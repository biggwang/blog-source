<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>bitgwang 의 무기고</title>
  <icon>https://www.gravatar.com/avatar/b01a31448e399300a64899d7eca81099</icon>
  <subtitle>차근차근 쌓아가자</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://biggwang.github.io/"/>
  <updated>2018-12-26T14:52:11.170Z</updated>
  <id>https://biggwang.github.io/</id>
  
  <author>
    <name>Yungwang Ryu</name>
    <email>ghmryg@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>개발자 어떻게 공부 해야 할까</title>
    <link href="https://biggwang.github.io/2018/12/26/%5Bmeta%5D%20%EA%B0%9C%EB%B0%9C%EC%9E%90%20%EC%96%B4%EB%96%BB%EA%B2%8C%20%EA%B3%B5%EB%B6%80%20%ED%95%B4%EC%95%BC%20%ED%95%A0%EA%B9%8C/"/>
    <id>https://biggwang.github.io/2018/12/26/[meta] 개발자 어떻게 공부 해야 할까/</id>
    <published>2018-12-26T14:41:21.000Z</published>
    <updated>2018-12-26T14:52:11.170Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="작성-동기">작성 동기</span></h1><p>개발자 어떻게 공부 해야 할까? 그 대답을 찾기위해 고민하고 스스롭 방법을 정립을 머릿속으로만 하였다.<br><strong>“개발자 공부”</strong> 에 대한 선배 개발자님들에 영감을 얻고 내 나름데로 생각을 정리하고 방법을 정립하기 위해 작성해 본다.</p><h1><span id="먼저-영감을준-선배-개발자님들에-조언-정리">먼저 영감을준 선배 개발자님들에 조언 정리</span></h1><h2><span id="개발자의-평생-공부-임백준">개발자의 평생 공부 | 임백준</span></h2><hr><p><a href="https://goo.gl/26K1HE" rel="external nofollow noopener noreferrer" target="_blank">보러가기</a></p><h2><span id="개발자는-어떻게-성장해야-할까-강대명">개발자는 어떻게 성장해야 할까? | 강대명</span></h2><hr><p><a href="https://goo.gl/4fcv6r" rel="external nofollow noopener noreferrer" target="_blank">보러가기</a></p><h3><span id="내가-흥미-있는-주제-위주로-블로그-하기">내가 흥미 있는 주제 위주로 블로그 하기</span></h3><h3><span id="나의-토이-프로젝트-공개하기">나의 토이 프로젝트 공개하기</span></h3><h3><span id="팀에서-사용하지-않는-기술이라면-그럼-나혼자-사용해-봄으로써-기술을-습득하면-된다">팀에서 사용하지 않는 기술이라면 그럼 나혼자 사용해 봄으로써 기술을 습득하면 된다.</span></h3><h3><span id="실력">실력</span></h3><h4><span id="지금-얼마나-알고-있는지">지금 얼마나 알고 있는지</span></h4><h4><span id="얼마나-빨리-배우는지">얼마나 빨리 배우는지</span></h4><h4><span id="지속적으로-학습하는지">지속적으로 학습하는지</span></h4><h3><span id="실력보다-중요한것은">실력보다 중요한것은?</span></h3><h4><span id="커뮤니케이션">커뮤니케이션</span></h4><ul><li>함께 일하고 싶은 동료인가?</li><li>정보 공유를 잘하고 나의 생산성을 향상시켜줄 수 있는 사람</li><li>나중에 우리팀에 함께 일하고자 추천 할 수 있는 사람</li></ul><p>위 질문에 Yes! 라고 주변에서 말할수 있는 상태라면 성실하고 잘하는 개발자이며 나아가 사람들과 잘 소통하고 끌어당기는 힘 개발 그이상에 힘이 있다고 생각한다.</p><h2><span id="오픈소스-개발자-이야기-20170701_오픈소스-개발자의-공부방법강대명">오픈소스 개발자 이야기 20170701_오픈소스 개발자의 공부방법(강대명)</span></h2><hr><p><a href="https://goo.gl/7C17Tw" rel="external nofollow noopener noreferrer" target="_blank">보러가기</a></p><h3><span id="절대적인-노력과-시간은-필요함">절대적인 노력과 시간은 필요함</span></h3><h3><span id="기반지식">기반지식</span></h3><p>강대명 개발자님은 새로운 것을 접할 때 쉬운책을 3~4권 정도 본다든지 어떤 기술을 습득할 때 이 기술이 왜 탄생했는지에 대한 탄생,역사 등을 접한다고 했다.<br>이것은 기반지식을 쌓는 행위라고 생각한다. 예전 부터 나도 기반지식에 대한 의미를 생각 했었는데 누군가의 이야기가 이해 되지 않는 경우는 2가지라고 했다.</p><ul><li>내용자체가 어려운 경우</li><li>기반 지식(컨텍스트)이 부족한 경우</li></ul><p>바로 2번째 경우에서 기반 지식은 곧 이해와 직결되는 사항이라 생각한다.<br>이해라는 전체적인 그림을 그리기 위해서 각 기반 지식들이 퍼즐 조각과도 같은 것이다.<br>따라서 새로운 개념을 습득할 때 기반지식이 없는 상태라면 아래와 같은 행위로 기반지식을 많이 쌓아두면 점점 익숙해져서 더 많이 깨닿고 습득 할 수 있을 거라 생각한다.</p><ul><li>쉬운 개념부터 0부터 100까지 빠르게 습득한다. (예) 기본 서적, 동영상, 블로그 활용)</li><li>탄생, 역사에 대한 히스토리를 보며 탄생의도를 파악한다.</li><li>제일 중요한건 내가 배우고 싶어하는 호기심과 관심이다.</li><li>그 관심을 가지고 토이프로젝트를 하면 최고다.</li><li>그 과정에서 알게되고 적용했을때 즐거움이 좋은 선순환을 만들 것이다.</li></ul><h3><span id="공부-방법에-중요성">공부 방법에 중요성</span></h3><blockquote><p>추가적인 지식습득 없이 특정 방법으로 14%의 수학 성적 향상<br>올바른 방법만 바꿔도 Input 되는 지식없이도 실력이 향상된다는 것이고 이는 프로그래밍에도 적용된다고 한다.<br>나 또한 같은 생각이며 항상 올바른 방법을 추가하며 공부해야 한다고 생각한다.</p></blockquote><h3><span id="의식적인-연습">의식적인 연습</span></h3><h4><span id="스타크래프트-럴커-피하기-연습">스타크래프트 럴커 피하기 연습</span></h4><p>프로게이머는 럴커 피하기 연습을 할 때 촉수가 delay 되는 시간 촉수를 피하기 위해 마우스 포인터 위치를 파악하여 끊임없는 반복 연습을 하여 럴커를 피하게 된다.</p><blockquote><p>의식적 연습이란 럴커를 피하기 위한 의식적 생각에 답으로 delay 시간과 마우스 포인트 위치를 파악하여 집중 노력을 했다는 것이다.<br>프로그래머가 어떠한 새로운 개념,기술,지식을 습득하기 위해선 내가 얻고자 하는 그 무언가를 전략적이고 의식적인 생각을 통해 끊임없이 노력, 제대로 된 노력, 정확 노력을 집중해서 하는 것이라고 생각한다.</p></blockquote><p>관련된 내용에 추천 책</p><ul><li><a href="https://goo.gl/DB6dKW" rel="external nofollow noopener noreferrer" target="_blank">아웃라이어</a></li><li><a href="https://goo.gl/AbmyPJ" rel="external nofollow noopener noreferrer" target="_blank">1만 시간의 재발견</a></li></ul><h3><span id="피드백">피드백</span></h3><p>반드시 필요한 단계이다.<br>투입한 나의 코스트가 낭비되지 않으려면 최대한 빨리 피드백을 받아 나의 상태를 진단하여 무엇이 잘못된지를 파악하여 계획을 다시 잡을 수 있다.</p><blockquote><p>제가 아는 모분은 아는 사람 볼때마다 코드 리뷰 부탁합니다.</p></blockquote><p>정말 개발을 잘하고 싶어하는 의지가 보이는 개발자인거 같다.<br>나도 위와 같은 행동이 정말 필요하다 생각하는데 실천은 잘 안되는거 같다.<br>정말 빨리 배우고 습득하고 싶다면 반드시 필요한 행동이라 생각한다.</p><p>피드백 받는 방법은</p><ul><li>잘하는 선배 개발자에게 질문, 리뷰 요청</li><li>웹상에서 질문</li><li>오픈소스 개발 활동</li></ul><h3><span id="교정">교정</span></h3><p>피드백을 통해 알게 된 내용을 바탕으로 실제 고쳐서 적용하는 것</p><h3><span id="그리고-다시-의식적인-연습">그리고 다시 의식적인 연습</span></h3><p>고쳐진 방법으로 다시 의식적인 연습</p><h2><span id="그래서-나는-어떻게">그래서 나는 어떻게??</span></h2><hr><h3><span id="의식적연습-gt-피드백-gt-교정-gt-의시적연습-반복">의식적연습 -&gt; 피드백 -&gt; 교정 -&gt; 의시적연습 반복</span></h3><p>각 단계에 대한 충실하게 지속적인 실천을 한다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;작성-동기&quot;&gt;작성 동기&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;개발자 어떻게 공부 해야 할까? 그 대답을 찾기위해 고민하고 스스롭 방법을 정립을 머릿속으로만 하였다.&lt;br&gt;
&lt;strong&gt;“개발자 공부”&lt;/strong&gt; 에 대한 선배 개발
      
    
    </summary>
    
    
      <category term="메타" scheme="https://biggwang.github.io/tags/%EB%A9%94%ED%83%80/"/>
    
      <category term="개발일반" scheme="https://biggwang.github.io/tags/%EA%B0%9C%EB%B0%9C%EC%9D%BC%EB%B0%98/"/>
    
  </entry>
  
  <entry>
    <title>새로운 개념 어떻게 습득해야 할까</title>
    <link href="https://biggwang.github.io/2018/12/12/%5Bmeta%5D%20%EC%83%88%EB%A1%9C%EC%9A%B4%20%EA%B0%9C%EB%85%90%20%EC%96%B4%EB%96%BB%EA%B2%8C%20%EC%8A%B5%EB%93%9D%ED%95%B4%EC%95%BC%20%ED%95%A0%EA%B9%8C/"/>
    <id>https://biggwang.github.io/2018/12/12/[meta] 새로운 개념 어떻게 습득해야 할까/</id>
    <published>2018-12-11T15:18:21.000Z</published>
    <updated>2018-12-26T13:11:54.487Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="새로운-개념-습득-어떻게">새로운 개념 습득 어떻게?</span></h1><p>소프트웨어 개발자로 살고 있는 나는 홍수같이 터져 나오는 많은 기술들에 대해서 다 알아둬야 할 것 같아서 허덕거렸다.<br>이 많은 것을 언제 다 배우지? 그것은 중압감과 압박감으로 스트레스로 이루어 졌고<br>일하면서 알게된 지식들 정리하기도 벅찬데 육아하면서 새로운 개념은 언제 습득 할까…</p><p>하지만 다른 개발들에 생각들을 웹에서 접하면서 새로운 기술을 배우는 것에 초점을 맞추는게 아니라<br>새로운 기술들을 잘 배울려면 나는 어떻게 해야 할까?? 라는 좀 더 근본적인 다시 말해 메타 생각을 가지게 되었다.</p><p>다 배울 필요없고 미리 배울 필요도 없다. 그냥 써야 되는 상황이 오면 그때 습득하여 적용하면 되는 것이다.</p><p>어짜피 미리 배워봤자 머릿속에 장기기억으로 잘 이루어지지 않는다.<br>왜냐하면 설사 습득하였다 하더라도 습득한 기술이<br>정말 절실하고 필요해서 사용한 것이 아니기 때문에 잘 와닿지도 않아 뇌 신경망을 그리 자극시키지 않기 때문이다.</p><p>평소에 쓰는 기술들로 다시 머릿속을 채울뿐이다.</p><p>한마디로 밑빠진독에 물붓기…</p><p>그럼 다시 돌아와서 내가 중요하게 생각하는것은 새로운 개념을 어떻게 해야 빠르고 정확하게 잘 습득하여 적용/응용 할 수 있을까? 라는 대답이다.</p><p>시간 날때마다 생각해본 나의 생각과 참고한 사이트 기반으로 정리한 방법은 아래와 같다. <a href="https://goo.gl/XNsHZv" rel="external nofollow noopener noreferrer" target="_blank">원문</a> / <a href="https://goo.gl/di0BnJ" rel="external nofollow noopener noreferrer" target="_blank">번역</a></p><h1><span id="그래서-어떻게-하라고">그래서 어떻게 하라고?</span></h1><h2><span id="step1-튜토리얼-데로-따라해보자">Step1 튜토리얼 데로 따라해보자</span></h2><h3><span id="익숙해지는게-목표">익숙해지는게 목표</span></h3><ul><li>처음 접한 것이기 때문에 이해라는 그림에 퍼즐조각을 많이 확보해야 함</li><li>퍼즐조각이 많을수록 이해도가 증가함</li><li>모르는것이 천지이기 때문에 모른다고 시간 잡아 먹으면 끝도 없음 일단 끝까지 완주 하는게 목표</li></ul><h2><span id="step2-튜토리얼-따라하면서-몰랐던-내용-조사">Step2 튜토리얼 따라하면서 몰랐던 내용 조사</span></h2><ul><li>Step1 에서 궁금증을 푸는 단계</li><li>삽질은 반드시 필요하며 머릿속에 넣는 고통에 대가이자 필수 재료이다.</li><li>책, 인터넷 서치, 커뮤니티, 지인 질문 등 다양한 방법으로 모르는 것을 해결하자</li></ul><h2><span id="step3-내가-만들고-싶은것을-만들어보자">Step3 내가 만들고 싶은것을 만들어보자</span></h2><ul><li>새로운 것을 습득하려는 이유가 반드시 있을것이다.</li><li>그 이유가 무엇인가??</li><li>그 이유를 바탕으로 내가 만들고 싶은걸 만들어야 동기가 생기고 재밋게 개발할 수 있다.</li></ul><h2><span id="step4-방출하기">Step4 방출하기</span></h2><ul><li>머릿속에 든 내용을 꺼내야 장기기억으로 이어짐</li><li>그 수단은 포스팅, 누군가에게 이해시키기 등이 있다.</li></ul><h1><span id="의식적-연습">의식적 연습</span></h1><p>node.js 기반 스케줄 모듈 만들어 보자</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;새로운-개념-습득-어떻게&quot;&gt;새로운 개념 습득 어떻게?&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;소프트웨어 개발자로 살고 있는 나는 홍수같이 터져 나오는 많은 기술들에 대해서 다 알아둬야 할 것 같아서 허덕거렸다.&lt;br&gt;
이 많은 것을 언제 
      
    
    </summary>
    
    
      <category term="메타" scheme="https://biggwang.github.io/tags/%EB%A9%94%ED%83%80/"/>
    
  </entry>
  
  <entry>
    <title>Quartz를 활용한 실시간 배치 동적 스케줄러 사용기</title>
    <link href="https://biggwang.github.io/2018/12/05/%5Bquartz%5D%20%EC%8B%A4%EC%8B%9C%EA%B0%84%20%EB%B0%B0%EC%B9%98%20%EB%8F%99%EC%A0%81%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC%20%EC%82%AC%EC%9A%A9%EA%B8%B0/"/>
    <id>https://biggwang.github.io/2018/12/05/[quartz] 실시간 배치 동적 스케줄러 사용기/</id>
    <published>2018-12-05T13:32:21.000Z</published>
    <updated>2018-12-07T15:08:39.402Z</updated>
    
    <content type="html"><![CDATA[<h1><span id="어떤-시스템인가">어떤 시스템인가</span></h1><ul><li>DB 접속하여 데이터를 실시간 주기로 데이터를 targetDB에 적재하는 스케줄러 배치 모듈</li><li>서버 중단 없이 스케줄 주기 동적 변경</li><li>서버 중단 없이 이관 DB 추가 하여 스케줄 배치 수행</li><li>이관해야 하는 DB 접속수가 늘어나도 각각 스케쥴 배치 수행</li><li>기본적 서버 이중화 이지만 서버가 늘어나도 서버별 스케줄 배치 수행 (서버 클러스터링)</li><li>한쪽 서버가 죽어도 나머지 서버가 죽은 서버의 스케줄 배치 까지 수행</li></ul><h1><span id="왜-quartz를-사용-하였는가">왜 Quartz를 사용 하였는가</span></h1><img src="/2018/12/05/[quartz]%20실시간%20배치%20동적%20스케줄러%20사용기/post_clustering.jpg">  <ul><li>서버 클러스터링을 사용하기 위해</li><li>서버 클러스터링이 필요한 이유는 만들고자 하는 배치 스케줄 모듈이 시간이 지날수록 이관해야 하는 DB가 늘어나는 만큼 서버 부하를 분산시키기 위해</li></ul><h2><span id="quartz-clsutering-동작-과정">quartz clsutering 동작 과정</span></h2><p>아래 표는 실제 서버를 각각 shutdown 시켜가면서 quartz clustering 동작을 눈으로 확인한 과정을 적은 것이다.</p><img src="/2018/12/05/[quartz]%20실시간%20배치%20동적%20스케줄러%20사용기/post-quartz-clustering-mode-example.png">  <h2><span id="그럼-도대체-clustering-기능은-어떻게-사용한단-말인가">그럼 도대체 clustering 기능은 어떻게 사용한단 말인가</span></h2><ul><li>quartz 테이블 생성 <a href="https://goo.gl/HyRE2Q" rel="external nofollow noopener noreferrer" target="_blank">[생성 스크립트 이동]</a></li><li>quartz instance property 설정</li><li>quartz jobStore property 설정  (property 설정 방법은 아래 quartz 설정 방법 부분 참고)</li></ul><p>Quartz instance property 에 대한 공식 설명을 먼저 보자</p><blockquote><p>org.quartz.scheduler.instanceName<br>Can be any string, and the value has no meaning to the scheduler itself - but rather serves as a mechanism for client code to distinguish schedulers when multiple instances are used within the same program. If you are using the clustering features, you must use the same name for every instance in the cluster that is ‘logically’ the same Scheduler.</p></blockquote><blockquote><p>org.quartz.scheduler.instanceId<br>Can be any string, but must be unique for all schedulers working as if they are the same ‘logical’ Scheduler within a cluster. You may use the value “AUTO” as the instanceId if you wish the Id to be generated for you. Or the value “SYS_PROP” if you want the value to come from the system property “org.quartz.scheduler.instanceId”.</p></blockquote><p>정리하면 cluster mode를 사용하려면 같은 instanceName을 가진 서버별 고유에 instanceId를 가져야 cluster mode를 이용 할 수 있다는 뜻이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// scheduler identity</span><br><span class="line">org.quartz.scheduler.instanceName = QUAARTZ-SCHEDULER</span><br><span class="line">org.quartz.scheduler.instanceId = MASTER</span><br><span class="line"></span><br><span class="line">// cluster 관련 설정</span><br><span class="line">org.quartz.jobStore.misfireThreshold = 60000</span><br><span class="line">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX</span><br><span class="line">org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.MSSQLDelegate</span><br><span class="line">org.quartz.jobStore.dataSource = myDS</span><br><span class="line">org.quartz.jobStore.tablePrefix = QRTZ_</span><br><span class="line">org.quartz.jobStore.isClustered = true</span><br><span class="line">org.quartz.jobStore.clusterCheckinInterval = 1000</span><br></pre></td></tr></table></figure><p>그 밖의 quartz config 설정은 <a href="https://goo.gl/jXEZfS" rel="external nofollow noopener noreferrer" target="_blank">quartz 레퍼런스 문서</a>를 보는게 제일 정확하므로 참고하여 설정하면 된다.</p><h1><span id="quartz-셋팅">Quartz 셋팅</span></h1><h2><span id="프로젝트-환경-및-버전">프로젝트 환경 및 버전</span></h2><p>Java8 + Spring 3.1.1 + Quartz 2.2.1 + Maven</p><h2><span id="spring-4-일-경우는-아래-추가로-dependency-해주어야-한다">Spring 4 일 경우는 아래 추가로 dependency 해주어야 한다.</span></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>해주지 않으면  org.springframework.scheduling.quartz 패키지가 존재 하지 않는다. (Spring 3은 spring-context-support dependency 안해줘도 됨)</p><h2><span id="quartz-spring-bean-등록">Quartz Spring Bean 등록</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SchedulerFactoryBean <span class="title">quartzScheduler</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">schedulerFactoryBean = <span class="keyword">new</span> SchedulerFactoryBean();</span><br><span class="line"></span><br><span class="line">schedulerFactoryBean.setSchedulerName(<span class="string">"name"</span>);</span><br><span class="line">AutowiringSpringBeanJobFactory jobFactory = <span class="keyword">new</span> AutowiringSpringBeanJobFactory();</span><br><span class="line">jobFactory.setApplicationContext(applicationContext);</span><br><span class="line"></span><br><span class="line">schedulerFactoryBean.setJobFactory(jobFactory);</span><br><span class="line">schedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">schedulerFactoryBean.setOverwriteExistingJobs(<span class="keyword">true</span>);</span><br><span class="line">schedulerFactoryBean.setAutoStartup(<span class="keyword">true</span>);</span><br><span class="line">schedulerFactoryBean.setQuartzProperties(quartzProperties());</span><br><span class="line"><span class="keyword">return</span> schedulerFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="객체-설명">객체 설명</span></h2><h3><span id="schedulerfactorybean-객체-orgspringframeworkschedulingquartz">SchedulerFactoryBean 객체 (org.springframework.scheduling.quartz)</span></h3><p>Spring Framework에서 Quartz를 bean으로 관리하기 위해 필요한 클래스로 Spring에서 Quartz를 사용하기 위해 필요함</p><h3><span id="autowiringspringbeanjobfactory-객체">AutowiringSpringBeanJobFactory 객체</span></h3><p>org.quartz.Job 을 implements한 Job 클래스내에서 @Autowired 할 수 있도록 하기 위해서 사용함</p><h2><span id="왜-필요한가">왜 필요한가</span></h2><p>구현한 Job 클래스에서 주입 받아야 하는 경우가 반드시 존재 하기 때문이다.<br>예를 들면 DAO 클래스 이다. 필자 같은 경우는 데이터를 DB INSERT 해야하는 경우로 Job 클래스에 DAO를 반드시 주입받아야 하기에 반드시 필요했다.<br>만약 객체를 생성하지 않으면 @Autowired 해도 객체가 null 이다.</p><h2><span id="그럼-왜-autowiringspringbeanjobfactory-객체-생성해야-autowired-할-수-있었을까">그럼 왜 AutowiringSpringBeanJobFactory 객체 생성해야 @Autowired 할 수 있었을까??</span></h2><p>해당 내용은 Spring Container 어떻게 Bean을 관리하는지에 대한 개념을 알아야 이해 할 수 있으며 해당 개념을 필자도 알고 싶어서 조사해 봤다.<br>그냥 추가해야 된다는 것만 알고 넘어 가고 싶다면 다음 주제로 넘어가면 되고 Spring이 bean 관리 메커니즘에 대해 궁금 하다면 아래를 보자</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.spi.TriggerFiredBundle;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.AutowireCapableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.quartz.SpringBeanJobFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiringSpringBeanJobFactory</span> <span class="keyword">extends</span> <span class="title">SpringBeanJobFactory</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> AutowireCapableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">beanFactory = applicationContext.getAutowireCapableBeanFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createJobInstance</span><span class="params">(TriggerFiredBundle bundle)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">final</span> Object job = <span class="keyword">super</span>.createJobInstance(bundle);</span><br><span class="line">beanFactory.autowireBean(job);</span><br><span class="line"><span class="keyword">return</span> job;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// TODO Posting spring은 어떻게 bean관리를 하는가</p><h2><span id="quartz-실행-화면">Quartz 실행 화면</span></h2><img src="/2018/12/05/[quartz]%20실시간%20배치%20동적%20스케줄러%20사용기/post-quartz-clustering-mode-log.png">  <p>quartz 셋팅을 마치고 was를 기동하면 위 로그와 같이 quartz 버전, 클러스터 모드 on/off 여부, Thread pool 갯수 등 정보가 나온다.<br>cluster mode가 제대로 동작한다면 노란색 박스 로그와 같이 설정한 check interval time에 맞게 로그가 계속 찍힐 것이다.<br>다른 서버가 살아있는지 계속 체크하고 있는 것이다. (로그를 볼때는 debug 레벨로 해야 보임)</p><h2><span id="그-밖의">그 밖의</span></h2><h3><span id="disallowconcurrentexecution">@DisallowConcurrentExecution</span></h3><p>Thread Pool 기반으로 동작하는 Quatrz에서 Job에 대한 Thread 동시 접근으로 인해 데이터 중복을 방지하기 위한 어노테이션 인거 같다.<br>나는 동시접근 못하게 코드로 막았는데 이런게 있는줄 알았으면 쉽게 해결했을거 같다.</p><h2><span id="남은것은">남은것은?</span></h2><ul><li>quartz 레퍼런스 문서를 더 꼼꼼히 보고 best pratice 데로 하고있는지 점검</li><li>quartz + spring batch 조합 해보기</li><li>리펙토링</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1&gt;&lt;span id=&quot;어떤-시스템인가&quot;&gt;어떤 시스템인가&lt;/span&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;DB 접속하여 데이터를 실시간 주기로 데이터를 targetDB에 적재하는 스케줄러 배치 모듈&lt;/li&gt;
&lt;li&gt;서버 중단 없이 스케줄 주기 동적 변경&lt;/li
      
    
    </summary>
    
    
      <category term="Library" scheme="https://biggwang.github.io/tags/Library/"/>
    
      <category term="Quartz" scheme="https://biggwang.github.io/tags/Quartz/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP 적용시 주의사항</title>
    <link href="https://biggwang.github.io/2018/12/04/%5Bspring%5DSpring%20AOP%20%EC%A0%81%EC%9A%A9%EC%8B%9C%20%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD/"/>
    <id>https://biggwang.github.io/2018/12/04/[spring]Spring AOP 적용시 주의사항/</id>
    <published>2018-12-03T16:03:21.000Z</published>
    <updated>2018-12-04T15:37:44.126Z</updated>
    
    <content type="html"><![CDATA[<h2><span id="기반개념">기반개념</span></h2><hr><p>1.Componet Scan<br>2.Root-context, servlet-context<br>3.Spring AOP 방식</p><h2><span id="현상">현상</span></h2><hr><p>1.point cut excution 패턴 적용 하였지만 특정 패키지에서만 동작이 되고 Scheduled 사용된 클래스에서는 AOP 적용, 즉 트랜잭션 rollback이 안됨<br>2.exception 발생시 catch 문에서 기존 동작 rollback하고 오류에 대한 insert를 하려 하는데 insert 까지 같이 rollback 됨</p><h2><span id="원인">원인</span></h2><hr><p>1.클래스내 모든 메소드가 private 메소드는 AOP 대상이 아님  <a href="https://goo.gl/rQnG4w" rel="external nofollow noopener noreferrer" target="_blank">참고</a><br>2.Spring AOP와 소스내 트랜잭션 rollback과 충돌 및 겹침 <a href="https://goo.gl/reS6sF" rel="external nofollow noopener noreferrer" target="_blank">참고</a></p><h2><span id="해결">해결</span></h2><hr><p>1번 원인만 해결하면 된다면 특정 메소드 public으로 바꿔주면 해결된다. 대신 exception 발생시 무조건 rollback 된다. 정확히 말해서 해당 service단 클래스에서 완전히 throw해주어야 rollback이 된다.</p><p>하지만 특정시점까지만 rollback 하고 그다움부턴 정상 commit 하고 싶은경우도 분명히 존재한다. 현상 2처럼 말이다. 그럴땐 Spring AOP 방식을 적용하지 않게 해야 한다. 안그러면 원인 2 처럼 되어 모두 rollback 이 되어 버린다.</p><p>따라서 원인 2를 해결하려면 모두 메소드를 private으로 바꾸고 소스내에서 commit / rollback 을 수행하면 된다.</p><h2><span id="코드">코드</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*** 생략</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (Map&lt;String, Object&gt; map : mBatchList) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 서비스별 dataSource 정보 갱신</span></span><br><span class="line">  bds = mDbConnMng.reNewDataSource(map.get(<span class="string">"driver"</span>).toString(), map.get(<span class="string">"url"</span>).toString(),map.get(<span class="string">"username"</span>).toString(),map.get(<span class="string">"password"</span>).toString());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// session open</span></span><br><span class="line">  session = mDbConnMng.openSession(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mapper 호출</span></span><br><span class="line">  dao = session.getMapper(TransDataDao.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ###### case 1 ######</span></span><br><span class="line">  <span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">  // 해당 클래스 메소드 모두 private --&gt; update 정상 동작</span></span><br><span class="line"><span class="comment">  // 해당 클래스 메소드 한개 이상 public --&gt; update 도 rollback 됨</span></span><br><span class="line"><span class="comment">  // 정리하면</span></span><br><span class="line"><span class="comment">  // Spring AOP Transaction 걸었는데 메소드내 트랜잭션 가져오면 충돌 나서 함수단위로 rollback이 안됨..</span></span><br><span class="line"><span class="comment">  // 메소드내 트랜잭션 가져오려면 해당 클래스내 메소드를 모두 private로 해야 함..</span></span><br><span class="line"><span class="comment">  // 반대로 Spring AOP Transaction 걸려면 public 메소드가 한개라도 있어야 함</span></span><br><span class="line"><span class="comment">  ***************************************************************/</span></span><br><span class="line"></span><br><span class="line">  insertFirstData();</span><br><span class="line">  session.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertFirstData</span> <span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ##### case 4 ###### worker 메소드 private으로 바꿈 (모든 메소드 private 이어야 함)</span></span><br><span class="line">  DefaultTransactionDefinition def = <span class="keyword">new</span> DefaultTransactionDefinition();</span><br><span class="line">  def.setName(<span class="string">"insert tx"</span>);</span><br><span class="line">  def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class="line">  TransactionStatus status = iCalDbConnection.getTransaction(def);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> result = loadDataDao.insertData();</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">    &#125;</span><br><span class="line">    iCalDbConnection.commit(status);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    iCalDbConnection.rollback(status);</span><br><span class="line">    updateTest();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateTest</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = loadDataDao.updateTest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// console log</span></span><br><span class="line"><span class="number">13</span>:<span class="number">49</span>:<span class="number">50</span> INFO &#123;<span class="function">call <span class="title">SET_CAL_BISMALLLITE_INSERT</span><span class="params">()</span> &#125; <span class="comment">// rollback 대상</span></span></span><br><span class="line"><span class="function">13:49:50 INFO |-------|</span></span><br><span class="line"><span class="function">13:49:50 INFO |RESULT |</span></span><br><span class="line"><span class="function">13:49:50 INFO |-------|</span></span><br><span class="line"><span class="function">13:49:50 INFO |1 |</span></span><br><span class="line"><span class="function">13:49:50 INFO |-------|</span></span><br><span class="line"><span class="function">13:49:52 INFO </span>&#123;<span class="function">call <span class="title">SP_SET_BATCH_LOG_UPDATE</span><span class="params">(<span class="string">'F'</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="string">'N'</span>, <span class="string">'ERR_CD!!!'</span>, <span class="string">'ERROR 발생!!!!!!!'</span>)</span> &#125;  <span class="comment">// insert/update 대상</span></span></span><br><span class="line"><span class="function">13:49:52 INFO |-------|</span></span><br><span class="line"><span class="function">13:49:52 INFO |result |</span></span><br><span class="line"><span class="function">13:49:52 INFO |-------|</span></span><br><span class="line"><span class="function">13:49:52 INFO |1 |</span></span><br><span class="line"><span class="function">13:49:52 INFO |-------|</span></span><br></pre></td></tr></table></figure><h2><span id="공부해야-할-개념">공부해야 할 개념</span></h2><hr><p>1.Spring AOP 동작 방식</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;&lt;span id=&quot;기반개념&quot;&gt;기반개념&lt;/span&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;1.Componet Scan&lt;br&gt;
2.Root-context, servlet-context&lt;br&gt;
3.Spring AOP 방식&lt;/p&gt;
&lt;h2&gt;&lt;span id=&quot;현상&quot;&gt;현
      
    
    </summary>
    
    
      <category term="Framework" scheme="https://biggwang.github.io/tags/Framework/"/>
    
      <category term="Spring" scheme="https://biggwang.github.io/tags/Spring/"/>
    
  </entry>
  
</feed>
