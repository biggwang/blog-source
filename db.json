{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/img/me.jpg","path":"img/me.jpg","modified":0,"renderable":0},{"_id":"source/img/icon_wechat.png","path":"img/icon_wechat.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/css/archive.styl","path":"css/archive.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.min.css","path":"css/beantech.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/beantech.css","path":"css/beantech.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/rocket.styl","path":"css/rocket.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/signature.styl","path":"css/signature.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/toc.styl","path":"css/toc.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/widget.styl","path":"css/widget.styl","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/hux-blog.min.css","path":"css/hux-blog.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.js","path":"js/hux-blog.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/hux-blog.min.js","path":"js/hux-blog.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.nav.js","path":"js/jquery.nav.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/toc.js","path":"js/toc.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"source/img/404-bg.jpg","path":"img/404-bg.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"source/img/header_img/Iron-Man-3.jpg","path":"img/header_img/Iron-Man-3.jpg","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/ironman.png","path":"css/images/ironman.png","modified":0,"renderable":1},{"_id":"themes/beantech/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":0},{"_id":"source/img/ironman-draw.png","path":"img/ironman-draw.png","modified":0,"renderable":0},{"_id":"source/img/signature/BeanTechSign-white.png","path":"img/signature/BeanTechSign-white.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"source/img/signature/BeanTechSign-black.png","path":"img/signature/BeanTechSign-black.png","modified":0,"renderable":0},{"_id":"source/img/header_img/tf-logo-dark.png","path":"img/header_img/tf-logo-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/bg_computer.jpg","path":"img/header_img/bg_computer.jpg","modified":0,"renderable":0},{"_id":"source/img/header_img/bg_computer.png","path":"img/header_img/bg_computer.png","modified":0,"renderable":0},{"_id":"themes/beantech/source/fonts/NANUMSQUAREROUNDB.TTF","path":"fonts/NANUMSQUAREROUNDB.TTF","modified":0,"renderable":1},{"_id":"source/img/header_img/tag-bg.png","path":"img/header_img/tag-bg.png","modified":0,"renderable":0},{"_id":"source/img/beantech-desktop.png","path":"img/beantech-desktop.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-2-dark.png","path":"img/header_img/home-bg-2-dark.png","modified":0,"renderable":0},{"_id":"source/img/header_img/home-bg-o.png","path":"img/header_img/home-bg-o.png","modified":0,"renderable":0},{"_id":"source/img/header_img/archive-bg.png","path":"img/header_img/archive-bg.png","modified":0,"renderable":0}],"Cache":[{"_id":"themes/beantech/_config.yml","hash":"36340a31ee7c937aa8d940236a29e281fe15ecb1","modified":1545494331885},{"_id":"themes/beantech/LICENSE","hash":"c48eaae47a703282e0ffe7b91d69366452046214","modified":1543851545919},{"_id":"source/404.md","hash":"8d0d831a77fe92a9e1530366ed90dec6d73d3aef","modified":1543851545788},{"_id":"source/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1543851545789},{"_id":"themes/beantech/languages_to_be_added/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1543851545921},{"_id":"themes/beantech/languages_to_be_added/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1543851545921},{"_id":"themes/beantech/languages_to_be_added/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1543851545922},{"_id":"themes/beantech/languages_to_be_added/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1543851545922},{"_id":"themes/beantech/languages_to_be_added/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1543851545922},{"_id":"themes/beantech/languages_to_be_added/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1543851545923},{"_id":"themes/beantech/languages_to_be_added/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1543851545924},{"_id":"themes/beantech/layout/404.ejs","hash":"c9b488d74c21fe9f35f642a5d19a138099ddf8a8","modified":1543851545925},{"_id":"themes/beantech/languages_to_be_added/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1543851545925},{"_id":"themes/beantech/languages_to_be_added/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1543851545924},{"_id":"themes/beantech/layout/about.ejs","hash":"96c08fc3580b842ad9d8f37f2cdf02e6fa57d7bc","modified":1543851545934},{"_id":"themes/beantech/layout/index.ejs","hash":"f293cefe4bf9f9c6848dff08b6dac4aeb7948892","modified":1543851545934},{"_id":"themes/beantech/layout/archive.ejs","hash":"62781e8b0ce4de9c3db6042fedeaf13c26d138f8","modified":1543851545934},{"_id":"themes/beantech/layout/keynote.ejs","hash":"e177b9e4a159f40b512f4ae1bfd928be4ab60840","modified":1543851545935},{"_id":"themes/beantech/layout/layout.ejs","hash":"389fc11a45676f94b77ebd2cb0d658a0358979c8","modified":1543851545936},{"_id":"themes/beantech/layout/post.ejs","hash":"2d69c68b7dee4642e32ad0a9334bc93e0d7647a7","modified":1543936310688},{"_id":"themes/beantech/layout/page.ejs","hash":"f7fc5282ad55131aa67dcde03c9189faa450a7c9","modified":1543936437748},{"_id":"themes/beantech/layout/tags.ejs","hash":"63911a99e6daf9968bfdd7d69f0d3d697039902e","modified":1543851545937},{"_id":"source/_drafts/IDC에서 클라우드로.md","hash":"abdeb6338a508b149b52b4ebc51e55ef6095202a","modified":1566706870141},{"_id":"source/_drafts/Jenkins과 AWS로 코드가 빌드 배포되는 과정.md","hash":"26d294bdd060d28adc7bda67c9092bd973856096","modified":1566480743336},{"_id":"source/_drafts/docker compose 로 ngnix, spring boot, mysql 띄우기.md","hash":"3e95118f46a9a551f94496b615665bc0fc2f7ea9","modified":1567923050675},{"_id":"source/archive/index.md","hash":"21806fd262da492f2634d224f5846ccee9cd3b45","modified":1543851545839},{"_id":"source/about/index.md","hash":"2a389bbeda13c34af3ea0f2aa47712af5869de52","modified":1549441042636},{"_id":"source/tags/index.md","hash":"a4cdcade4001fdc71547462e0bd7feedee96038b","modified":1543851545918},{"_id":"source/img/me.jpg","hash":"1a276a9fd1558a2ae1d6707ac959e87af3d790dc","modified":1566108738475},{"_id":"source/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1543851545898},{"_id":"themes/beantech/layout/_partial/footer.ejs","hash":"6739744e71fc211a9e7c05c71c42b240c1f5abf7","modified":1543851545926},{"_id":"themes/beantech/layout/_partial/head.ejs","hash":"b6a08f40f65d8860b8eee17def8130c2cc9fdc78","modified":1568036531552},{"_id":"themes/beantech/layout/_partial/header.ejs","hash":"9aea336d3907735eedabcfb21c286cd54a01f45f","modified":1543851545927},{"_id":"themes/beantech/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1543851545928},{"_id":"themes/beantech/layout/_partial/nav.ejs","hash":"e65bfec3d14a9eb9f1e09b592bb34023e6bf6e83","modified":1543851545928},{"_id":"themes/beantech/layout/_partial/sidebar.ejs","hash":"bc7834dd769eeac94a76ffd9cfbb13a622861b62","modified":1543851545929},{"_id":"themes/beantech/layout/_partial/toc.ejs","hash":"a765433a33b3613f4664de2da48d0c58f68f8cd6","modified":1543851545930},{"_id":"themes/beantech/layout/_widget/archive.ejs","hash":"ad9fb0073d40fe90bfe3a1e3246e0b07e12b3ecf","modified":1543851545930},{"_id":"themes/beantech/layout/_widget/friends-blog.ejs","hash":"b185fcffb0d181ddd9eb2259af38cf7d82fb2846","modified":1543851545932},{"_id":"themes/beantech/layout/_widget/category.ejs","hash":"c32e6fb8f3a07c5cbaffcebf93c357237c18b009","modified":1543851545931},{"_id":"themes/beantech/layout/_widget/featured-tags.ejs","hash":"e29431fa78c81d7c521bb1f7be356651fcde959c","modified":1543851545931},{"_id":"themes/beantech/layout/_widget/recent-posts.ejs","hash":"814dd716083a8a75eb31f9d2d6ab28150b01c533","modified":1543851545933},{"_id":"themes/beantech/layout/_widget/short-about.ejs","hash":"91288381dbd98f1c6b91d419094934ff59437021","modified":1543851545933},{"_id":"themes/beantech/source/css/archive.styl","hash":"7fbe61178ba54fd306d60bbbdf66aa2d19d9bcca","modified":1545557273501},{"_id":"themes/beantech/source/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1543851545946},{"_id":"themes/beantech/source/css/highlight.styl","hash":"831f8195f3577ba5bea374f2e24b90054d445055","modified":1545555608421},{"_id":"themes/beantech/source/css/beantech.css","hash":"5e9bee0a553da83a3efd4e9bc975a0ebd13b1b7d","modified":1545563589268},{"_id":"themes/beantech/source/css/rocket.styl","hash":"0abbccdbcd6cce70e8a0bab7152c38adc0b708f1","modified":1543851545971},{"_id":"themes/beantech/source/css/signature.styl","hash":"63ae8051f59d5e69544647cc4173eabc81d99aae","modified":1543851545972},{"_id":"themes/beantech/source/css/toc.styl","hash":"822aca17c885109452cc75a9aa384d9f3c07ea81","modified":1545557521676},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1543851545974},{"_id":"themes/beantech/source/css/widget.styl","hash":"f996466e299c68274145ba5afaca9b6d1dd83114","modified":1543851545973},{"_id":"themes/beantech/source/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1543851545967},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1543851545983},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1543851545984},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1543851545984},{"_id":"themes/beantech/source/js/hux-blog.js","hash":"3d3c93e42a9990b2a2e6df5a08e9816f9a221e0f","modified":1543851546006},{"_id":"themes/beantech/source/js/hux-blog.min.js","hash":"ee99af17a1a69ac8d85a695fed0349ba202789ae","modified":1543851546008},{"_id":"themes/beantech/source/js/bootstrap.min.js","hash":"313da686ebbe387064f2d1899c64ea562b81eb40","modified":1543851546004},{"_id":"themes/beantech/source/js/jquery.nav.js","hash":"bc6383fa2aa8f437978cf044a3b6f10a65114398","modified":1543851546067},{"_id":"themes/beantech/source/js/jquery.tagcloud.js","hash":"448017ff32f75f444ed7985d10a21b3ad92ab100","modified":1543851546069},{"_id":"themes/beantech/source/js/toc.js","hash":"4ffe95b7755b035ee1b41664fa72b0ebea29c3f8","modified":1543851546071},{"_id":"source/_posts/API/[REST API] REST API란.md","hash":"2bbdf38e2778f9e8ddcd1b1eb28425815c51eb37","modified":1562769892390},{"_id":"themes/beantech/source/js/totop.js","hash":"f796b09b4f6177c3674a8c1542a8c92e8590cb5c","modified":1543851546072},{"_id":"source/_drafts/Jenkins과 AWS로 코드가 빌드 배포되는 과정/jenkins-deploy-process.png","hash":"90b05cd9286b19a79abf947b293ba6f110fe1473","modified":1566480325418},{"_id":"source/_posts/Build/Gradle로 빌드시 동적으로 yml 파일에 값 셋팅하기.md","hash":"f7c982595d9eb704c341ffd78874230f51b59b8d","modified":1566221316692},{"_id":"source/_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기.md","hash":"33469c237cf60caf1531dd1c4730122db9691e46","modified":1664544742995},{"_id":"source/_posts/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편.md","hash":"4a4d1ab560c42013d8b9c9f219aea45de26cd461","modified":1562769770438},{"_id":"source/_posts/ETC/서버가 여러대 있때 redirect 사용시 발생하는 문제.md","hash":"e386e48a80fccb41bd6e2e571da9662a11b0842a","modified":1566221096702},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편.md","hash":"af7c289f8a4348c70340820dcf36c9d0fc60b17f","modified":1562769770438},{"_id":"source/_posts/Design Patterns/[Design Patterns] 템플릿 메소드 패턴, 도대체 왜 쓰는거야-기본 이론편.md","hash":"4bec16c4b6ce57691dfc86df41ae632aca662d52","modified":1562769770437},{"_id":"source/_posts/Docker/Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기.md","hash":"803b1921db0b1b2e60c9a3834db670b384a124c9","modified":1569135634641},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편.md","hash":"c5d485269395ec48628936c945ab0c730d4436bc","modified":1562769770438},{"_id":"source/_posts/JPA/JPA N+1 문제 해결 방법.md","hash":"5306b9ba24c06f52b1ebf896eb51cc9a9d0d57cb","modified":1564056211116},{"_id":"source/_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법.md","hash":"497e4c849fc1f026cfbcb1b57d45013efc7ec71b","modified":1564233994907},{"_id":"source/_posts/JPA/JPA 커스텀 리파지토리 만드는 방법.md","hash":"0ea475cc2a817db62751d792bb0187538abf17fb","modified":1564495815654},{"_id":"source/_posts/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까.md","hash":"e70c5fc779fb8a06c27e28282b5592373f26c50e","modified":1562769869326},{"_id":"source/_posts/JPA/JPA 쿼리에 대해서.md","hash":"7b18ad92c080d6f38138e94f9b50cfbc889f0329","modified":1564495907532},{"_id":"source/_posts/OOP/01 객체,설계.md","hash":"606b3f1123f518f404731d6aff6437da6b8beecd","modified":1566109525591},{"_id":"source/_posts/OOP/02 객체 지향 프로그래밍.md","hash":"609a2c0a6bb2d7b6ef0ca2b06541ebae50ca7ce3","modified":1566108539622},{"_id":"source/_posts/OOP/객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유.md","hash":"6819252d13ada4f6fbc63040a5ef7453f2517006","modified":1566108544255},{"_id":"source/_posts/OOP/객체 지향 설계 5대 원칙.md","hash":"f90a54edb93d0eb56c71372262e7e8774bc4c3fe","modified":1566108558441},{"_id":"source/_posts/JS/document ready 의미.md","hash":"b1891c7f2cdffee499d720895708f7f9b6d5d2da","modified":1567866389082},{"_id":"source/_posts/OOP/객체지향 캡슐화 그것이 알고 싶다.md","hash":"567baa82677dc5778860a73f196787cd8f032766","modified":1566108555910},{"_id":"source/_posts/OOP/상속보다는 합성을 사용해야 하는 이유.md","hash":"fa19f9e06c73167759dd1ce17efa2aab03b39181","modified":1566111334986},{"_id":"source/_posts/Spock/Spock 으로 Controller 파일 업로드 테스트 해보기.md","hash":"fd5acadd2dbf3d5f28ce7fe031aad17debcb6586","modified":1566221040366},{"_id":"source/_posts/메타인지/[meta] 개발자 논리적인 사고력에 대해서.md","hash":"3334b590b3bd09e37bd8b2791744f7f958c9a931","modified":1562769809735},{"_id":"source/_posts/메타인지/[meta] 개발자 어떻게 공부 해야 할까.md","hash":"3e82f564922c20dd73c2d17d6d984b79ed766bb5","modified":1562769809736},{"_id":"source/_posts/회고/2018년 회고.md","hash":"b29f5143804c18c806afa94fc423f16a6ffd4df0","modified":1562769588361},{"_id":"source/_posts/메타인지/[meta] 새로운 개념 어떻게 습득해야 할까.md","hash":"1969e817b139682a04d4d55a78b9aa2988890f3a","modified":1562769809735},{"_id":"source/_posts/회고/2019년도 2월 회고.md","hash":"f572e236a8089127bd70db36076301718222552e","modified":1562769536579},{"_id":"source/_posts/Spring/IoC, DI란 무엇일까.md","hash":"c00f9b37d6ce8e4c7ddf9675d146cfb1bea49fd6","modified":1664544199300},{"_id":"source/_posts/Spring/Spring AOP 적용시 주의사항.md","hash":"c1a58b685901c6f225871faaae54708b3b37b520","modified":1563290102638},{"_id":"source/_posts/회고/2019년도 첫 실천 1월 회고.md","hash":"3efae40ff8b9e7b9d8f974fe575bba86e6a826f8","modified":1562769536579},{"_id":"source/_posts/Spring/Spring Validation 처리 방법.md","hash":"4f95e3c23257178ac9767ac5f46f57129471533b","modified":1563291702742},{"_id":"source/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1543851545840},{"_id":"source/_posts/회고/첫오픈 준비.md","hash":"8b2071badefe92cacf20f7c5f623ea8410a85a09","modified":1565796513855},{"_id":"source/_posts/Spring/순환참조와 Lazy.md","hash":"1ea403cdfad4bc0a322cfcf1966a7583b617236c","modified":1566394195604},{"_id":"themes/beantech/source/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1543851545982},{"_id":"themes/beantech/source/css/bootstrap.min.css","hash":"1818a346630e7133a1f194669f613f613fcfa97c","modified":1543851545964},{"_id":"themes/beantech/source/js/bootstrap.js","hash":"5d69034fb6eded2e5961ea54dd47129a88cd5182","modified":1543851545996},{"_id":"source/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1543851545851},{"_id":"themes/beantech/source/js/jquery.min.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1543851546064},{"_id":"themes/beantech/source/css/bootstrap.css","hash":"d1a24afac31222d70b4e001e0361ef045aa42043","modified":1543851545956},{"_id":"themes/beantech/source/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1543851545969},{"_id":"themes/beantech/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1543851545971},{"_id":"source/_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post_clustering.jpg","hash":"06449cdaf9d37e8e005b5cc817b3c07b564b5b09","modified":1544189956252},{"_id":"source/_posts/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편/observer-result.png","hash":"ccc90b134809d81bf3564265a889b61a6b1e2ad9","modified":1557328048301},{"_id":"source/_posts/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편/observer.png","hash":"6712421cb9aa3304b0241d64a722b8ebd9938bd6","modified":1557241988607},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편/simple-factory.png","hash":"ef761f8d35689355b7f2fe2b37168acc891d9d09","modified":1555942230038},{"_id":"source/_posts/JPA/JPA N+1 문제 해결 방법/jpa_entity_graph.jpg","hash":"c88668783a37bf403b8304c7a00f67486966d588","modified":1563800852726},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편/factory-pattern.png","hash":"1ab36a3c85d26db7256e60a6de12b282d97b34f1","modified":1556289776477},{"_id":"source/_posts/Docker/Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기/docker-error.png","hash":"1ebcec9dbf97a22b0556ea94a8a93078d5dd73fc","modified":1564841392264},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편/factory-pattern.png","hash":"1ab36a3c85d26db7256e60a6de12b282d97b34f1","modified":1556291576346},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편/simple-factory.png","hash":"ef761f8d35689355b7f2fe2b37168acc891d9d09","modified":1556291576350},{"_id":"source/_posts/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/OS_process.png","hash":"e978fc1f2e908389d21d7bc5fe53f440e8cab369","modified":1546526760436},{"_id":"source/_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/dynamic-update2.png","hash":"81626988714eabd1d77221dfd10018bb1cb54ef2","modified":1564232414066},{"_id":"source/_posts/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/OS_register.png","hash":"646abba8221aab76ea91fca3f2d16aa462f6fb53","modified":1546526804456},{"_id":"source/_posts/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/OS_process_code.png","hash":"424e99a264efff9ac12a4c680dcbe047c2555ab1","modified":1546526871084},{"_id":"source/_posts/OOP/객체 지향 설계 5대 원칙/srp-2.png","hash":"53bff37d3596fb160c160460cebf15fd0637953d","modified":1558620903422},{"_id":"source/_posts/OOP/객체 지향 설계 5대 원칙/srp-1.png","hash":"501d9a036e91b6d161dc664e12656adbe47a7e75","modified":1558620903406},{"_id":"source/_posts/회고/2018년 회고/evernote.png","hash":"aadac0e1c3ef71c23040b54d6b1368c6aa6af00e","modified":1547350658432},{"_id":"source/_posts/회고/2019년도 첫 실천 1월 회고/1_notion.png","hash":"c5c2532977f8ec9b11b26a4e8b209c4b9ad4b4f2","modified":1549028640895},{"_id":"source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1543851545849},{"_id":"source/_posts/회고/2019년도 첫 실천 1월 회고/score.png","hash":"6f5f38f8dba9326e0a17fb80aaa2e0ba47290947","modified":1549027319499},{"_id":"source/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1543851545903},{"_id":"source/_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post-quartz-clustering-mode-example.png","hash":"db0f9d614b5530bd52c51708fd2268ce2da18add","modified":1544192171498},{"_id":"source/_posts/JPA/JPA N+1 문제 해결 방법/jpa_fetch_join.jpg","hash":"5bd9006e674c9f6a2d47e66fd5920470d63831d1","modified":1563720642167},{"_id":"source/_posts/JPA/JPA N+1 문제 해결 방법/jpa_n_plus_one.jpg","hash":"2d7e1c5045ca9222a7111006d4310592a826823c","modified":1563720647733},{"_id":"source/_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/dynamic-update1.png","hash":"4886df1797689f64c39f810ec911383afafe287d","modified":1564217324445},{"_id":"source/_posts/OOP/상속보다는 합성을 사용해야 하는 이유/inherit-reason2.png","hash":"6e2604268dd90fd46e68f5ef14f8319af6ad69d5","modified":1564815178256},{"_id":"source/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1543851545917},{"_id":"themes/beantech/source/js/jquery.js","hash":"4bb763dc96da604aed08ac024a1a3f5de73eea39","modified":1543851546045},{"_id":"source/_posts/OOP/상속보다는 합성을 사용해야 하는 이유/inherit-reason3.png","hash":"735c86b13d4eda70c806b112e316f97efcf0b3a5","modified":1564815178280},{"_id":"source/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1543851545907},{"_id":"source/_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post-quartz-clustering-mode-test.png","hash":"20fdd03a1a409e8052894ef015be27b37ac4b252","modified":1544145748919},{"_id":"source/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1543851545895},{"_id":"source/_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/write-lazy.png","hash":"e6e3be1bd7a7e747320ca1e0b5967101f4c61719","modified":1564217324499},{"_id":"source/_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/jpql-flush.png","hash":"ff73ad0182a8b3eb9dfce17f957c2deeaa480d6a","modified":1564217324471},{"_id":"source/_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post-quartz-clustering-mode-log.png","hash":"32214ac821da1cd2e573b6dcc3f95139792ee45d","modified":1544194063580},{"_id":"source/_posts/OOP/객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유/object-1.png","hash":"da45ae88c8f6ffc375126a02de7134b18bd49ce0","modified":1566086603513},{"_id":"source/_posts/Spring/순환참조와 Lazy/spring-circular-reference.png","hash":"66cc179f029792de7bd634dc8f075f8c1c88dea4","modified":1566393417102},{"_id":"source/_posts/OOP/상속보다는 합성을 사용해야 하는 이유/inherit-reason1.png","hash":"3e13b8e39e9d79dc8f2362a6c1829b7b197e0607","modified":1564815178224},{"_id":"source/img/header_img/bg_computer.jpg","hash":"6d40923b632e3aa0973d1ccbdb8f4a1f44883cea","modified":1544015583659},{"_id":"source/img/header_img/bg_computer.png","hash":"6d40923b632e3aa0973d1ccbdb8f4a1f44883cea","modified":1544015583659},{"_id":"themes/beantech/source/fonts/NANUMSQUAREROUNDB.TTF","hash":"e92331df4c26e67374cb41c18d4bdf326db8e53d","modified":1545557033808},{"_id":"source/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1543851545884},{"_id":"source/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1543851545848},{"_id":"source/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1543851545869},{"_id":"source/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1543851545877},{"_id":"source/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1543851545861},{"_id":"source/_drafts/docker compose 로 ngnix, spring boot, mysql 띄우기/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1567922171845},{"_id":"source/_drafts/IDC에서 클라우드로/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1566706784131},{"_id":"source/_drafts/Jenkins과 AWS로 코드가 빌드 배포되는 과정/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1566478399551},{"_id":"source/_posts/Spock/Spock 으로 Controller 파일 업로드 테스트 해보기/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1564059520680},{"_id":"source/_posts/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1557241248439},{"_id":"source/_posts/OOP/객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1564412826207},{"_id":"source/_posts/ETC/서버가 여러대 있때 redirect 사용시 발생하는 문제/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1566086792150},{"_id":"source/_posts/메타인지/[meta] 개발자 논리적인 사고력에 대해서/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1546610644269},{"_id":"source/_posts/Build/Gradle로 빌드시 동적으로 yml 파일에 값 셋팅하기/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1566218871033},{"_id":"source/_posts/JPA/JPA N+1 문제 해결 방법/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1563716201323},{"_id":"source/_posts/OOP/01 객체,설계/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1562936300441},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1555510925281},{"_id":"source/_posts/Design Patterns/[Design Patterns] 템플린 메소드 패턴, 도대체 왜 쓰는거야-기본 이론편/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1557887655495},{"_id":"source/_posts/OOP/객체지향 캡슐화 그것이 알고 싶다/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1564582454472},{"_id":"source/_posts/메타인지/[meta] 개발자 어떻게 공부 해야 할까/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1545829831749},{"_id":"source/_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1544016575396},{"_id":"source/_posts/OOP/객체 지향 설계 5대 원칙/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1558620866721},{"_id":"source/_posts/Docker/Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1564061640585},{"_id":"source/_posts/JPA/JPA 쿼리에 대해서/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1564216383011},{"_id":"source/_posts/Spring/Spring AOP 적용시 주의사항/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1543938034451},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1556291576324},{"_id":"source/_posts/회고/첫 오픈 준비/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1565792728013},{"_id":"source/_posts/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1546526587471},{"_id":"source/_posts/JPA/JPA 커스텀 리파지토리 만드는 방법/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1564054140905},{"_id":"source/_posts/OOP/02 객체 지향 프로그래밍/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1562936317477},{"_id":"source/_posts/Spring/순환참조와 Lazy/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1566393016640},{"_id":"source/_posts/API/[REST API]  REST API 란/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1557326509134},{"_id":"source/_posts/OOP/상속보다는 합성을 사용해야 하는 이유/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1564814988813},{"_id":"source/_posts/회고/2019년도 첫 실천 1월 회고/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1549027123293},{"_id":"source/_posts/메타인지/[meta] 새로운 개념 어떻게 습득해야 할까/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1544541430182},{"_id":"source/_posts/Spring/Spring Validation 처리 방법/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1563290084409},{"_id":"source/_posts/회고/2018년 회고/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1547350658417},{"_id":"source/_posts/Spring/IoC, DI란 무엇일까/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1567866389102},{"_id":"source/_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1564216400425},{"_id":"public/feed.xml","hash":"ff9e46c6fe1308f7f30b620287f671209092ff2d","modified":1664590808725},{"_id":"public/post-sitemap.xml","hash":"bfa34b7aedd268d458b162d58c3f96271eed8bb3","modified":1664590809128},{"_id":"public/page-sitemap.xml","hash":"c489c6ea3e208aff8917ae39d1753140b4eadbfb","modified":1664543770492},{"_id":"public/category-sitemap.xml","hash":"e5100f2af01579a77e5ca3a72fab900332f443c5","modified":1664590810090},{"_id":"public/tag-sitemap.xml","hash":"759a8a5b40bcada3fd22a56ac8c3650c927c773f","modified":1664590809241},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1664543770537},{"_id":"public/sitemap.xml","hash":"10001da0951fb9332e97c3d95b695c21966ffe9d","modified":1664544752432},{"_id":"public/robots.txt","hash":"7e49dfd97319f5dd7cdaea8518cf43e0e8d01e5a","modified":1664543770841},{"_id":"public/404.html","hash":"5c29c308a566eb9bfc6acd1d521564b59e8f7081","modified":1664543770934},{"_id":"public/archive/index.html","hash":"934aacdcb69a049c7251ce6ca457c4f082f7454f","modified":1664590811540},{"_id":"public/tags/index.html","hash":"386527f2da59b427f3482f5419bea72a91d9dd78","modified":1664590810383},{"_id":"public/2019/08/31/Spring/IoC, DI란 무엇일까/index.html","hash":"8b04a06cf28b2cf0cc7bf4cd3efb098f418ed9f9","modified":1664590811493},{"_id":"public/2019/09/07/Docker/Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기/index.html","hash":"4954503ae1c07650f62dd13aa57625a359b670d3","modified":1664543773817},{"_id":"public/2019/08/21/Spring/순환참조와 Lazy/index.html","hash":"db2977f6864b0a18641e1c4dfeb9c652c5768af6","modified":1664544481580},{"_id":"public/2019/08/31/JS/document ready 의미/index.html","hash":"46b6bc804267ffb4179084510e8c1c8fa83a0894","modified":1664543773817},{"_id":"public/2019/08/18/ETC/서버가 여러대 있때 redirect 사용시 발생하는 문제/index.html","hash":"eac35bb0b7c5a29e1e30c7f4d0484b0b104d9e67","modified":1664590810403},{"_id":"public/2019/08/14/회고/첫오픈 준비/index.html","hash":"c75fb1da8e4f145acb2222b5c6f7dc09b109d29f","modified":1664543773817},{"_id":"public/2019/08/19/Build/Gradle로 빌드시 동적으로 yml 파일에 값 셋팅하기/index.html","hash":"62565dce66e883cf598d4aeb393b970f27b25b75","modified":1664544754532},{"_id":"public/2019/07/27/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/index.html","hash":"0fab5212993f27372013ddf5faa276963e260c1a","modified":1664543773817},{"_id":"public/2019/07/31/OOP/객체지향 캡슐화 그것이 알고 싶다/index.html","hash":"778d8abebbf7f8c59bf7cd0f88ba4b6ba8c25948","modified":1664543773817},{"_id":"public/2019/07/31/OOP/상속보다는 합성을 사용해야 하는 이유/index.html","hash":"6f5030a7acdbd67521c5eee91cf51df928e71839","modified":1664543773817},{"_id":"public/2019/07/29/OOP/객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유/index.html","hash":"89b40c368a6cd3d56355e2cab1b4e0e6c45fb45b","modified":1664543773817},{"_id":"public/2019/07/25/JPA/JPA 커스텀 리파지토리 만드는 방법/index.html","hash":"30391b760da7b295f4d98797730038e386c6ff0b","modified":1664544754891},{"_id":"public/2019/07/25/Spock/Spock 으로 Controller 파일 업로드 테스트 해보기/index.html","hash":"cf2faa1fd81ebb067820e8edbc95cb7bee0e9e5a","modified":1664543773817},{"_id":"public/2019/07/23/JPA/JPA 쿼리에 대해서/index.html","hash":"7e2a12db3df820d0ac55daf54b48819bb0fa196d","modified":1664544754892},{"_id":"public/2019/07/11/OOP/02 객체 지향 프로그래밍/index.html","hash":"bf43ed2918d1c1f2ee1b1fc669264cca01ba50bb","modified":1664543773817},{"_id":"public/2019/07/10/JPA/JPA N+1 문제 해결 방법/index.html","hash":"c7c6dc1c85fa5bc3e9c94de2d144622eead1860d","modified":1664543773818},{"_id":"public/2019/07/10/OOP/01 객체,설계/index.html","hash":"210c9ade63249354227286073d6f21fdda9197ee","modified":1664543773818},{"_id":"public/2019/05/23/OOP/객체 지향 설계 5대 원칙/index.html","hash":"c6493ec80f9262b4c8c4a482adb79c0ca6de6b12","modified":1664543773818},{"_id":"public/2019/06/28/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편/index.html","hash":"076b1a8f6fe51dfe6504ed43837347f5bca20b63","modified":1664543773818},{"_id":"public/2019/05/15/Design Patterns/[Design Patterns] 템플릿 메소드 패턴, 도대체 왜 쓰는거야-기본 이론편/index.html","hash":"a4c99bcba4157c4d28ecb5fc68b8c96baaf298ec","modified":1664543773818},{"_id":"public/2019/04/17/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편/index.html","hash":"c0f1c5e4cc12a422f1800a060cccdc17e3411e0e","modified":1664543773818},{"_id":"public/2019/02/01/회고/2019년도 첫 실천 1월 회고/index.html","hash":"1c58def8700a6ed5f9dd7fd809f77e7c4aea1f7a","modified":1664543773818},{"_id":"public/2019/04/17/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편/index.html","hash":"ce360bee41278832427904dbe3659c972ca3b374","modified":1664543773818},{"_id":"public/2019/05/08/API/[REST API] REST API란/index.html","hash":"1418eee304450e2badb5c586f532f2ed796a2c4a","modified":1664543773818},{"_id":"public/2019/03/01/회고/2019년도 2월 회고/index.html","hash":"64348d811934f2c7190642fabdf84452e472c602","modified":1664543773818},{"_id":"public/2019/01/03/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/index.html","hash":"ca7144621357d805b2b1450245dcae99a4feb09c","modified":1664543773818},{"_id":"public/2018/12/26/메타인지/[meta] 개발자 어떻게 공부 해야 할까/index.html","hash":"19dce473de1cbde6babc609b61958565fb43278a","modified":1664543773818},{"_id":"public/2018/12/12/메타인지/[meta] 새로운 개념 어떻게 습득해야 할까/index.html","hash":"735d07f5b133e791ad70ab5a8b098da769cc0403","modified":1664543773818},{"_id":"public/2019/01/13/회고/2018년 회고/index.html","hash":"23b2e649cee66e3b3f1b02fac6585472f76b30b6","modified":1664543773818},{"_id":"public/2019/01/04/메타인지/[meta] 개발자 논리적인 사고력에 대해서/index.html","hash":"c5acbf6a79c1993998bb3fb01699404cc4b751d9","modified":1664543773818},{"_id":"public/2018/12/04/Spring/Spring Validation 처리 방법/index.html","hash":"f2aea79c1f83be9b9a7b63d01deab4f02df054e4","modified":1664543773819},{"_id":"public/2018/12/04/Spring/Spring AOP 적용시 주의사항/index.html","hash":"4216fbed603e8abdf84f92d7f75918fab3100f97","modified":1664543773819},{"_id":"public/2018/12/05/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/index.html","hash":"d87e3a907cc23c9c773e363b72c7c443f87a1d50","modified":1664544754892},{"_id":"public/about/index.html","hash":"69d92cee127c960bf91078f7374abb67cdbde9a0","modified":1664590811541},{"_id":"public/archives/index.html","hash":"e93144c4c8008723d222f8de27ef3087a833b92e","modified":1664590811664},{"_id":"public/archives/archives/3/index.html","hash":"1e5635f98a770363097abf6c59e2f1c595a505a2","modified":1664590811674},{"_id":"public/archives/archives/4/index.html","hash":"49d4dac74958610ed3ba1a79b969133004b5f6e0","modified":1664544483212},{"_id":"public/archives/archives/2/index.html","hash":"5dc60191e4098f38db89b96d0f7c03443b4d4dc1","modified":1664590811674},{"_id":"public/archives/2018/index.html","hash":"48a781bba852594aa11816b00d5c3be98eb901af","modified":1664590811675},{"_id":"public/archives/2018/12/index.html","hash":"6c83f16d035a915dc3f29a52478320be518068b1","modified":1664590811675},{"_id":"public/archives/2019/index.html","hash":"096dbf84fc4833751425ca0de9cdaa8ebbe9f9bf","modified":1664590811675},{"_id":"public/archives/2019/archives/3/index.html","hash":"acd13c9743f1f4ced8093e05b8a45b7e6ca7a24f","modified":1664590811675},{"_id":"public/archives/2019/archives/2/index.html","hash":"bdb2dbbb628bbc44184de452906768a4dd3c2fec","modified":1664590811675},{"_id":"public/archives/2019/01/index.html","hash":"a4cac0fd1153d0ac8e65066ed2226cd5354cee3e","modified":1664590811675},{"_id":"public/archives/2019/03/index.html","hash":"0034ec94e4f5d31c2ea7a108e8ba5f406bc701be","modified":1664590811677},{"_id":"public/archives/2019/02/index.html","hash":"ec0de3fb2a35da5d3c15bb4108ec349fe9c2dfaf","modified":1664590811676},{"_id":"public/archives/2019/04/index.html","hash":"71c2b82675aa71d73f19a85415e80dcc615711c9","modified":1664590811676},{"_id":"public/archives/2019/07/index.html","hash":"59efdd4a66d0c578d2af5c39f3b7bc3029aed37c","modified":1664590811677},{"_id":"public/archives/2019/09/index.html","hash":"97a29f017311a30db73b0dbcf152623ec6cae801","modified":1664590811677},{"_id":"public/archives/2019/05/index.html","hash":"256d8dfb18b3d9e9f2c0891d81f600a2bb0dea40","modified":1664590811677},{"_id":"public/archives/2019/06/index.html","hash":"09052b1f42fc1ca93f29e36684ac22d47e11c6e3","modified":1664590811677},{"_id":"public/categories/Build/Gradle/index.html","hash":"bea577c68f9e581bda1c83a1e2a0e74009208a11","modified":1664544754892},{"_id":"public/archives/2019/08/index.html","hash":"2898fd526da4eb32b2657c76e226562de11b960e","modified":1664590811677},{"_id":"public/categories/객체지향프로그래밍/index.html","hash":"7a28db8dffc36c7aa5f0cfdd6efba68ae28c5d2b","modified":1664590811632},{"_id":"public/categories/Build/index.html","hash":"406d3ca1a53b767ee3549979b597cd4d2489d57f","modified":1664544754892},{"_id":"public/index.html","hash":"91c4a396680321ecf4ab67c74cc1d74ece350192","modified":1664590811664},{"_id":"public/categories/JS/index.html","hash":"622dbe4b8f895b5d255c1657a4e93c19b151077e","modified":1664543773821},{"_id":"public/tags/Learnning/index.html","hash":"94d599cb20a0fdab474eb8ec7bc222ebf32cf4ef","modified":1664590811677},{"_id":"public/tags/Experience/index.html","hash":"ea72d7c57c37c87ecac0a6404a64c74261fec0cd","modified":1664590811677},{"_id":"public/tags/Quartz/index.html","hash":"d512a658a21653a4ac8a4037b3b724590a8ce3ce","modified":1664590811677},{"_id":"public/tags/API/index.html","hash":"59de3d3b78a2178f0e0827ca9649a9859402fd02","modified":1664590811677},{"_id":"public/tags/Design-Patterns/index.html","hash":"e4534a32ce446f218d40b2f8bd565b6b590ef636","modified":1664590811677},{"_id":"public/tags/OS/index.html","hash":"cf72eeec59879f68b3d1258c1ee2a7029fa145d5","modified":1664590811677},{"_id":"public/tags/Book/index.html","hash":"a8399a59fedcd34378a25454d7198becb79a14da","modified":1664590811677},{"_id":"public/tags/Library/index.html","hash":"2fd55d2a9aad160e8af6e9dddc75f9181d231143","modified":1664590811677},{"_id":"public/categories/Spring/index.html","hash":"73d87917b3d2a8ec5d1756d539f9c77984952a17","modified":1664544483216},{"_id":"public/tags/개발일반/index.html","hash":"3ab1f7359ec77ae2c4ed6e46cf35b5bfde30c600","modified":1664590811677},{"_id":"public/tags/Framework/index.html","hash":"b0eeb26fb828596c3e980fe7871276c3547bf1be","modified":1664590811677},{"_id":"public/tags/메타/index.html","hash":"59cfc064b85c5258d59cda54c479ba9ff499e5cf","modified":1664590811677},{"_id":"public/tags/회고/index.html","hash":"48579c116af9a0d8eeed23a3eb951b0d6a426a26","modified":1664590811677},{"_id":"public/tags/Spring/index.html","hash":"436ace9a25a0dcd2ecd6b086517e1fc90e96ec0b","modified":1664590811677},{"_id":"public/CNAME","hash":"55d5b0b4757a7d65ee4966dd161f394d06d257b7","modified":1664543773835},{"_id":"public/img/icon_wechat.png","hash":"4188058026609de06c6cac88b349a2da831a1783","modified":1664543773835},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1664543773835},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1664543773835},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1664543773835},{"_id":"public/css/images/ironman.png","hash":"2f0db0ab15d466c4065d9f6102fdf829726d9e3f","modified":1664543773835},{"_id":"public/2019/08/22/Jenkins과 AWS로 코드가 빌드 배포되는 과정/jenkins-deploy-process.png","hash":"90b05cd9286b19a79abf947b293ba6f110fe1473","modified":1664543773836},{"_id":"public/2019/09/07/Docker/Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기/docker-error.png","hash":"1ebcec9dbf97a22b0556ea94a8a93078d5dd73fc","modified":1664543773836},{"_id":"public/2019/04/17/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편/observer-result.png","hash":"ccc90b134809d81bf3564265a889b61a6b1e2ad9","modified":1664543773836},{"_id":"public/2019/04/17/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편/observer.png","hash":"6712421cb9aa3304b0241d64a722b8ebd9938bd6","modified":1664543773836},{"_id":"public/2019/06/28/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편/factory-pattern.png","hash":"1ab36a3c85d26db7256e60a6de12b282d97b34f1","modified":1664543773836},{"_id":"public/2019/06/28/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편/simple-factory.png","hash":"ef761f8d35689355b7f2fe2b37168acc891d9d09","modified":1664543773836},{"_id":"public/2019/04/17/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편/factory-pattern.png","hash":"1ab36a3c85d26db7256e60a6de12b282d97b34f1","modified":1664543773836},{"_id":"public/2019/04/17/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편/simple-factory.png","hash":"ef761f8d35689355b7f2fe2b37168acc891d9d09","modified":1664543773836},{"_id":"public/2019/05/23/OOP/객체 지향 설계 5대 원칙/srp-1.png","hash":"501d9a036e91b6d161dc664e12656adbe47a7e75","modified":1664543773836},{"_id":"public/2019/05/23/OOP/객체 지향 설계 5대 원칙/srp-2.png","hash":"53bff37d3596fb160c160460cebf15fd0637953d","modified":1664543773836},{"_id":"public/2019/01/03/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/OS_process.png","hash":"e978fc1f2e908389d21d7bc5fe53f440e8cab369","modified":1664543773836},{"_id":"public/2019/07/10/JPA/JPA N+1 문제 해결 방법/jpa_entity_graph.jpg","hash":"c88668783a37bf403b8304c7a00f67486966d588","modified":1664543773836},{"_id":"public/2019/07/10/JPA/JPA N+1 문제 해결 방법/jpa_fetch_join.jpg","hash":"5bd9006e674c9f6a2d47e66fd5920470d63831d1","modified":1664543773836},{"_id":"public/2019/01/03/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/OS_process_code.png","hash":"424e99a264efff9ac12a4c680dcbe047c2555ab1","modified":1664543773836},{"_id":"public/2019/01/03/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/OS_register.png","hash":"646abba8221aab76ea91fca3f2d16aa462f6fb53","modified":1664543773836},{"_id":"public/2018/12/05/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post_clustering.jpg","hash":"06449cdaf9d37e8e005b5cc817b3c07b564b5b09","modified":1664543773837},{"_id":"public/2019/07/27/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/dynamic-update1.png","hash":"4886df1797689f64c39f810ec911383afafe287d","modified":1664543773837},{"_id":"public/2019/07/27/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/dynamic-update2.png","hash":"81626988714eabd1d77221dfd10018bb1cb54ef2","modified":1664543773837},{"_id":"public/2019/01/13/회고/2018년 회고/evernote.png","hash":"aadac0e1c3ef71c23040b54d6b1368c6aa6af00e","modified":1664543773837},{"_id":"public/2019/02/01/회고/2019년도 첫 실천 1월 회고/1_notion.png","hash":"c5c2532977f8ec9b11b26a4e8b209c4b9ad4b4f2","modified":1664543773837},{"_id":"public/2019/02/01/회고/2019년도 첫 실천 1월 회고/score.png","hash":"6f5f38f8dba9326e0a17fb80aaa2e0ba47290947","modified":1664543773837},{"_id":"public/img/me.jpg","hash":"1a276a9fd1558a2ae1d6707ac959e87af3d790dc","modified":1664543774125},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1664543774125},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1664543774126},{"_id":"public/2018/12/05/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post-quartz-clustering-mode-test.png","hash":"20fdd03a1a409e8052894ef015be27b37ac4b252","modified":1664543774127},{"_id":"public/2019/07/10/JPA/JPA N+1 문제 해결 방법/jpa_n_plus_one.jpg","hash":"2d7e1c5045ca9222a7111006d4310592a826823c","modified":1664543774127},{"_id":"public/2019/07/31/OOP/상속보다는 합성을 사용해야 하는 이유/inherit-reason2.png","hash":"6e2604268dd90fd46e68f5ef14f8319af6ad69d5","modified":1664543774127},{"_id":"public/2019/07/31/OOP/상속보다는 합성을 사용해야 하는 이유/inherit-reason3.png","hash":"735c86b13d4eda70c806b112e316f97efcf0b3a5","modified":1664543774127},{"_id":"public/2018/12/05/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post-quartz-clustering-mode-example.png","hash":"db0f9d614b5530bd52c51708fd2268ce2da18add","modified":1664543774127},{"_id":"public/2019/07/27/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/write-lazy.png","hash":"e6e3be1bd7a7e747320ca1e0b5967101f4c61719","modified":1664543774127},{"_id":"public/css/archive.css","hash":"112f240646e0cbf8d593c4e23d7275452edad4e6","modified":1664543774133},{"_id":"public/css/signature.css","hash":"820fa4743cea34a61808cd8f7de528605c32d7e3","modified":1664543774133},{"_id":"public/css/highlight.css","hash":"03d1f0a648e9bdf7b1f57d217313cbac5d0c7eb1","modified":1664543774133},{"_id":"public/css/rocket.css","hash":"9456fd92f729e09d6de8cda70f95d78e0d789c70","modified":1664543774133},{"_id":"public/css/widget.css","hash":"da95ad3f1938f24d20f1fa77d7a38f0c392b5ec8","modified":1664543774133},{"_id":"public/css/toc.css","hash":"2062bf4e5b219654e0d4bf470f5eef1be213da95","modified":1664543774133},{"_id":"public/js/hux-blog.js","hash":"4b4d3c557405d04c3087d36c13e2834fe05c0f73","modified":1664543774133},{"_id":"public/js/hux-blog.min.js","hash":"1563e7f70550ac6b30803d6f449719b853200e35","modified":1664543774133},{"_id":"public/js/toc.js","hash":"41e52551731854224c249d53010c1bae5aa92ffa","modified":1664543774133},{"_id":"public/js/jquery.nav.js","hash":"ef2160a456176a4d09cc0b95d52b27dfbbadf2d8","modified":1664543774133},{"_id":"public/js/totop.js","hash":"c05360f6fc699ac12e794b1764b4a952713a3017","modified":1664543774133},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1664543774134},{"_id":"public/css/beantech.min.css","hash":"05a06230b1a9eca0b30cece54a397008cb77dc50","modified":1664543774134},{"_id":"public/css/beantech.css","hash":"4c361354fd8e9851923fb21a620bc079380ebcd8","modified":1664543774134},{"_id":"public/css/hux-blog.min.css","hash":"1baef04de262aeb7023d835429b49a805ac4ab40","modified":1664543774134},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1664543774134},{"_id":"public/css/bootstrap.min.css","hash":"fec7b176a4b9a67c0eb5d184f57b84297efc23aa","modified":1664543774134},{"_id":"public/js/bootstrap.js","hash":"f8752e9ae24daec0a0baffd7819122f8c6fd9103","modified":1664543774134},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1664543774134},{"_id":"public/css/bootstrap.css","hash":"41c54bf695145ae0b4d9020a1da308ceb05dcaf3","modified":1664543774134},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1664543774134},{"_id":"public/2019/08/21/Spring/순환참조와 Lazy/spring-circular-reference.png","hash":"66cc179f029792de7bd634dc8f075f8c1c88dea4","modified":1664543774134},{"_id":"public/img/404-bg.jpg","hash":"68f7d525269a94287e0ad18713ae232fb59dcf71","modified":1664543774153},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1664543774153},{"_id":"public/img/header_img/Iron-Man-3.jpg","hash":"62a9a76854503c327990cc8d10de293ab6e9588f","modified":1664543774153},{"_id":"public/img/header_img/tf-logo-dark.png","hash":"5c7bf8ade9de134f8c77a3c59e575abe9fc6cdd4","modified":1664543774153},{"_id":"public/2018/12/05/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post-quartz-clustering-mode-log.png","hash":"32214ac821da1cd2e573b6dcc3f95139792ee45d","modified":1664543774153},{"_id":"public/2019/07/29/OOP/객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유/object-1.png","hash":"da45ae88c8f6ffc375126a02de7134b18bd49ce0","modified":1664543774153},{"_id":"public/img/signature/BeanTechSign-white.png","hash":"34289ed41cf9ddac2d56be46fbb1515b7d5913cd","modified":1664543774162},{"_id":"public/img/signature/BeanTechSign-black.png","hash":"94b7102e819fd6ee082d3fb0166f4de7458c22ff","modified":1664543774162},{"_id":"public/img/ironman-draw.png","hash":"7d6a06b4b544ab146c3b3e8474edc33f14ac6e4d","modified":1664543774162},{"_id":"public/2019/07/27/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/jpql-flush.png","hash":"ff73ad0182a8b3eb9dfce17f957c2deeaa480d6a","modified":1664543774162},{"_id":"public/2019/07/31/OOP/상속보다는 합성을 사용해야 하는 이유/inherit-reason1.png","hash":"3e13b8e39e9d79dc8f2362a6c1829b7b197e0607","modified":1664543774175},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1664543774191},{"_id":"public/fonts/NANUMSQUAREROUNDB.TTF","hash":"e92331df4c26e67374cb41c18d4bdf326db8e53d","modified":1664543774229},{"_id":"public/img/header_img/bg_computer.png","hash":"6d40923b632e3aa0973d1ccbdb8f4a1f44883cea","modified":1664543774229},{"_id":"public/img/header_img/bg_computer.jpg","hash":"6d40923b632e3aa0973d1ccbdb8f4a1f44883cea","modified":1664543774233},{"_id":"public/img/beantech-desktop.png","hash":"4a8f8b209c9db8fd5209f15b8e4590525e258b0f","modified":1664543774262},{"_id":"public/img/header_img/tag-bg.png","hash":"e83cd7b04ff85bcbc9bd3ebf5e57a55166e82568","modified":1664543774296},{"_id":"public/img/header_img/home-bg-o.png","hash":"134ece4cb4c49c7ca1403a5afe7f46d0e2f9ecbb","modified":1664543774316},{"_id":"public/img/header_img/home-bg-2-dark.png","hash":"da6a3d5ca787bdc25e69655abd879b4f821aeb30","modified":1664543774326},{"_id":"public/img/header_img/archive-bg.png","hash":"6bf9c224543ec54e250309db89cbdf46e0c4b5ba","modified":1664543774337},{"_id":"public/2019/08/19/Build/Gradle로 빌드시 동적으로 yml 파일에 값 셋팅하기/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774371},{"_id":"public/2019/09/08/docker compose 로 ngnix, spring boot, mysql 띄우기/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774371},{"_id":"public/2019/07/25/JPA/JPA 커스텀 리파지토리 만드는 방법/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774372},{"_id":"public/2019/08/22/Jenkins과 AWS로 코드가 빌드 배포되는 과정/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774374},{"_id":"public/2019/07/10/OOP/01 객체,설계/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774375},{"_id":"public/2018/12/26/메타인지/[meta] 개발자 어떻게 공부 해야 할까/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774377},{"_id":"public/2019/07/25/Spock/Spock 으로 Controller 파일 업로드 테스트 해보기/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774378},{"_id":"public/2019/01/04/메타인지/[meta] 개발자 논리적인 사고력에 대해서/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774379},{"_id":"public/2019/07/31/OOP/객체지향 캡슐화 그것이 알고 싶다/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774382},{"_id":"public/2019/04/17/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774383},{"_id":"public/2019/07/29/OOP/객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774384},{"_id":"public/2019/07/11/OOP/02 객체 지향 프로그래밍/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774385},{"_id":"public/2019/09/07/Docker/Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774387},{"_id":"public/2019/01/03/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774389},{"_id":"public/2019/07/27/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774390},{"_id":"public/2019/08/22/IDC에서 클라우드로/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774398},{"_id":"public/2019/07/23/JPA/JPA 쿼리에 대해서/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774398},{"_id":"public/2019/08/18/ETC/서버가 여러대 있때 redirect 사용시 발생하는 문제/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774399},{"_id":"public/2019/06/28/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774400},{"_id":"public/2019/04/17/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774402},{"_id":"public/2019/05/23/OOP/객체 지향 설계 5대 원칙/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774405},{"_id":"public/2019/07/10/JPA/JPA N+1 문제 해결 방법/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774406},{"_id":"public/2019/07/31/OOP/상속보다는 합성을 사용해야 하는 이유/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774406},{"_id":"public/2018/12/05/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774407},{"_id":"public/2018/12/04/Spring/Spring AOP 적용시 주의사항/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774410},{"_id":"public/2019/08/31/Spring/IoC, DI란 무엇일까/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774410},{"_id":"public/2018/12/04/Spring/Spring Validation 처리 방법/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774412},{"_id":"public/2019/01/13/회고/2018년 회고/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774413},{"_id":"public/2019/02/01/회고/2019년도 첫 실천 1월 회고/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774415},{"_id":"public/2018/12/12/메타인지/[meta] 새로운 개념 어떻게 습득해야 할까/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774418},{"_id":"public/2019/08/21/Spring/순환참조와 Lazy/bg_computer.jpg","hash":"c1262e32424df886818ea55062c81ce89851c2cd","modified":1664543774425}],"Category":[{"name":"Build","_id":"cl8oids06000hk0ota7yua8x0"},{"name":"Gradle","parent":"cl8oids06000hk0ota7yua8x0","_id":"cl8oids0g000pk0otcgrglhwi"},{"name":"객체지향프로그래밍","_id":"cl8oids0z001ek0otzse6gtl6"},{"name":"JS","_id":"cl8oids1c0020k0ot7l8rerw9"},{"name":"Spring","_id":"cl8oids2g0032k0ot6bd3vvmm"}],"Data":[],"Page":[{"layout":"404","description":"你来到了没有知识的荒原 :(","header-img":"img/404-bg.jpg","_content":"","source":"404.md","raw":"---\nlayout: 404\ndescription: \"你来到了没有知识的荒原 :(\"\nheader-img: \"img/404-bg.jpg\"\n---\n","date":"2018-12-31T07:57:16.351Z","updated":"2018-12-03T15:39:05.788Z","path":"404.html","title":"","comments":1,"_id":"cl8oidrry0000k0ot82s7e4vk","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"archive","title":"Archives","header-img":"img/header_img/archive-bg.png","comments":0,"date":"2017-03-20T11:49:56.000Z","description":"Hey, this is archives","_content":"","source":"archive/index.md","raw":"---\nlayout: \"archive\"\ntitle: \"Archives\"\nheader-img: \"img/header_img/archive-bg.png\"\ncomments: false\ndate: 2017-03-20 20:49:56\ndescription: \"Hey, this is archives\"\n---\n","updated":"2018-12-03T15:39:05.839Z","path":"archive/index.html","_id":"cl8oidryo0002k0otddr3g7m4","content":"","site":{"data":{}},"excerpt":"","more":""},{"layout":"about","title":"About","date":"2016-04-20T19:48:33.000Z","description":null,"header-img":"img/header_img/Iron-Man-3.jpg","comments":1,"_content":"\n### 중요하게 생각하는 것들\n- 하루는 지나가는게 아니라 쌓이는 것\n- 원하는 것을 이루기위해 나아가려면, 엔진이 목표, 동기 기름은 반복과 습관이다.\n\n### 좋아하는 것\n- 영화나 미드 보면서 맛있는거 먹기 \n- 가족과 함께 좋은 장소에 가서 맛있는거 먹기\n\n### 취미\n- 유럽 축구 보기\n- 좋은 노래 수집하기\n\n### 하고싶은 것들\n- 기타 연주하기, 핑커스타일로!\n- 1년에 최소 한번 아내랑 해외 여행가기\n- 혼자 여행 다니기\n\n### 관심사\n- 영어회화\n","source":"about/index.md","raw":"---\nlayout: \"about\"\ntitle: \"About\"\ndate: 2016-04-21 04:48:33\ndescription: \nheader-img: \"img/header_img/Iron-Man-3.jpg\"\ncomments: true\n---\n\n### 중요하게 생각하는 것들\n- 하루는 지나가는게 아니라 쌓이는 것\n- 원하는 것을 이루기위해 나아가려면, 엔진이 목표, 동기 기름은 반복과 습관이다.\n\n### 좋아하는 것\n- 영화나 미드 보면서 맛있는거 먹기 \n- 가족과 함께 좋은 장소에 가서 맛있는거 먹기\n\n### 취미\n- 유럽 축구 보기\n- 좋은 노래 수집하기\n\n### 하고싶은 것들\n- 기타 연주하기, 핑커스타일로!\n- 1년에 최소 한번 아내랑 해외 여행가기\n- 혼자 여행 다니기\n\n### 관심사\n- 영어회화\n","updated":"2019-02-06T08:17:22.636Z","path":"about/index.html","_id":"cl8oidrzg000bk0otcwwe9vsm","content":"<h3><span id=\"중요하게-생각하는-것들\">중요하게 생각하는 것들</span></h3>\n<ul>\n<li>하루는 지나가는게 아니라 쌓이는 것</li>\n<li>원하는 것을 이루기위해 나아가려면, 엔진이 목표, 동기 기름은 반복과 습관이다.</li>\n</ul>\n<h3><span id=\"좋아하는-것\">좋아하는 것</span></h3>\n<ul>\n<li>영화나 미드 보면서 맛있는거 먹기</li>\n<li>가족과 함께 좋은 장소에 가서 맛있는거 먹기</li>\n</ul>\n<h3><span id=\"취미\">취미</span></h3>\n<ul>\n<li>유럽 축구 보기</li>\n<li>좋은 노래 수집하기</li>\n</ul>\n<h3><span id=\"하고싶은-것들\">하고싶은 것들</span></h3>\n<ul>\n<li>기타 연주하기, 핑커스타일로!</li>\n<li>1년에 최소 한번 아내랑 해외 여행가기</li>\n<li>혼자 여행 다니기</li>\n</ul>\n<h3><span id=\"관심사\">관심사</span></h3>\n<ul>\n<li>영어회화</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3>중요하게 생각하는 것들</h3>\n<ul>\n<li>하루는 지나가는게 아니라 쌓이는 것</li>\n<li>원하는 것을 이루기위해 나아가려면, 엔진이 목표, 동기 기름은 반복과 습관이다.</li>\n</ul>\n<h3>좋아하는 것</h3>\n<ul>\n<li>영화나 미드 보면서 맛있는거 먹기</li>\n<li>가족과 함께 좋은 장소에 가서 맛있는거 먹기</li>\n</ul>\n<h3>취미</h3>\n<ul>\n<li>유럽 축구 보기</li>\n<li>좋은 노래 수집하기</li>\n</ul>\n<h3>하고싶은 것들</h3>\n<ul>\n<li>기타 연주하기, 핑커스타일로!</li>\n<li>1년에 최소 한번 아내랑 해외 여행가기</li>\n<li>혼자 여행 다니기</li>\n</ul>\n<h3>관심사</h3>\n<ul>\n<li>영어회화</li>\n</ul>\n"},{"layout":"tags","title":"Tags","description":"Hey, this is Tags.","header-img":"img/header_img/tag-bg.png","_content":"","source":"tags/index.md","raw":"---\nlayout: \"tags\"\ntitle: \"Tags\"\ndescription: \"Hey, this is Tags.\"\nheader-img: \"img/header_img/tag-bg.png\"\n---\n","date":"2018-12-03T15:39:05.918Z","updated":"2018-12-03T15:39:05.918Z","path":"tags/index.html","comments":1,"_id":"cl8oidrzh000ck0otndw3xf0m","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"IDC 에서 클라우드로","catalog":true,"date":"2019-08-22T12:53:55.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["AWS"],"_content":"\n\n무신사에서 인프라 환경이 IDC에서 AWS클라우드로 전환과정을 정리하였습니다.\n\n### 왜 클라우드 환경인가?\n\n[DevOps 시대가 요구하는 품질확보 방법](https://www.slideshare.net/arload/devops-124383318)\n\n클라우드 서버에 장점인 Auto Scaling때문입니다.\n\n회사 사업상 추석, 이벤트, 푸쉬발송 등 특정 이벤트에 사용자가 폭주로 평균 트래픽에 9배 이상이 서버 요청이 들어옵니다. 이때 IDC에서는 유리천장 즉, 수용 할 수 있는 한계치만 허용하고 그 이상 트래픽을 받을수 없어 사용자 입장에서는 사이트에 접근 할 수 없는 상황이 될 수도 있죠. 이는 사용자 이탈을 발생 시킬수 있으며 곧 매출에 영향을 미칠수 있습니다.\n\n그래서 트래픽에 따라서 유연하게 서버를 scale out 하기 위해 AWS에서 서버를 운용하기로 하게 되었습니다.\n\n블루그린, 레드블랙\n\nAWS 이미지 생성 배포 방식, 코드만 배포\n\n### 배포는 어떻게 이루어지는가\n\nTODO 배포 프로세스 이미지 넣기\n\nAWS에서 배포하는 방식이 2가지가 있습니다.\n\n용어는 생각이 나지 않지만 이미지를 만들고 배포하는 방식, 코드만 인식해서 배포하는 방식 회사에서는 바뀐 파일만 인식하는 방식을 사용하게 되었습니다. 왜 그런지는 아래에서 설명하도록 하겠습니다.\n\n### 이미지 배포 방식 AMI (Amazon Machine Image)\n\nS3에 존재하는 artifact 를 Code Deploy가 이미지를 만들어 각 서버에 배포하는 방식입니다.\n\n장점은 ...\n\n단점은 배포하는 방식이 느리다는 것입니다.\n\n### 변경된 파일만 배포하는 방식 (용어 넣기)\n\n사내에서는 이 방식을 채택하게 되었습니다.\n\n배포 속도를 높은것을 중요하게 생각하였기 때문입니다.\n\n### 블루그린 배포\n\n서버4대가 있다고 가정해보겠습니다. \n\n서비스 운영중에 서버를 내리고 그냥 배포하면 될까요?? 예를 들어 1대씩 죽이고 배포하다가 잘 못되면??\n\n그래서 블루그린 방식이 있습니다.\n\n새롭게 배포할 서버4대를 새로 구성해 놓고 거기에 배포하고 트래픽을 새로 만든 서버 4대에다가 보내는 것이죠\n\n만약에 문제가 생긴다면 이전에 구성한 서버에다가 다시 트래픽을 보내는것이구요\n\n### 레드블랙 배포\n\n개념 조사 필요\n\n회사에서는 레드블랙으로 배포 한다.","source":"_drafts/IDC에서 클라우드로.md","raw":"---\ntitle: IDC 에서 클라우드로\ncatalog: true\ndate: 2019-08-22 21:53:55\nsubtitle: \nheader-img: \"bg_computer.jpg\"\ntags: \n- Experience\ncatagories:\n- AWS\n---\n\n\n무신사에서 인프라 환경이 IDC에서 AWS클라우드로 전환과정을 정리하였습니다.\n\n### 왜 클라우드 환경인가?\n\n[DevOps 시대가 요구하는 품질확보 방법](https://www.slideshare.net/arload/devops-124383318)\n\n클라우드 서버에 장점인 Auto Scaling때문입니다.\n\n회사 사업상 추석, 이벤트, 푸쉬발송 등 특정 이벤트에 사용자가 폭주로 평균 트래픽에 9배 이상이 서버 요청이 들어옵니다. 이때 IDC에서는 유리천장 즉, 수용 할 수 있는 한계치만 허용하고 그 이상 트래픽을 받을수 없어 사용자 입장에서는 사이트에 접근 할 수 없는 상황이 될 수도 있죠. 이는 사용자 이탈을 발생 시킬수 있으며 곧 매출에 영향을 미칠수 있습니다.\n\n그래서 트래픽에 따라서 유연하게 서버를 scale out 하기 위해 AWS에서 서버를 운용하기로 하게 되었습니다.\n\n블루그린, 레드블랙\n\nAWS 이미지 생성 배포 방식, 코드만 배포\n\n### 배포는 어떻게 이루어지는가\n\nTODO 배포 프로세스 이미지 넣기\n\nAWS에서 배포하는 방식이 2가지가 있습니다.\n\n용어는 생각이 나지 않지만 이미지를 만들고 배포하는 방식, 코드만 인식해서 배포하는 방식 회사에서는 바뀐 파일만 인식하는 방식을 사용하게 되었습니다. 왜 그런지는 아래에서 설명하도록 하겠습니다.\n\n### 이미지 배포 방식 AMI (Amazon Machine Image)\n\nS3에 존재하는 artifact 를 Code Deploy가 이미지를 만들어 각 서버에 배포하는 방식입니다.\n\n장점은 ...\n\n단점은 배포하는 방식이 느리다는 것입니다.\n\n### 변경된 파일만 배포하는 방식 (용어 넣기)\n\n사내에서는 이 방식을 채택하게 되었습니다.\n\n배포 속도를 높은것을 중요하게 생각하였기 때문입니다.\n\n### 블루그린 배포\n\n서버4대가 있다고 가정해보겠습니다. \n\n서비스 운영중에 서버를 내리고 그냥 배포하면 될까요?? 예를 들어 1대씩 죽이고 배포하다가 잘 못되면??\n\n그래서 블루그린 방식이 있습니다.\n\n새롭게 배포할 서버4대를 새로 구성해 놓고 거기에 배포하고 트래픽을 새로 만든 서버 4대에다가 보내는 것이죠\n\n만약에 문제가 생긴다면 이전에 구성한 서버에다가 다시 트래픽을 보내는것이구요\n\n### 레드블랙 배포\n\n개념 조사 필요\n\n회사에서는 레드블랙으로 배포 한다.","slug":"IDC에서 클라우드로","published":0,"updated":"2019-08-25T04:21:10.141Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oidryl0001k0ot7tacx1qy","content":"<p>무신사에서 인프라 환경이 IDC에서 AWS클라우드로 전환과정을 정리하였습니다.</p>\n<h3><span id=\"왜-클라우드-환경인가\">왜 클라우드 환경인가?</span></h3>\n<p><a href=\"https://www.slideshare.net/arload/devops-124383318\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">DevOps 시대가 요구하는 품질확보 방법</a></p>\n<p>클라우드 서버에 장점인 Auto Scaling때문입니다.</p>\n<p>회사 사업상 추석, 이벤트, 푸쉬발송 등 특정 이벤트에 사용자가 폭주로 평균 트래픽에 9배 이상이 서버 요청이 들어옵니다. 이때 IDC에서는 유리천장 즉, 수용 할 수 있는 한계치만 허용하고 그 이상 트래픽을 받을수 없어 사용자 입장에서는 사이트에 접근 할 수 없는 상황이 될 수도 있죠. 이는 사용자 이탈을 발생 시킬수 있으며 곧 매출에 영향을 미칠수 있습니다.</p>\n<p>그래서 트래픽에 따라서 유연하게 서버를 scale out 하기 위해 AWS에서 서버를 운용하기로 하게 되었습니다.</p>\n<p>블루그린, 레드블랙</p>\n<p>AWS 이미지 생성 배포 방식, 코드만 배포</p>\n<h3><span id=\"배포는-어떻게-이루어지는가\">배포는 어떻게 이루어지는가</span></h3>\n<p>TODO 배포 프로세스 이미지 넣기</p>\n<p>AWS에서 배포하는 방식이 2가지가 있습니다.</p>\n<p>용어는 생각이 나지 않지만 이미지를 만들고 배포하는 방식, 코드만 인식해서 배포하는 방식 회사에서는 바뀐 파일만 인식하는 방식을 사용하게 되었습니다. 왜 그런지는 아래에서 설명하도록 하겠습니다.</p>\n<h3><span id=\"이미지-배포-방식-ami-amazon-machine-image\">이미지 배포 방식 AMI (Amazon Machine Image)</span></h3>\n<p>S3에 존재하는 artifact 를 Code Deploy가 이미지를 만들어 각 서버에 배포하는 방식입니다.</p>\n<p>장점은 …</p>\n<p>단점은 배포하는 방식이 느리다는 것입니다.</p>\n<h3><span id=\"변경된-파일만-배포하는-방식-용어-넣기\">변경된 파일만 배포하는 방식 (용어 넣기)</span></h3>\n<p>사내에서는 이 방식을 채택하게 되었습니다.</p>\n<p>배포 속도를 높은것을 중요하게 생각하였기 때문입니다.</p>\n<h3><span id=\"블루그린-배포\">블루그린 배포</span></h3>\n<p>서버4대가 있다고 가정해보겠습니다.</p>\n<p>서비스 운영중에 서버를 내리고 그냥 배포하면 될까요?? 예를 들어 1대씩 죽이고 배포하다가 잘 못되면??</p>\n<p>그래서 블루그린 방식이 있습니다.</p>\n<p>새롭게 배포할 서버4대를 새로 구성해 놓고 거기에 배포하고 트래픽을 새로 만든 서버 4대에다가 보내는 것이죠</p>\n<p>만약에 문제가 생긴다면 이전에 구성한 서버에다가 다시 트래픽을 보내는것이구요</p>\n<h3><span id=\"레드블랙-배포\">레드블랙 배포</span></h3>\n<p>개념 조사 필요</p>\n<p>회사에서는 레드블랙으로 배포 한다.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>무신사에서 인프라 환경이 IDC에서 AWS클라우드로 전환과정을 정리하였습니다.</p>\n<h3>왜 클라우드 환경인가?</h3>\n<p><a href=\"https://www.slideshare.net/arload/devops-124383318\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">DevOps 시대가 요구하는 품질확보 방법</a></p>\n<p>클라우드 서버에 장점인 Auto Scaling때문입니다.</p>\n<p>회사 사업상 추석, 이벤트, 푸쉬발송 등 특정 이벤트에 사용자가 폭주로 평균 트래픽에 9배 이상이 서버 요청이 들어옵니다. 이때 IDC에서는 유리천장 즉, 수용 할 수 있는 한계치만 허용하고 그 이상 트래픽을 받을수 없어 사용자 입장에서는 사이트에 접근 할 수 없는 상황이 될 수도 있죠. 이는 사용자 이탈을 발생 시킬수 있으며 곧 매출에 영향을 미칠수 있습니다.</p>\n<p>그래서 트래픽에 따라서 유연하게 서버를 scale out 하기 위해 AWS에서 서버를 운용하기로 하게 되었습니다.</p>\n<p>블루그린, 레드블랙</p>\n<p>AWS 이미지 생성 배포 방식, 코드만 배포</p>\n<h3>배포는 어떻게 이루어지는가</h3>\n<p>TODO 배포 프로세스 이미지 넣기</p>\n<p>AWS에서 배포하는 방식이 2가지가 있습니다.</p>\n<p>용어는 생각이 나지 않지만 이미지를 만들고 배포하는 방식, 코드만 인식해서 배포하는 방식 회사에서는 바뀐 파일만 인식하는 방식을 사용하게 되었습니다. 왜 그런지는 아래에서 설명하도록 하겠습니다.</p>\n<h3>이미지 배포 방식 AMI (Amazon Machine Image)</h3>\n<p>S3에 존재하는 artifact 를 Code Deploy가 이미지를 만들어 각 서버에 배포하는 방식입니다.</p>\n<p>장점은 …</p>\n<p>단점은 배포하는 방식이 느리다는 것입니다.</p>\n<h3>변경된 파일만 배포하는 방식 (용어 넣기)</h3>\n<p>사내에서는 이 방식을 채택하게 되었습니다.</p>\n<p>배포 속도를 높은것을 중요하게 생각하였기 때문입니다.</p>\n<h3>블루그린 배포</h3>\n<p>서버4대가 있다고 가정해보겠습니다.</p>\n<p>서비스 운영중에 서버를 내리고 그냥 배포하면 될까요?? 예를 들어 1대씩 죽이고 배포하다가 잘 못되면??</p>\n<p>그래서 블루그린 방식이 있습니다.</p>\n<p>새롭게 배포할 서버4대를 새로 구성해 놓고 거기에 배포하고 트래픽을 새로 만든 서버 4대에다가 보내는 것이죠</p>\n<p>만약에 문제가 생긴다면 이전에 구성한 서버에다가 다시 트래픽을 보내는것이구요</p>\n<h3>레드블랙 배포</h3>\n<p>개념 조사 필요</p>\n<p>회사에서는 레드블랙으로 배포 한다.</p>\n"},{"title":"Jenkins과 AWS로 코드가 빌드 배포되는 과정","catalog":true,"date":"2019-08-22T12:53:55.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["AWS"],"_content":"\n\n### 개발서버에 어떻게 배포 되고 있는 것일까?? \n\n문득 사내에서 개발서버에 배포 할 때 Jenkins에서 버튼 딸깍 딸깍 하고 있는데 이것이 어떻게 빌드 되고 AWS로 어떻게 가는거지? 궁금해졌다. AWS도 잘모르는데 이참에 배포되는 과정을 조사해 보고자 한다.\n\n우선 배포되는 과정은 아래 이미지와 같다.\n{% asset_img \"jenkins-deploy-process.png\" %}\n\n\n### 1. 코드리뷰 그리고 PR\n\nBitbucket으로 PR을 날리고 승인되면 devel이라는 브랜치로 코드가 병합 된다.\n\n### 2. Jenkins이 빌드하여 빌드결과 파일을 S3로 전송\n\nJenkins에서 빌드 담당자가 빌드할 브랜치를 선택하고 Job을 실행하면 Gradle이 빌드를 시작한다.  \n\n빌드를 하면서 아래에 프로세스를 거치게 된다.\n\n- 코드정적 분석 (Intellij Checkstyle 데로 코드가 작성되어 있는지 체크한다. 실패시 빌드 fail)\n- 테스트 코드 수행\n- 정적 리소스 파일 Timestamp로 버전 업데이트 (캐쉬를 무효화하고 수정된 버전을 적용시키기 위해)\n- 빌드된 결과 파일을 tar로 archive하고 그외 정적 리소스 파일(js, css, image 등)을 S3로 전송함\n\n여기서 중요한것은 빌드 파일이 S3로 갈 때, S3의 bucket이 다르다. tar 파일은 A라는 Bucket에서 관리하고 정적 리소스파일은 B 라는 Bucket으로 간다. 원래 정적 리소스 파일은 웹서버 내에서 관리 되었는데 CDN으로 활용하고자 S3에 static 디렉토리 별도에 두고 서비스 하기 위해 구분하여 배포하게 되었다.\n\n### 3,4 Code Deploy에서 S3에서 변경감지를 하여 서버 배포 및 재시작\n\nJenkins에 역활을 빌드를 수행하고 결과물을 S3에 쏘는데 까지만이다. 나머지는 AWS에서 제공하는 Code Deploy 서비스를 이용하여 S3에 파일이 변경된 것을 감지하여 EC2서버에 코드를 배포한다.  \n\n그리고 소스가 반영되고 재시작되어 배포는 마무리 된다.\n\n\n### 조사 할 것\n\n### 정적 리소스 파일 삭제시 S3에 싱크됨?\n\n이전에는 rsync로 파일에 대한 동기화가 됬었는데 S3에서는 파일이 추가만 되지 파일을 삭제하고 S3로 쏴도 파일 삭제가 되지 않았다. 풀어야 할 과제이며 해결시 반드시 포스팅 업데이트 해야 한다.","source":"_drafts/Jenkins과 AWS로 코드가 빌드 배포되는 과정.md","raw":"---\ntitle: Jenkins과 AWS로 코드가 빌드 배포되는 과정\ncatalog: true\ndate: 2019-08-22 21:53:55\nsubtitle: \nheader-img: \"bg_computer.jpg\"\ntags: \n- Experience\ncatagories:\n- AWS\n---\n\n\n### 개발서버에 어떻게 배포 되고 있는 것일까?? \n\n문득 사내에서 개발서버에 배포 할 때 Jenkins에서 버튼 딸깍 딸깍 하고 있는데 이것이 어떻게 빌드 되고 AWS로 어떻게 가는거지? 궁금해졌다. AWS도 잘모르는데 이참에 배포되는 과정을 조사해 보고자 한다.\n\n우선 배포되는 과정은 아래 이미지와 같다.\n{% asset_img \"jenkins-deploy-process.png\" %}\n\n\n### 1. 코드리뷰 그리고 PR\n\nBitbucket으로 PR을 날리고 승인되면 devel이라는 브랜치로 코드가 병합 된다.\n\n### 2. Jenkins이 빌드하여 빌드결과 파일을 S3로 전송\n\nJenkins에서 빌드 담당자가 빌드할 브랜치를 선택하고 Job을 실행하면 Gradle이 빌드를 시작한다.  \n\n빌드를 하면서 아래에 프로세스를 거치게 된다.\n\n- 코드정적 분석 (Intellij Checkstyle 데로 코드가 작성되어 있는지 체크한다. 실패시 빌드 fail)\n- 테스트 코드 수행\n- 정적 리소스 파일 Timestamp로 버전 업데이트 (캐쉬를 무효화하고 수정된 버전을 적용시키기 위해)\n- 빌드된 결과 파일을 tar로 archive하고 그외 정적 리소스 파일(js, css, image 등)을 S3로 전송함\n\n여기서 중요한것은 빌드 파일이 S3로 갈 때, S3의 bucket이 다르다. tar 파일은 A라는 Bucket에서 관리하고 정적 리소스파일은 B 라는 Bucket으로 간다. 원래 정적 리소스 파일은 웹서버 내에서 관리 되었는데 CDN으로 활용하고자 S3에 static 디렉토리 별도에 두고 서비스 하기 위해 구분하여 배포하게 되었다.\n\n### 3,4 Code Deploy에서 S3에서 변경감지를 하여 서버 배포 및 재시작\n\nJenkins에 역활을 빌드를 수행하고 결과물을 S3에 쏘는데 까지만이다. 나머지는 AWS에서 제공하는 Code Deploy 서비스를 이용하여 S3에 파일이 변경된 것을 감지하여 EC2서버에 코드를 배포한다.  \n\n그리고 소스가 반영되고 재시작되어 배포는 마무리 된다.\n\n\n### 조사 할 것\n\n### 정적 리소스 파일 삭제시 S3에 싱크됨?\n\n이전에는 rsync로 파일에 대한 동기화가 됬었는데 S3에서는 파일이 추가만 되지 파일을 삭제하고 S3로 쏴도 파일 삭제가 되지 않았다. 풀어야 할 과제이며 해결시 반드시 포스팅 업데이트 해야 한다.","slug":"Jenkins과 AWS로 코드가 빌드 배포되는 과정","published":0,"updated":"2019-08-22T13:32:23.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oidryp0003k0ot6ot2jykn","content":"<h3><span id=\"개발서버에-어떻게-배포-되고-있는-것일까\">개발서버에 어떻게 배포 되고 있는 것일까??</span></h3>\n<p>문득 사내에서 개발서버에 배포 할 때 Jenkins에서 버튼 딸깍 딸깍 하고 있는데 이것이 어떻게 빌드 되고 AWS로 어떻게 가는거지? 궁금해졌다. AWS도 잘모르는데 이참에 배포되는 과정을 조사해 보고자 한다.</p>\n<p>우선 배포되는 과정은 아래 이미지와 같다.</p>\n<img src=\"/2019/08/22/Jenkins과%20AWS로%20코드가%20빌드%20배포되는%20과정/jenkins-deploy-process.png\">\n<h3><span id=\"1-코드리뷰-그리고-pr\">1. 코드리뷰 그리고 PR</span></h3>\n<p>Bitbucket으로 PR을 날리고 승인되면 devel이라는 브랜치로 코드가 병합 된다.</p>\n<h3><span id=\"2-jenkins이-빌드하여-빌드결과-파일을-s3로-전송\">2. Jenkins이 빌드하여 빌드결과 파일을 S3로 전송</span></h3>\n<p>Jenkins에서 빌드 담당자가 빌드할 브랜치를 선택하고 Job을 실행하면 Gradle이 빌드를 시작한다.</p>\n<p>빌드를 하면서 아래에 프로세스를 거치게 된다.</p>\n<ul>\n<li>코드정적 분석 (Intellij Checkstyle 데로 코드가 작성되어 있는지 체크한다. 실패시 빌드 fail)</li>\n<li>테스트 코드 수행</li>\n<li>정적 리소스 파일 Timestamp로 버전 업데이트 (캐쉬를 무효화하고 수정된 버전을 적용시키기 위해)</li>\n<li>빌드된 결과 파일을 tar로 archive하고 그외 정적 리소스 파일(js, css, image 등)을 S3로 전송함</li>\n</ul>\n<p>여기서 중요한것은 빌드 파일이 S3로 갈 때, S3의 bucket이 다르다. tar 파일은 A라는 Bucket에서 관리하고 정적 리소스파일은 B 라는 Bucket으로 간다. 원래 정적 리소스 파일은 웹서버 내에서 관리 되었는데 CDN으로 활용하고자 S3에 static 디렉토리 별도에 두고 서비스 하기 위해 구분하여 배포하게 되었다.</p>\n<h3><span id=\"34-code-deploy에서-s3에서-변경감지를-하여-서버-배포-및-재시작\">3,4 Code Deploy에서 S3에서 변경감지를 하여 서버 배포 및 재시작</span></h3>\n<p>Jenkins에 역활을 빌드를 수행하고 결과물을 S3에 쏘는데 까지만이다. 나머지는 AWS에서 제공하는 Code Deploy 서비스를 이용하여 S3에 파일이 변경된 것을 감지하여 EC2서버에 코드를 배포한다.</p>\n<p>그리고 소스가 반영되고 재시작되어 배포는 마무리 된다.</p>\n<h3><span id=\"조사-할-것\">조사 할 것</span></h3>\n<h3><span id=\"정적-리소스-파일-삭제시-s3에-싱크됨\">정적 리소스 파일 삭제시 S3에 싱크됨?</span></h3>\n<p>이전에는 rsync로 파일에 대한 동기화가 됬었는데 S3에서는 파일이 추가만 되지 파일을 삭제하고 S3로 쏴도 파일 삭제가 되지 않았다. 풀어야 할 과제이며 해결시 반드시 포스팅 업데이트 해야 한다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>개발서버에 어떻게 배포 되고 있는 것일까??</h3>\n<p>문득 사내에서 개발서버에 배포 할 때 Jenkins에서 버튼 딸깍 딸깍 하고 있는데 이것이 어떻게 빌드 되고 AWS로 어떻게 가는거지? 궁금해졌다. AWS도 잘모르는데 이참에 배포되는 과정을 조사해 보고자 한다.</p>\n<p>우선 배포되는 과정은 아래 이미지와 같다.</p>\n<img src=\"/2019/08/22/Jenkins과%20AWS로%20코드가%20빌드%20배포되는%20과정/jenkins-deploy-process.png\">\n<h3>1. 코드리뷰 그리고 PR</h3>\n<p>Bitbucket으로 PR을 날리고 승인되면 devel이라는 브랜치로 코드가 병합 된다.</p>\n<h3>2. Jenkins이 빌드하여 빌드결과 파일을 S3로 전송</h3>\n<p>Jenkins에서 빌드 담당자가 빌드할 브랜치를 선택하고 Job을 실행하면 Gradle이 빌드를 시작한다.</p>\n<p>빌드를 하면서 아래에 프로세스를 거치게 된다.</p>\n<ul>\n<li>코드정적 분석 (Intellij Checkstyle 데로 코드가 작성되어 있는지 체크한다. 실패시 빌드 fail)</li>\n<li>테스트 코드 수행</li>\n<li>정적 리소스 파일 Timestamp로 버전 업데이트 (캐쉬를 무효화하고 수정된 버전을 적용시키기 위해)</li>\n<li>빌드된 결과 파일을 tar로 archive하고 그외 정적 리소스 파일(js, css, image 등)을 S3로 전송함</li>\n</ul>\n<p>여기서 중요한것은 빌드 파일이 S3로 갈 때, S3의 bucket이 다르다. tar 파일은 A라는 Bucket에서 관리하고 정적 리소스파일은 B 라는 Bucket으로 간다. 원래 정적 리소스 파일은 웹서버 내에서 관리 되었는데 CDN으로 활용하고자 S3에 static 디렉토리 별도에 두고 서비스 하기 위해 구분하여 배포하게 되었다.</p>\n<h3>3,4 Code Deploy에서 S3에서 변경감지를 하여 서버 배포 및 재시작</h3>\n<p>Jenkins에 역활을 빌드를 수행하고 결과물을 S3에 쏘는데 까지만이다. 나머지는 AWS에서 제공하는 Code Deploy 서비스를 이용하여 S3에 파일이 변경된 것을 감지하여 EC2서버에 코드를 배포한다.</p>\n<p>그리고 소스가 반영되고 재시작되어 배포는 마무리 된다.</p>\n<h3>조사 할 것</h3>\n<h3>정적 리소스 파일 삭제시 S3에 싱크됨?</h3>\n<p>이전에는 rsync로 파일에 대한 동기화가 됬었는데 S3에서는 파일이 추가만 되지 파일을 삭제하고 S3로 쏴도 파일 삭제가 되지 않았다. 풀어야 할 과제이며 해결시 반드시 포스팅 업데이트 해야 한다.</p>\n"},{"title":"docker compose 로 ngnix, spring boot, mysql 띄우기","catalog":true,"date":"2019-09-08T05:58:56.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["Docker"],"_content":"\n\n### 들어가며 \n\n웹서버, WAS, DB를 docker-compse로 구성해보고 운영중 발생 할 수 있는 문제를 재현해보고 테스트 할 수 있는 환경을 만들어 보고자 합니다.\n\n[예제 프로젝트](https://github.com/biggwang/learnning-subjects/tree/master/dockerspringboot)를 참고하여 실습을 진행하였습니다.\n\n\n### 실습 목표\n\n- 로컬에서 docker compose로 웹서버, WAS, DB 환경 구성 하기\n- 각 docker container AWS에서 구성하고 서비스 동작 확인 하기\n- docker-compose.yml, Dockerfile 명령어 이해 하기\n\n\n### 참고\nhttps://blog.pickth.com/start-docker/","source":"_drafts/docker compose 로 ngnix, spring boot, mysql 띄우기.md","raw":"---\ntitle: docker compose 로 ngnix, spring boot, mysql 띄우기\ncatalog: true\ndate: 2019-09-08 14:58:56\nsubtitle: \nheader-img: \"bg_computer.jpg\"\ntags: \n- Learnning\ncatagories:\n- Docker\n---\n\n\n### 들어가며 \n\n웹서버, WAS, DB를 docker-compse로 구성해보고 운영중 발생 할 수 있는 문제를 재현해보고 테스트 할 수 있는 환경을 만들어 보고자 합니다.\n\n[예제 프로젝트](https://github.com/biggwang/learnning-subjects/tree/master/dockerspringboot)를 참고하여 실습을 진행하였습니다.\n\n\n### 실습 목표\n\n- 로컬에서 docker compose로 웹서버, WAS, DB 환경 구성 하기\n- 각 docker container AWS에서 구성하고 서비스 동작 확인 하기\n- docker-compose.yml, Dockerfile 명령어 이해 하기\n\n\n### 참고\nhttps://blog.pickth.com/start-docker/","slug":"docker compose 로 ngnix, spring boot, mysql 띄우기","published":0,"updated":"2019-09-08T06:10:50.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oidryr0005k0otlicxwlmf","content":"<h3><span id=\"들어가며\">들어가며</span></h3>\n<p>웹서버, WAS, DB를 docker-compse로 구성해보고 운영중 발생 할 수 있는 문제를 재현해보고 테스트 할 수 있는 환경을 만들어 보고자 합니다.</p>\n<p><a href=\"https://github.com/biggwang/learnning-subjects/tree/master/dockerspringboot\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">예제 프로젝트</a>를 참고하여 실습을 진행하였습니다.</p>\n<h3><span id=\"실습-목표\">실습 목표</span></h3>\n<ul>\n<li>로컬에서 docker compose로 웹서버, WAS, DB 환경 구성 하기</li>\n<li>각 docker container AWS에서 구성하고 서비스 동작 확인 하기</li>\n<li>docker-compose.yml, Dockerfile 명령어 이해 하기</li>\n</ul>\n<h3><span id=\"참고\">참고</span></h3>\n<p><a href=\"https://blog.pickth.com/start-docker/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://blog.pickth.com/start-docker/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3>들어가며</h3>\n<p>웹서버, WAS, DB를 docker-compse로 구성해보고 운영중 발생 할 수 있는 문제를 재현해보고 테스트 할 수 있는 환경을 만들어 보고자 합니다.</p>\n<p><a href=\"https://github.com/biggwang/learnning-subjects/tree/master/dockerspringboot\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">예제 프로젝트</a>를 참고하여 실습을 진행하였습니다.</p>\n<h3>실습 목표</h3>\n<ul>\n<li>로컬에서 docker compose로 웹서버, WAS, DB 환경 구성 하기</li>\n<li>각 docker container AWS에서 구성하고 서비스 동작 확인 하기</li>\n<li>docker-compose.yml, Dockerfile 명령어 이해 하기</li>\n</ul>\n<h3>참고</h3>\n<p><a href=\"https://blog.pickth.com/start-docker/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://blog.pickth.com/start-docker/</a></p>\n"},{"title":"REST API에 대해서","catalog":true,"subtitle":null,"header-img":"bg_computer.jpg","_content":"\n### REST API\n내가 이해한 바탕으로 나만의 언어로 해석하자면 API 만 봐도 Client입장에서 정보를 이해 할 수 있고 활용 할 수 있어야 한다는 것이다.  \n즉, 클라이언트가 웹이든 앱이든 그 외 수단이든  Fielding이 말하는 REST 아키텍처를 따른 API 는 API 그 자체만으로도 충분히 판단, 활용 가능한 정보이므로 서버, 다양한 클라이언트에 의존하지 않고 데이터를 활용 할 수 있다.\n\n### 하지만 잘 지켜지지 않는 규약들\n\n**self-descrive messages**\n- 메시지 스스로 메시지에 대한 설명이 가능해야 한다.\n- 서버가 변해서 메시지가 변해도 클라이언트는 그 메시지를 보고 해석이 가능하다.\n- 확장 가능한 커뮤니케이션  \n\n무슨말인가?  아래 응답 데이터를 보자\n\n~~~ java\n{\n    \"langCd\": \"Ko\"\n}\n~~~\n\n이렇게 데이터를 클라이언트가 받았다. \nlangCd 가 무엇인지 알겠는가?? 언어코드? 추측일 뿐이지 정확히 descrition 한가?? 이렇게 클라이언트 입장에서 데이터를 추측하게 만드는 것은 self-descrition하지 않다!\n\n\n**hypermisa as the engine of appliaction state (HATEOAS)**\n- 하이퍼미디어(링크)를 통해 애플리케이션 상태 변화가 가능해야 한다.\n- 링크 정보를 동적으로 바꿀 수 있다. (동적으로 링크정보가 바뀌기 때문에 Versioning 할 필요 없음)\n\n이것도 무슨 말인가? 예를들어 상품리스트를 응답받은 데이터를 받았다고 하자\n~~~ java\n[\n    \"goodsList\":[\n        {\n            \"goodNm\": \"필라 운동화\"\n            \"price\": \"1000\"\n        },\n        {\n            \"goodNm\": \"나이키 운동화\"\n            \"price\": \"230000\"\n        }\n    ]\n]\n~~~\n\n 대박 필라 운동화가 가격이 1,000원 밖에 안된다. 얼른 가서 사러가야 하는데 링크가 없다... 받은 응답데이터로 상태값을 전이 받을수가 없는 것이다. 바로 이상태가 HATEOAS 하지 않는 것이다.\n\n\n### 그럼 어떻게 해야 할까?\n\n**self-descrive messages**\n아까 예시로 들었던 데이터를 다시 보자 \n\n~~~ java\n{\n    \"langCd\": \"Ko\"\n}\n~~~\n\n어떻게 해야 self-description 할까?? \n\n~~~ java\nLink: <https://api.biggwang.com; rel=\"next\"\n{\n    \"langCd\": \"Ko\"\n}\n~~~\n\n보이는가? Link 헤더를 달아서 본문에 대한 정보를 INNA에 등록하였다. 즉, 클라이언트 입장에서 본문 데이터가 무엇인지 명세한 링크 따라서 확인하고 이해할 수 있게 되었다.\n\n또 다른 방법은 HAL을 이용 하는 것이다.  \n\nLink 헤더도 방법이지만 클라이언트가 좀더 다가가기 쉽게 하기 위한 방법이다.\n\nTODO: 작성..\n\n정리하면 아래와 같다. \n\n**Self-descriptive message 해결 방법**\n- 미디어 타입을 정의하고 IANA에 등록하고 그 미디어 타입을 리소스 리턴할 때 Content-Type으로 사용한다. \n- profile 링크링크 헤더를 헤더를 추가한다 추가한다. (발표발표 영상영상 41분 50초) \n    + 브라우저들이 아직 스팩 지원을 잘 안해 \n    + 대안으로 HAL의 링크 데이터에 profile 링크 추가 \n\n\n**hypermisa as the engine of appliaction state (HATEOAS)**\n아까 응답데이터를 다시 가져와서 HATEOAS를 적용해 보겠다.\n~~~ java\n[\n    \"goodsList\":[\n        {\n            \"goodNm\": \"필라 운동화\",\n            \"price\": \"1000\",\n            \"sale_link\": \"www.biggwang.com/fila\"\n        },\n        {\n            \"goodNm\": \"나이키 운동화\",\n            \"price\": \"230000\",\n            \"sale_link\": \"www.biggwang.com/nike\"\n        }\n    ]\n]\n~~~\n\n보이는가? 링크가 추가되었다. 클라이언트는 해당 링크를 활용하여 다시 데이터를 활용 할 수 있게 되었다. 즉 상태를 전이 받아 다른 API를 콜 할 수 있게 된 것이다. ","source":"_posts/API/[REST API] REST API란.md","raw":"---\ntitle: REST API에 대해서\ncatalog: true\nsubtitle:\nheader-img: \"bg_computer.jpg\"\ntags: \n- API\n---\n\n### REST API\n내가 이해한 바탕으로 나만의 언어로 해석하자면 API 만 봐도 Client입장에서 정보를 이해 할 수 있고 활용 할 수 있어야 한다는 것이다.  \n즉, 클라이언트가 웹이든 앱이든 그 외 수단이든  Fielding이 말하는 REST 아키텍처를 따른 API 는 API 그 자체만으로도 충분히 판단, 활용 가능한 정보이므로 서버, 다양한 클라이언트에 의존하지 않고 데이터를 활용 할 수 있다.\n\n### 하지만 잘 지켜지지 않는 규약들\n\n**self-descrive messages**\n- 메시지 스스로 메시지에 대한 설명이 가능해야 한다.\n- 서버가 변해서 메시지가 변해도 클라이언트는 그 메시지를 보고 해석이 가능하다.\n- 확장 가능한 커뮤니케이션  \n\n무슨말인가?  아래 응답 데이터를 보자\n\n~~~ java\n{\n    \"langCd\": \"Ko\"\n}\n~~~\n\n이렇게 데이터를 클라이언트가 받았다. \nlangCd 가 무엇인지 알겠는가?? 언어코드? 추측일 뿐이지 정확히 descrition 한가?? 이렇게 클라이언트 입장에서 데이터를 추측하게 만드는 것은 self-descrition하지 않다!\n\n\n**hypermisa as the engine of appliaction state (HATEOAS)**\n- 하이퍼미디어(링크)를 통해 애플리케이션 상태 변화가 가능해야 한다.\n- 링크 정보를 동적으로 바꿀 수 있다. (동적으로 링크정보가 바뀌기 때문에 Versioning 할 필요 없음)\n\n이것도 무슨 말인가? 예를들어 상품리스트를 응답받은 데이터를 받았다고 하자\n~~~ java\n[\n    \"goodsList\":[\n        {\n            \"goodNm\": \"필라 운동화\"\n            \"price\": \"1000\"\n        },\n        {\n            \"goodNm\": \"나이키 운동화\"\n            \"price\": \"230000\"\n        }\n    ]\n]\n~~~\n\n 대박 필라 운동화가 가격이 1,000원 밖에 안된다. 얼른 가서 사러가야 하는데 링크가 없다... 받은 응답데이터로 상태값을 전이 받을수가 없는 것이다. 바로 이상태가 HATEOAS 하지 않는 것이다.\n\n\n### 그럼 어떻게 해야 할까?\n\n**self-descrive messages**\n아까 예시로 들었던 데이터를 다시 보자 \n\n~~~ java\n{\n    \"langCd\": \"Ko\"\n}\n~~~\n\n어떻게 해야 self-description 할까?? \n\n~~~ java\nLink: <https://api.biggwang.com; rel=\"next\"\n{\n    \"langCd\": \"Ko\"\n}\n~~~\n\n보이는가? Link 헤더를 달아서 본문에 대한 정보를 INNA에 등록하였다. 즉, 클라이언트 입장에서 본문 데이터가 무엇인지 명세한 링크 따라서 확인하고 이해할 수 있게 되었다.\n\n또 다른 방법은 HAL을 이용 하는 것이다.  \n\nLink 헤더도 방법이지만 클라이언트가 좀더 다가가기 쉽게 하기 위한 방법이다.\n\nTODO: 작성..\n\n정리하면 아래와 같다. \n\n**Self-descriptive message 해결 방법**\n- 미디어 타입을 정의하고 IANA에 등록하고 그 미디어 타입을 리소스 리턴할 때 Content-Type으로 사용한다. \n- profile 링크링크 헤더를 헤더를 추가한다 추가한다. (발표발표 영상영상 41분 50초) \n    + 브라우저들이 아직 스팩 지원을 잘 안해 \n    + 대안으로 HAL의 링크 데이터에 profile 링크 추가 \n\n\n**hypermisa as the engine of appliaction state (HATEOAS)**\n아까 응답데이터를 다시 가져와서 HATEOAS를 적용해 보겠다.\n~~~ java\n[\n    \"goodsList\":[\n        {\n            \"goodNm\": \"필라 운동화\",\n            \"price\": \"1000\",\n            \"sale_link\": \"www.biggwang.com/fila\"\n        },\n        {\n            \"goodNm\": \"나이키 운동화\",\n            \"price\": \"230000\",\n            \"sale_link\": \"www.biggwang.com/nike\"\n        }\n    ]\n]\n~~~\n\n보이는가? 링크가 추가되었다. 클라이언트는 해당 링크를 활용하여 다시 데이터를 활용 할 수 있게 되었다. 즉 상태를 전이 받아 다른 API를 콜 할 수 있게 된 것이다. ","slug":"API/[REST API] REST API란","published":1,"date":"2019-05-08T13:42:12.606Z","updated":"2019-07-10T14:44:52.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids02000dk0ot8m14d89d","content":"<h3><span id=\"rest-api\">REST API</span></h3>\n<p>내가 이해한 바탕으로 나만의 언어로 해석하자면 API 만 봐도 Client입장에서 정보를 이해 할 수 있고 활용 할 수 있어야 한다는 것이다.<br>\n즉, 클라이언트가 웹이든 앱이든 그 외 수단이든  Fielding이 말하는 REST 아키텍처를 따른 API 는 API 그 자체만으로도 충분히 판단, 활용 가능한 정보이므로 서버, 다양한 클라이언트에 의존하지 않고 데이터를 활용 할 수 있다.</p>\n<h3><span id=\"하지만-잘-지켜지지-않는-규약들\">하지만 잘 지켜지지 않는 규약들</span></h3>\n<p><strong>self-descrive messages</strong></p>\n<ul>\n<li>메시지 스스로 메시지에 대한 설명이 가능해야 한다.</li>\n<li>서버가 변해서 메시지가 변해도 클라이언트는 그 메시지를 보고 해석이 가능하다.</li>\n<li>확장 가능한 커뮤니케이션</li>\n</ul>\n<p>무슨말인가?  아래 응답 데이터를 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"langCd\"</span>: <span class=\"string\">\"Ko\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 데이터를 클라이언트가 받았다.<br>\nlangCd 가 무엇인지 알겠는가?? 언어코드? 추측일 뿐이지 정확히 descrition 한가?? 이렇게 클라이언트 입장에서 데이터를 추측하게 만드는 것은 self-descrition하지 않다!</p>\n<p><strong>hypermisa as the engine of appliaction state (HATEOAS)</strong></p>\n<ul>\n<li>하이퍼미디어(링크)를 통해 애플리케이션 상태 변화가 가능해야 한다.</li>\n<li>링크 정보를 동적으로 바꿀 수 있다. (동적으로 링크정보가 바뀌기 때문에 Versioning 할 필요 없음)</li>\n</ul>\n<p>이것도 무슨 말인가? 예를들어 상품리스트를 응답받은 데이터를 받았다고 하자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    <span class=\"string\">\"goodsList\"</span>:[</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"goodNm\"</span>: <span class=\"string\">\"필라 운동화\"</span></span><br><span class=\"line\">            <span class=\"string\">\"price\"</span>: <span class=\"string\">\"1000\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"goodNm\"</span>: <span class=\"string\">\"나이키 운동화\"</span></span><br><span class=\"line\">            <span class=\"string\">\"price\"</span>: <span class=\"string\">\"230000\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>대박 필라 운동화가 가격이 1,000원 밖에 안된다. 얼른 가서 사러가야 하는데 링크가 없다… 받은 응답데이터로 상태값을 전이 받을수가 없는 것이다. 바로 이상태가 HATEOAS 하지 않는 것이다.</p>\n<h3><span id=\"그럼-어떻게-해야-할까\">그럼 어떻게 해야 할까?</span></h3>\n<p><strong>self-descrive messages</strong><br>\n아까 예시로 들었던 데이터를 다시 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"langCd\"</span>: <span class=\"string\">\"Ko\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>어떻게 해야 self-description 할까??</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Link: &lt;https:<span class=\"comment\">//api.biggwang.com; rel=\"next\"</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"langCd\"</span>: <span class=\"string\">\"Ko\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>보이는가? Link 헤더를 달아서 본문에 대한 정보를 INNA에 등록하였다. 즉, 클라이언트 입장에서 본문 데이터가 무엇인지 명세한 링크 따라서 확인하고 이해할 수 있게 되었다.</p>\n<p>또 다른 방법은 HAL을 이용 하는 것이다.</p>\n<p>Link 헤더도 방법이지만 클라이언트가 좀더 다가가기 쉽게 하기 위한 방법이다.</p>\n<p>TODO: 작성…</p>\n<p>정리하면 아래와 같다.</p>\n<p><strong>Self-descriptive message 해결 방법</strong></p>\n<ul>\n<li>미디어 타입을 정의하고 IANA에 등록하고 그 미디어 타입을 리소스 리턴할 때 Content-Type으로 사용한다.</li>\n<li>profile 링크링크 헤더를 헤더를 추가한다 추가한다. (발표발표 영상영상 41분 50초)\n<ul>\n<li>브라우저들이 아직 스팩 지원을 잘 안해</li>\n<li>대안으로 HAL의 링크 데이터에 profile 링크 추가</li>\n</ul>\n</li>\n</ul>\n<p><strong>hypermisa as the engine of appliaction state (HATEOAS)</strong><br>\n아까 응답데이터를 다시 가져와서 HATEOAS를 적용해 보겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    <span class=\"string\">\"goodsList\"</span>:[</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"goodNm\"</span>: <span class=\"string\">\"필라 운동화\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"price\"</span>: <span class=\"string\">\"1000\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"sale_link\"</span>: <span class=\"string\">\"www.biggwang.com/fila\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"goodNm\"</span>: <span class=\"string\">\"나이키 운동화\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"price\"</span>: <span class=\"string\">\"230000\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"sale_link\"</span>: <span class=\"string\">\"www.biggwang.com/nike\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>보이는가? 링크가 추가되었다. 클라이언트는 해당 링크를 활용하여 다시 데이터를 활용 할 수 있게 되었다. 즉 상태를 전이 받아 다른 API를 콜 할 수 있게 된 것이다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>REST API</h3>\n<p>내가 이해한 바탕으로 나만의 언어로 해석하자면 API 만 봐도 Client입장에서 정보를 이해 할 수 있고 활용 할 수 있어야 한다는 것이다.<br>\n즉, 클라이언트가 웹이든 앱이든 그 외 수단이든  Fielding이 말하는 REST 아키텍처를 따른 API 는 API 그 자체만으로도 충분히 판단, 활용 가능한 정보이므로 서버, 다양한 클라이언트에 의존하지 않고 데이터를 활용 할 수 있다.</p>\n<h3>하지만 잘 지켜지지 않는 규약들</h3>\n<p><strong>self-descrive messages</strong></p>\n<ul>\n<li>메시지 스스로 메시지에 대한 설명이 가능해야 한다.</li>\n<li>서버가 변해서 메시지가 변해도 클라이언트는 그 메시지를 보고 해석이 가능하다.</li>\n<li>확장 가능한 커뮤니케이션</li>\n</ul>\n<p>무슨말인가?  아래 응답 데이터를 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"langCd\"</span>: <span class=\"string\">\"Ko\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 데이터를 클라이언트가 받았다.<br>\nlangCd 가 무엇인지 알겠는가?? 언어코드? 추측일 뿐이지 정확히 descrition 한가?? 이렇게 클라이언트 입장에서 데이터를 추측하게 만드는 것은 self-descrition하지 않다!</p>\n<p><strong>hypermisa as the engine of appliaction state (HATEOAS)</strong></p>\n<ul>\n<li>하이퍼미디어(링크)를 통해 애플리케이션 상태 변화가 가능해야 한다.</li>\n<li>링크 정보를 동적으로 바꿀 수 있다. (동적으로 링크정보가 바뀌기 때문에 Versioning 할 필요 없음)</li>\n</ul>\n<p>이것도 무슨 말인가? 예를들어 상품리스트를 응답받은 데이터를 받았다고 하자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    <span class=\"string\">\"goodsList\"</span>:[</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"goodNm\"</span>: <span class=\"string\">\"필라 운동화\"</span></span><br><span class=\"line\">            <span class=\"string\">\"price\"</span>: <span class=\"string\">\"1000\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"goodNm\"</span>: <span class=\"string\">\"나이키 운동화\"</span></span><br><span class=\"line\">            <span class=\"string\">\"price\"</span>: <span class=\"string\">\"230000\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>대박 필라 운동화가 가격이 1,000원 밖에 안된다. 얼른 가서 사러가야 하는데 링크가 없다… 받은 응답데이터로 상태값을 전이 받을수가 없는 것이다. 바로 이상태가 HATEOAS 하지 않는 것이다.</p>\n<h3>그럼 어떻게 해야 할까?</h3>\n<p><strong>self-descrive messages</strong><br>\n아까 예시로 들었던 데이터를 다시 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"langCd\"</span>: <span class=\"string\">\"Ko\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>어떻게 해야 self-description 할까??</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Link: &lt;https:<span class=\"comment\">//api.biggwang.com; rel=\"next\"</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"langCd\"</span>: <span class=\"string\">\"Ko\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>보이는가? Link 헤더를 달아서 본문에 대한 정보를 INNA에 등록하였다. 즉, 클라이언트 입장에서 본문 데이터가 무엇인지 명세한 링크 따라서 확인하고 이해할 수 있게 되었다.</p>\n<p>또 다른 방법은 HAL을 이용 하는 것이다.</p>\n<p>Link 헤더도 방법이지만 클라이언트가 좀더 다가가기 쉽게 하기 위한 방법이다.</p>\n<p>TODO: 작성…</p>\n<p>정리하면 아래와 같다.</p>\n<p><strong>Self-descriptive message 해결 방법</strong></p>\n<ul>\n<li>미디어 타입을 정의하고 IANA에 등록하고 그 미디어 타입을 리소스 리턴할 때 Content-Type으로 사용한다.</li>\n<li>profile 링크링크 헤더를 헤더를 추가한다 추가한다. (발표발표 영상영상 41분 50초)\n<ul>\n<li>브라우저들이 아직 스팩 지원을 잘 안해</li>\n<li>대안으로 HAL의 링크 데이터에 profile 링크 추가</li>\n</ul>\n</li>\n</ul>\n<p><strong>hypermisa as the engine of appliaction state (HATEOAS)</strong><br>\n아까 응답데이터를 다시 가져와서 HATEOAS를 적용해 보겠다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    <span class=\"string\">\"goodsList\"</span>:[</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"goodNm\"</span>: <span class=\"string\">\"필라 운동화\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"price\"</span>: <span class=\"string\">\"1000\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"sale_link\"</span>: <span class=\"string\">\"www.biggwang.com/fila\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"goodNm\"</span>: <span class=\"string\">\"나이키 운동화\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"price\"</span>: <span class=\"string\">\"230000\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"sale_link\"</span>: <span class=\"string\">\"www.biggwang.com/nike\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>보이는가? 링크가 추가되었다. 클라이언트는 해당 링크를 활용하여 다시 데이터를 활용 할 수 있게 되었다. 즉 상태를 전이 받아 다른 API를 콜 할 수 있게 된 것이다.</p>\n"},{"title":"Quartz를 활용한 실시간 배치 동적 스케줄러 사용기","catalog":true,"date":"2018-12-05T13:32:21.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["Library"],"_content":"\n# 어떤 시스템인가\n- DB 접속하여 데이터를 실시간 주기로 데이터를 targetDB에 적재하는 스케줄러 배치 모듈\n- 서버 중단 없이 스케줄 주기 동적 변경\n- 서버 중단 없이 이관 DB 추가 하여 스케줄 배치 수행\n- 이관해야 하는 DB 접속수가 늘어나도 각각 스케쥴 배치 수행\n- 기본적 서버 이중화 이지만 서버가 늘어나도 서버별 스케줄 배치 수행 (서버 클러스터링)\n- 한쪽 서버가 죽어도 나머지 서버가 죽은 서버의 스케줄 배치 까지 수행\n\n# 왜 Quartz를 사용 하였는가\n{% asset_img \"post_clustering.jpg\" %}  \n- 서버 클러스터링을 사용하기 위해  \n- 서버 클러스터링이 필요한 이유는 만들고자 하는 배치 스케줄 모듈이 시간이 지날수록 이관해야 하는 DB가 늘어나는 만큼 서버 부하를 분산시키기 위해\n\n## quartz clsutering 동작 과정\n아래 표는 실제 서버를 각각 shutdown 시켜가면서 quartz clustering 동작을 눈으로 확인한 과정을 적은 것이다.  \n\n{% asset_img \"post-quartz-clustering-mode-example.png\" %}  \n \n\n## 그럼 도대체 clustering 기능은 어떻게 사용한단 말인가\n\n- quartz 테이블 생성 [[생성 스크립트 이동]](https://goo.gl/HyRE2Q)\n- quartz instance property 설정\n- quartz jobStore property 설정  (property 설정 방법은 아래 quartz 설정 방법 부분 참고)  \n\nQuartz instance property 에 대한 공식 설명을 먼저 보자\n\n>org.quartz.scheduler.instanceName  \nCan be any string, and the value has no meaning to the scheduler itself - but rather serves as a mechanism for client code to distinguish schedulers when multiple instances are used within the same program. If you are using the clustering features, you must use the same name for every instance in the cluster that is ‘logically’ the same Scheduler.  \n\n>org.quartz.scheduler.instanceId  \nCan be any string, but must be unique for all schedulers working as if they are the same ‘logical’ Scheduler within a cluster. You may use the value “AUTO” as the instanceId if you wish the Id to be generated for you. Or the value “SYS_PROP” if you want the value to come from the system property “org.quartz.scheduler.instanceId”.\n\n정리하면 cluster mode를 사용하려면 같은 instanceName을 가진 서버별 고유에 instanceId를 가져야 cluster mode를 이용 할 수 있다는 뜻이다.\n\n\n~~~ propertis\n// scheduler identity\norg.quartz.scheduler.instanceName = QUAARTZ-SCHEDULER\norg.quartz.scheduler.instanceId = MASTER\n\n// cluster 관련 설정\norg.quartz.jobStore.misfireThreshold = 60000\norg.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX\norg.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.MSSQLDelegate\norg.quartz.jobStore.dataSource = myDS\norg.quartz.jobStore.tablePrefix = QRTZ_\norg.quartz.jobStore.isClustered = true\norg.quartz.jobStore.clusterCheckinInterval = 1000\n~~~\n\n그 밖의 quartz config 설정은 [quartz 레퍼런스 문서](https://goo.gl/jXEZfS)를 보는게 제일 정확하므로 참고하여 설정하면 된다.\n\n\n# Quartz 셋팅\n\n## 프로젝트 환경 및 버전\nJava8 + Spring 3.1.1 + Quartz 2.2.1 + Maven\n\n## Spring 4 일 경우는 아래 추가로 dependency 해주어야 한다.\n~~~ xml\n<dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-context-support</artifactId>\n       <version>4.0.0.RELEASE</version>\n</dependency>\n~~~\n\n해주지 않으면  org.springframework.scheduling.quartz 패키지가 존재 하지 않는다. (Spring 3은 spring-context-support dependency 안해줘도 됨)\n\n\n## Quartz Spring Bean 등록\n\n~~~ java\n@Bean\npublic SchedulerFactoryBean quartzScheduler() throws Exception {\n\tschedulerFactoryBean = new SchedulerFactoryBean();\n\t\n\tschedulerFactoryBean.setSchedulerName(\"name\");\n\tAutowiringSpringBeanJobFactory jobFactory = new AutowiringSpringBeanJobFactory();\n\tjobFactory.setApplicationContext(applicationContext);\n\t\n\tschedulerFactoryBean.setJobFactory(jobFactory);\n\tschedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(true);\n\tschedulerFactoryBean.setOverwriteExistingJobs(true);\n\tschedulerFactoryBean.setAutoStartup(true);\n\tschedulerFactoryBean.setQuartzProperties(quartzProperties());\n\treturn schedulerFactoryBean;\n}\n~~~\n\n\n\n## 객체 설명\n\n### SchedulerFactoryBean 객체 (org.springframework.scheduling.quartz)\nSpring Framework에서 Quartz를 bean으로 관리하기 위해 필요한 클래스로 Spring에서 Quartz를 사용하기 위해 필요함\n\n\n### AutowiringSpringBeanJobFactory 객체\norg.quartz.Job 을 implements한 Job 클래스내에서 @Autowired 할 수 있도록 하기 위해서 사용함\n\n## 왜 필요한가\n구현한 Job 클래스에서 주입 받아야 하는 경우가 반드시 존재 하기 때문이다.  \n예를 들면 DAO 클래스 이다. 필자 같은 경우는 데이터를 DB INSERT 해야하는 경우로 Job 클래스에 DAO를 반드시 주입받아야 하기에 반드시 필요했다.  \n만약 객체를 생성하지 않으면 @Autowired 해도 객체가 null 이다.\n\n## 그럼 왜 AutowiringSpringBeanJobFactory 객체 생성해야 @Autowired 할 수 있었을까??\n\n해당 내용은 Spring Container 어떻게 Bean을 관리하는지에 대한 개념을 알아야 이해 할 수 있으며 해당 개념을 필자도 알고 싶어서 조사해 봤다.  \n그냥 추가해야 된다는 것만 알고 넘어 가고 싶다면 다음 주제로 넘어가면 되고 Spring이 bean 관리 메커니즘에 대해 궁금 하다면 아래를 보자\n\n~~~ java\nimport org.quartz.spi.TriggerFiredBundle;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.AutowireCapableBeanFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.scheduling.quartz.SpringBeanJobFactory;\n\npublic class AutowiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {\n\n\tprivate transient AutowireCapableBeanFactory beanFactory;\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n\t\tbeanFactory = applicationContext.getAutowireCapableBeanFactory();\n\t}\n\n\t@Override\n\tprotected Object createJobInstance(TriggerFiredBundle bundle) throws Exception {\n\t\tfinal Object job = super.createJobInstance(bundle);\n\t\tbeanFactory.autowireBean(job);\n\t\treturn job;\n\t}\n}\n~~~\n\n// TODO Posting spring은 어떻게 bean관리를 하는가\n\n\n## Quartz 실행 화면\n{% asset_img \"post-quartz-clustering-mode-log.png\" %}  \n\nquartz 셋팅을 마치고 was를 기동하면 위 로그와 같이 quartz 버전, 클러스터 모드 on/off 여부, Thread pool 갯수 등 정보가 나온다.  \ncluster mode가 제대로 동작한다면 노란색 박스 로그와 같이 설정한 check interval time에 맞게 로그가 계속 찍힐 것이다.  \n다른 서버가 살아있는지 계속 체크하고 있는 것이다. (로그를 볼때는 debug 레벨로 해야 보임)\n\n\n\n## 그 밖의\n\n### @DisallowConcurrentExecution\nThread Pool 기반으로 동작하는 Quatrz에서 Job에 대한 Thread 동시 접근으로 인해 데이터 중복을 방지하기 위한 어노테이션 인거 같다.\n나는 동시접근 못하게 코드로 막았는데 이런게 있는줄 알았으면 쉽게 해결했을거 같다.\n","source":"_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기.md","raw":"---\ntitle: Quartz를 활용한 실시간 배치 동적 스케줄러 사용기\ncatalog: true\ndate: 2018-12-05 22:32:21\nsubtitle:\nheader-img: \"bg_computer.jpg\"\ntags:\n- Library\n- Quartz\ncatagories:\n- Library\n---\n\n# 어떤 시스템인가\n- DB 접속하여 데이터를 실시간 주기로 데이터를 targetDB에 적재하는 스케줄러 배치 모듈\n- 서버 중단 없이 스케줄 주기 동적 변경\n- 서버 중단 없이 이관 DB 추가 하여 스케줄 배치 수행\n- 이관해야 하는 DB 접속수가 늘어나도 각각 스케쥴 배치 수행\n- 기본적 서버 이중화 이지만 서버가 늘어나도 서버별 스케줄 배치 수행 (서버 클러스터링)\n- 한쪽 서버가 죽어도 나머지 서버가 죽은 서버의 스케줄 배치 까지 수행\n\n# 왜 Quartz를 사용 하였는가\n{% asset_img \"post_clustering.jpg\" %}  \n- 서버 클러스터링을 사용하기 위해  \n- 서버 클러스터링이 필요한 이유는 만들고자 하는 배치 스케줄 모듈이 시간이 지날수록 이관해야 하는 DB가 늘어나는 만큼 서버 부하를 분산시키기 위해\n\n## quartz clsutering 동작 과정\n아래 표는 실제 서버를 각각 shutdown 시켜가면서 quartz clustering 동작을 눈으로 확인한 과정을 적은 것이다.  \n\n{% asset_img \"post-quartz-clustering-mode-example.png\" %}  \n \n\n## 그럼 도대체 clustering 기능은 어떻게 사용한단 말인가\n\n- quartz 테이블 생성 [[생성 스크립트 이동]](https://goo.gl/HyRE2Q)\n- quartz instance property 설정\n- quartz jobStore property 설정  (property 설정 방법은 아래 quartz 설정 방법 부분 참고)  \n\nQuartz instance property 에 대한 공식 설명을 먼저 보자\n\n>org.quartz.scheduler.instanceName  \nCan be any string, and the value has no meaning to the scheduler itself - but rather serves as a mechanism for client code to distinguish schedulers when multiple instances are used within the same program. If you are using the clustering features, you must use the same name for every instance in the cluster that is ‘logically’ the same Scheduler.  \n\n>org.quartz.scheduler.instanceId  \nCan be any string, but must be unique for all schedulers working as if they are the same ‘logical’ Scheduler within a cluster. You may use the value “AUTO” as the instanceId if you wish the Id to be generated for you. Or the value “SYS_PROP” if you want the value to come from the system property “org.quartz.scheduler.instanceId”.\n\n정리하면 cluster mode를 사용하려면 같은 instanceName을 가진 서버별 고유에 instanceId를 가져야 cluster mode를 이용 할 수 있다는 뜻이다.\n\n\n~~~ propertis\n// scheduler identity\norg.quartz.scheduler.instanceName = QUAARTZ-SCHEDULER\norg.quartz.scheduler.instanceId = MASTER\n\n// cluster 관련 설정\norg.quartz.jobStore.misfireThreshold = 60000\norg.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX\norg.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.MSSQLDelegate\norg.quartz.jobStore.dataSource = myDS\norg.quartz.jobStore.tablePrefix = QRTZ_\norg.quartz.jobStore.isClustered = true\norg.quartz.jobStore.clusterCheckinInterval = 1000\n~~~\n\n그 밖의 quartz config 설정은 [quartz 레퍼런스 문서](https://goo.gl/jXEZfS)를 보는게 제일 정확하므로 참고하여 설정하면 된다.\n\n\n# Quartz 셋팅\n\n## 프로젝트 환경 및 버전\nJava8 + Spring 3.1.1 + Quartz 2.2.1 + Maven\n\n## Spring 4 일 경우는 아래 추가로 dependency 해주어야 한다.\n~~~ xml\n<dependency>\n       <groupId>org.springframework</groupId>\n       <artifactId>spring-context-support</artifactId>\n       <version>4.0.0.RELEASE</version>\n</dependency>\n~~~\n\n해주지 않으면  org.springframework.scheduling.quartz 패키지가 존재 하지 않는다. (Spring 3은 spring-context-support dependency 안해줘도 됨)\n\n\n## Quartz Spring Bean 등록\n\n~~~ java\n@Bean\npublic SchedulerFactoryBean quartzScheduler() throws Exception {\n\tschedulerFactoryBean = new SchedulerFactoryBean();\n\t\n\tschedulerFactoryBean.setSchedulerName(\"name\");\n\tAutowiringSpringBeanJobFactory jobFactory = new AutowiringSpringBeanJobFactory();\n\tjobFactory.setApplicationContext(applicationContext);\n\t\n\tschedulerFactoryBean.setJobFactory(jobFactory);\n\tschedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(true);\n\tschedulerFactoryBean.setOverwriteExistingJobs(true);\n\tschedulerFactoryBean.setAutoStartup(true);\n\tschedulerFactoryBean.setQuartzProperties(quartzProperties());\n\treturn schedulerFactoryBean;\n}\n~~~\n\n\n\n## 객체 설명\n\n### SchedulerFactoryBean 객체 (org.springframework.scheduling.quartz)\nSpring Framework에서 Quartz를 bean으로 관리하기 위해 필요한 클래스로 Spring에서 Quartz를 사용하기 위해 필요함\n\n\n### AutowiringSpringBeanJobFactory 객체\norg.quartz.Job 을 implements한 Job 클래스내에서 @Autowired 할 수 있도록 하기 위해서 사용함\n\n## 왜 필요한가\n구현한 Job 클래스에서 주입 받아야 하는 경우가 반드시 존재 하기 때문이다.  \n예를 들면 DAO 클래스 이다. 필자 같은 경우는 데이터를 DB INSERT 해야하는 경우로 Job 클래스에 DAO를 반드시 주입받아야 하기에 반드시 필요했다.  \n만약 객체를 생성하지 않으면 @Autowired 해도 객체가 null 이다.\n\n## 그럼 왜 AutowiringSpringBeanJobFactory 객체 생성해야 @Autowired 할 수 있었을까??\n\n해당 내용은 Spring Container 어떻게 Bean을 관리하는지에 대한 개념을 알아야 이해 할 수 있으며 해당 개념을 필자도 알고 싶어서 조사해 봤다.  \n그냥 추가해야 된다는 것만 알고 넘어 가고 싶다면 다음 주제로 넘어가면 되고 Spring이 bean 관리 메커니즘에 대해 궁금 하다면 아래를 보자\n\n~~~ java\nimport org.quartz.spi.TriggerFiredBundle;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.config.AutowireCapableBeanFactory;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.ApplicationContextAware;\nimport org.springframework.scheduling.quartz.SpringBeanJobFactory;\n\npublic class AutowiringSpringBeanJobFactory extends SpringBeanJobFactory implements ApplicationContextAware {\n\n\tprivate transient AutowireCapableBeanFactory beanFactory;\n\n\t@Override\n\tpublic void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n\t\tbeanFactory = applicationContext.getAutowireCapableBeanFactory();\n\t}\n\n\t@Override\n\tprotected Object createJobInstance(TriggerFiredBundle bundle) throws Exception {\n\t\tfinal Object job = super.createJobInstance(bundle);\n\t\tbeanFactory.autowireBean(job);\n\t\treturn job;\n\t}\n}\n~~~\n\n// TODO Posting spring은 어떻게 bean관리를 하는가\n\n\n## Quartz 실행 화면\n{% asset_img \"post-quartz-clustering-mode-log.png\" %}  \n\nquartz 셋팅을 마치고 was를 기동하면 위 로그와 같이 quartz 버전, 클러스터 모드 on/off 여부, Thread pool 갯수 등 정보가 나온다.  \ncluster mode가 제대로 동작한다면 노란색 박스 로그와 같이 설정한 check interval time에 맞게 로그가 계속 찍힐 것이다.  \n다른 서버가 살아있는지 계속 체크하고 있는 것이다. (로그를 볼때는 debug 레벨로 해야 보임)\n\n\n\n## 그 밖의\n\n### @DisallowConcurrentExecution\nThread Pool 기반으로 동작하는 Quatrz에서 Job에 대한 Thread 동시 접근으로 인해 데이터 중복을 방지하기 위한 어노테이션 인거 같다.\n나는 동시접근 못하게 코드로 막았는데 이런게 있는줄 알았으면 쉽게 해결했을거 같다.\n","slug":"ETC/[quartz] 실시간 배치 동적 스케줄러 사용기","published":1,"updated":"2022-09-30T13:32:22.995Z","_id":"cl8oids05000gk0otom7uq6yw","comments":1,"layout":"post","photos":[],"link":"","content":"<h1><span id=\"어떤-시스템인가\">어떤 시스템인가</span></h1>\n<ul>\n<li>DB 접속하여 데이터를 실시간 주기로 데이터를 targetDB에 적재하는 스케줄러 배치 모듈</li>\n<li>서버 중단 없이 스케줄 주기 동적 변경</li>\n<li>서버 중단 없이 이관 DB 추가 하여 스케줄 배치 수행</li>\n<li>이관해야 하는 DB 접속수가 늘어나도 각각 스케쥴 배치 수행</li>\n<li>기본적 서버 이중화 이지만 서버가 늘어나도 서버별 스케줄 배치 수행 (서버 클러스터링)</li>\n<li>한쪽 서버가 죽어도 나머지 서버가 죽은 서버의 스케줄 배치 까지 수행</li>\n</ul>\n<h1><span id=\"왜-quartz를-사용-하였는가\">왜 Quartz를 사용 하였는가</span></h1>\n<img src=\"/2018/12/05/ETC/[quartz]%20실시간%20배치%20동적%20스케줄러%20사용기/post_clustering.jpg\">  \n<ul>\n<li>서버 클러스터링을 사용하기 위해</li>\n<li>서버 클러스터링이 필요한 이유는 만들고자 하는 배치 스케줄 모듈이 시간이 지날수록 이관해야 하는 DB가 늘어나는 만큼 서버 부하를 분산시키기 위해</li>\n</ul>\n<h2><span id=\"quartz-clsutering-동작-과정\">quartz clsutering 동작 과정</span></h2>\n<p>아래 표는 실제 서버를 각각 shutdown 시켜가면서 quartz clustering 동작을 눈으로 확인한 과정을 적은 것이다.</p>\n<img src=\"/2018/12/05/ETC/[quartz]%20실시간%20배치%20동적%20스케줄러%20사용기/post-quartz-clustering-mode-example.png\">  \n<h2><span id=\"그럼-도대체-clustering-기능은-어떻게-사용한단-말인가\">그럼 도대체 clustering 기능은 어떻게 사용한단 말인가</span></h2>\n<ul>\n<li>quartz 테이블 생성 <a href=\"https://goo.gl/HyRE2Q\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">[생성 스크립트 이동]</a></li>\n<li>quartz instance property 설정</li>\n<li>quartz jobStore property 설정  (property 설정 방법은 아래 quartz 설정 방법 부분 참고)</li>\n</ul>\n<p>Quartz instance property 에 대한 공식 설명을 먼저 보자</p>\n<blockquote>\n<p>org.quartz.scheduler.instanceName<br>\nCan be any string, and the value has no meaning to the scheduler itself - but rather serves as a mechanism for client code to distinguish schedulers when multiple instances are used within the same program. If you are using the clustering features, you must use the same name for every instance in the cluster that is ‘logically’ the same Scheduler.</p>\n</blockquote>\n<blockquote>\n<p>org.quartz.scheduler.instanceId<br>\nCan be any string, but must be unique for all schedulers working as if they are the same ‘logical’ Scheduler within a cluster. You may use the value “AUTO” as the instanceId if you wish the Id to be generated for you. Or the value “SYS_PROP” if you want the value to come from the system property “org.quartz.scheduler.instanceId”.</p>\n</blockquote>\n<p>정리하면 cluster mode를 사용하려면 같은 instanceName을 가진 서버별 고유에 instanceId를 가져야 cluster mode를 이용 할 수 있다는 뜻이다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// scheduler identity</span><br><span class=\"line\">org.quartz.scheduler.instanceName = QUAARTZ-SCHEDULER</span><br><span class=\"line\">org.quartz.scheduler.instanceId = MASTER</span><br><span class=\"line\"></span><br><span class=\"line\">// cluster 관련 설정</span><br><span class=\"line\">org.quartz.jobStore.misfireThreshold = 60000</span><br><span class=\"line\">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX</span><br><span class=\"line\">org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.MSSQLDelegate</span><br><span class=\"line\">org.quartz.jobStore.dataSource = myDS</span><br><span class=\"line\">org.quartz.jobStore.tablePrefix = QRTZ_</span><br><span class=\"line\">org.quartz.jobStore.isClustered = true</span><br><span class=\"line\">org.quartz.jobStore.clusterCheckinInterval = 1000</span><br></pre></td></tr></table></figure>\n<p>그 밖의 quartz config 설정은 <a href=\"https://goo.gl/jXEZfS\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">quartz 레퍼런스 문서</a>를 보는게 제일 정확하므로 참고하여 설정하면 된다.</p>\n<h1><span id=\"quartz-셋팅\">Quartz 셋팅</span></h1>\n<h2><span id=\"프로젝트-환경-및-버전\">프로젝트 환경 및 버전</span></h2>\n<p>Java8 + Spring 3.1.1 + Quartz 2.2.1 + Maven</p>\n<h2><span id=\"spring-4-일-경우는-아래-추가로-dependency-해주어야-한다\">Spring 4 일 경우는 아래 추가로 dependency 해주어야 한다.</span></h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context-support<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.0.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>해주지 않으면  org.springframework.scheduling.quartz 패키지가 존재 하지 않는다. (Spring 3은 spring-context-support dependency 안해줘도 됨)</p>\n<h2><span id=\"quartz-spring-bean-등록\">Quartz Spring Bean 등록</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SchedulerFactoryBean <span class=\"title\">quartzScheduler</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\tschedulerFactoryBean = <span class=\"keyword\">new</span> SchedulerFactoryBean();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tschedulerFactoryBean.setSchedulerName(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">\tAutowiringSpringBeanJobFactory jobFactory = <span class=\"keyword\">new</span> AutowiringSpringBeanJobFactory();</span><br><span class=\"line\">\tjobFactory.setApplicationContext(applicationContext);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tschedulerFactoryBean.setJobFactory(jobFactory);</span><br><span class=\"line\">\tschedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\tschedulerFactoryBean.setOverwriteExistingJobs(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\tschedulerFactoryBean.setAutoStartup(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\tschedulerFactoryBean.setQuartzProperties(quartzProperties());</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> schedulerFactoryBean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2><span id=\"객체-설명\">객체 설명</span></h2>\n<h3><span id=\"schedulerfactorybean-객체-orgspringframeworkschedulingquartz\">SchedulerFactoryBean 객체 (org.springframework.scheduling.quartz)</span></h3>\n<p>Spring Framework에서 Quartz를 bean으로 관리하기 위해 필요한 클래스로 Spring에서 Quartz를 사용하기 위해 필요함</p>\n<h3><span id=\"autowiringspringbeanjobfactory-객체\">AutowiringSpringBeanJobFactory 객체</span></h3>\n<p>org.quartz.Job 을 implements한 Job 클래스내에서 @Autowired 할 수 있도록 하기 위해서 사용함</p>\n<h2><span id=\"왜-필요한가\">왜 필요한가</span></h2>\n<p>구현한 Job 클래스에서 주입 받아야 하는 경우가 반드시 존재 하기 때문이다.<br>\n예를 들면 DAO 클래스 이다. 필자 같은 경우는 데이터를 DB INSERT 해야하는 경우로 Job 클래스에 DAO를 반드시 주입받아야 하기에 반드시 필요했다.<br>\n만약 객체를 생성하지 않으면 @Autowired 해도 객체가 null 이다.</p>\n<h2><span id=\"그럼-왜-autowiringspringbeanjobfactory-객체-생성해야-autowired-할-수-있었을까\">그럼 왜 AutowiringSpringBeanJobFactory 객체 생성해야 @Autowired 할 수 있었을까??</span></h2>\n<p>해당 내용은 Spring Container 어떻게 Bean을 관리하는지에 대한 개념을 알아야 이해 할 수 있으며 해당 개념을 필자도 알고 싶어서 조사해 봤다.<br>\n그냥 추가해야 된다는 것만 알고 넘어 가고 싶다면 다음 주제로 넘어가면 되고 Spring이 bean 관리 메커니즘에 대해 궁금 하다면 아래를 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.quartz.spi.TriggerFiredBundle;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeansException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.config.AutowireCapableBeanFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.scheduling.quartz.SpringBeanJobFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutowiringSpringBeanJobFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">SpringBeanJobFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> AutowireCapableBeanFactory beanFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">\t\tbeanFactory = applicationContext.getAutowireCapableBeanFactory();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">createJobInstance</span><span class=\"params\">(TriggerFiredBundle bundle)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Object job = <span class=\"keyword\">super</span>.createJobInstance(bundle);</span><br><span class=\"line\">\t\tbeanFactory.autowireBean(job);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> job;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>// TODO Posting spring은 어떻게 bean관리를 하는가</p>\n<h2><span id=\"quartz-실행-화면\">Quartz 실행 화면</span></h2>\n<img src=\"/2018/12/05/ETC/[quartz]%20실시간%20배치%20동적%20스케줄러%20사용기/post-quartz-clustering-mode-log.png\">  \n<p>quartz 셋팅을 마치고 was를 기동하면 위 로그와 같이 quartz 버전, 클러스터 모드 on/off 여부, Thread pool 갯수 등 정보가 나온다.<br>\ncluster mode가 제대로 동작한다면 노란색 박스 로그와 같이 설정한 check interval time에 맞게 로그가 계속 찍힐 것이다.<br>\n다른 서버가 살아있는지 계속 체크하고 있는 것이다. (로그를 볼때는 debug 레벨로 해야 보임)</p>\n<h2><span id=\"그-밖의\">그 밖의</span></h2>\n<h3><span id=\"disallowconcurrentexecution\">@DisallowConcurrentExecution</span></h3>\n<p>Thread Pool 기반으로 동작하는 Quatrz에서 Job에 대한 Thread 동시 접근으로 인해 데이터 중복을 방지하기 위한 어노테이션 인거 같다.<br>\n나는 동시접근 못하게 코드로 막았는데 이런게 있는줄 알았으면 쉽게 해결했을거 같다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>어떤 시스템인가</h1>\n<ul>\n<li>DB 접속하여 데이터를 실시간 주기로 데이터를 targetDB에 적재하는 스케줄러 배치 모듈</li>\n<li>서버 중단 없이 스케줄 주기 동적 변경</li>\n<li>서버 중단 없이 이관 DB 추가 하여 스케줄 배치 수행</li>\n<li>이관해야 하는 DB 접속수가 늘어나도 각각 스케쥴 배치 수행</li>\n<li>기본적 서버 이중화 이지만 서버가 늘어나도 서버별 스케줄 배치 수행 (서버 클러스터링)</li>\n<li>한쪽 서버가 죽어도 나머지 서버가 죽은 서버의 스케줄 배치 까지 수행</li>\n</ul>\n<h1>왜 Quartz를 사용 하였는가</h1>\n<img src=\"/2018/12/05/ETC/[quartz]%20실시간%20배치%20동적%20스케줄러%20사용기/post_clustering.jpg\">  \n<ul>\n<li>서버 클러스터링을 사용하기 위해</li>\n<li>서버 클러스터링이 필요한 이유는 만들고자 하는 배치 스케줄 모듈이 시간이 지날수록 이관해야 하는 DB가 늘어나는 만큼 서버 부하를 분산시키기 위해</li>\n</ul>\n<h2>quartz clsutering 동작 과정</h2>\n<p>아래 표는 실제 서버를 각각 shutdown 시켜가면서 quartz clustering 동작을 눈으로 확인한 과정을 적은 것이다.</p>\n<img src=\"/2018/12/05/ETC/[quartz]%20실시간%20배치%20동적%20스케줄러%20사용기/post-quartz-clustering-mode-example.png\">  \n<h2>그럼 도대체 clustering 기능은 어떻게 사용한단 말인가</h2>\n<ul>\n<li>quartz 테이블 생성 <a href=\"https://goo.gl/HyRE2Q\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">[생성 스크립트 이동]</a></li>\n<li>quartz instance property 설정</li>\n<li>quartz jobStore property 설정  (property 설정 방법은 아래 quartz 설정 방법 부분 참고)</li>\n</ul>\n<p>Quartz instance property 에 대한 공식 설명을 먼저 보자</p>\n<blockquote>\n<p>org.quartz.scheduler.instanceName<br>\nCan be any string, and the value has no meaning to the scheduler itself - but rather serves as a mechanism for client code to distinguish schedulers when multiple instances are used within the same program. If you are using the clustering features, you must use the same name for every instance in the cluster that is ‘logically’ the same Scheduler.</p>\n</blockquote>\n<blockquote>\n<p>org.quartz.scheduler.instanceId<br>\nCan be any string, but must be unique for all schedulers working as if they are the same ‘logical’ Scheduler within a cluster. You may use the value “AUTO” as the instanceId if you wish the Id to be generated for you. Or the value “SYS_PROP” if you want the value to come from the system property “org.quartz.scheduler.instanceId”.</p>\n</blockquote>\n<p>정리하면 cluster mode를 사용하려면 같은 instanceName을 가진 서버별 고유에 instanceId를 가져야 cluster mode를 이용 할 수 있다는 뜻이다.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// scheduler identity</span><br><span class=\"line\">org.quartz.scheduler.instanceName = QUAARTZ-SCHEDULER</span><br><span class=\"line\">org.quartz.scheduler.instanceId = MASTER</span><br><span class=\"line\"></span><br><span class=\"line\">// cluster 관련 설정</span><br><span class=\"line\">org.quartz.jobStore.misfireThreshold = 60000</span><br><span class=\"line\">org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTX</span><br><span class=\"line\">org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.MSSQLDelegate</span><br><span class=\"line\">org.quartz.jobStore.dataSource = myDS</span><br><span class=\"line\">org.quartz.jobStore.tablePrefix = QRTZ_</span><br><span class=\"line\">org.quartz.jobStore.isClustered = true</span><br><span class=\"line\">org.quartz.jobStore.clusterCheckinInterval = 1000</span><br></pre></td></tr></table></figure>\n<p>그 밖의 quartz config 설정은 <a href=\"https://goo.gl/jXEZfS\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">quartz 레퍼런스 문서</a>를 보는게 제일 정확하므로 참고하여 설정하면 된다.</p>\n<h1>Quartz 셋팅</h1>\n<h2>프로젝트 환경 및 버전</h2>\n<p>Java8 + Spring 3.1.1 + Quartz 2.2.1 + Maven</p>\n<h2>Spring 4 일 경우는 아래 추가로 dependency 해주어야 한다.</h2>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context-support<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.0.0.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>해주지 않으면  org.springframework.scheduling.quartz 패키지가 존재 하지 않는다. (Spring 3은 spring-context-support dependency 안해줘도 됨)</p>\n<h2>Quartz Spring Bean 등록</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SchedulerFactoryBean <span class=\"title\">quartzScheduler</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\tschedulerFactoryBean = <span class=\"keyword\">new</span> SchedulerFactoryBean();</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tschedulerFactoryBean.setSchedulerName(<span class=\"string\">\"name\"</span>);</span><br><span class=\"line\">\tAutowiringSpringBeanJobFactory jobFactory = <span class=\"keyword\">new</span> AutowiringSpringBeanJobFactory();</span><br><span class=\"line\">\tjobFactory.setApplicationContext(applicationContext);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tschedulerFactoryBean.setJobFactory(jobFactory);</span><br><span class=\"line\">\tschedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\tschedulerFactoryBean.setOverwriteExistingJobs(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\tschedulerFactoryBean.setAutoStartup(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">\tschedulerFactoryBean.setQuartzProperties(quartzProperties());</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> schedulerFactoryBean;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2>객체 설명</h2>\n<h3>SchedulerFactoryBean 객체 (org.springframework.scheduling.quartz)</h3>\n<p>Spring Framework에서 Quartz를 bean으로 관리하기 위해 필요한 클래스로 Spring에서 Quartz를 사용하기 위해 필요함</p>\n<h3>AutowiringSpringBeanJobFactory 객체</h3>\n<p>org.quartz.Job 을 implements한 Job 클래스내에서 @Autowired 할 수 있도록 하기 위해서 사용함</p>\n<h2>왜 필요한가</h2>\n<p>구현한 Job 클래스에서 주입 받아야 하는 경우가 반드시 존재 하기 때문이다.<br>\n예를 들면 DAO 클래스 이다. 필자 같은 경우는 데이터를 DB INSERT 해야하는 경우로 Job 클래스에 DAO를 반드시 주입받아야 하기에 반드시 필요했다.<br>\n만약 객체를 생성하지 않으면 @Autowired 해도 객체가 null 이다.</p>\n<h2>그럼 왜 AutowiringSpringBeanJobFactory 객체 생성해야 @Autowired 할 수 있었을까??</h2>\n<p>해당 내용은 Spring Container 어떻게 Bean을 관리하는지에 대한 개념을 알아야 이해 할 수 있으며 해당 개념을 필자도 알고 싶어서 조사해 봤다.<br>\n그냥 추가해야 된다는 것만 알고 넘어 가고 싶다면 다음 주제로 넘어가면 되고 Spring이 bean 관리 메커니즘에 대해 궁금 하다면 아래를 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.quartz.spi.TriggerFiredBundle;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeansException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.config.AutowireCapableBeanFactory;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContext;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.ApplicationContextAware;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.scheduling.quartz.SpringBeanJobFactory;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AutowiringSpringBeanJobFactory</span> <span class=\"keyword\">extends</span> <span class=\"title\">SpringBeanJobFactory</span> <span class=\"keyword\">implements</span> <span class=\"title\">ApplicationContextAware</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> AutowireCapableBeanFactory beanFactory;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setApplicationContext</span><span class=\"params\">(ApplicationContext applicationContext)</span> <span class=\"keyword\">throws</span> BeansException </span>&#123;</span><br><span class=\"line\">\t\tbeanFactory = applicationContext.getAutowireCapableBeanFactory();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">createJobInstance</span><span class=\"params\">(TriggerFiredBundle bundle)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">final</span> Object job = <span class=\"keyword\">super</span>.createJobInstance(bundle);</span><br><span class=\"line\">\t\tbeanFactory.autowireBean(job);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> job;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>// TODO Posting spring은 어떻게 bean관리를 하는가</p>\n<h2>Quartz 실행 화면</h2>\n<img src=\"/2018/12/05/ETC/[quartz]%20실시간%20배치%20동적%20스케줄러%20사용기/post-quartz-clustering-mode-log.png\">  \n<p>quartz 셋팅을 마치고 was를 기동하면 위 로그와 같이 quartz 버전, 클러스터 모드 on/off 여부, Thread pool 갯수 등 정보가 나온다.<br>\ncluster mode가 제대로 동작한다면 노란색 박스 로그와 같이 설정한 check interval time에 맞게 로그가 계속 찍힐 것이다.<br>\n다른 서버가 살아있는지 계속 체크하고 있는 것이다. (로그를 볼때는 debug 레벨로 해야 보임)</p>\n<h2>그 밖의</h2>\n<h3>@DisallowConcurrentExecution</h3>\n<p>Thread Pool 기반으로 동작하는 Quatrz에서 Job에 대한 Thread 동시 접근으로 인해 데이터 중복을 방지하기 위한 어노테이션 인거 같다.<br>\n나는 동시접근 못하게 코드로 막았는데 이런게 있는줄 알았으면 쉽게 해결했을거 같다.</p>\n"},{"title":"옵저버 패턴, 도대체 왜 쓰는거야? - 기본 이론편","catalog":true,"date":"2019-04-17T14:25:05.000Z","subtitle":"옵저버 패턴 파헤치기","header-img":"bg_computer.jpg","catagories":["Design Patterns"],"_content":"\n### 옵저버 패턴이란?\n> 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정희 - 헤드퍼스트 참고\n\n\n### 언제 사용할까?\n\n\n**내가 만든 예제 (구독자에게 미세먼지 전달 하기)**\n{% asset_img \"observer.png\" %}  \n\nPublisher, Observer 가 핵심이다. 각 역활은 아래와 같다.\n\n### Observer\n~~~ java\npublic interface Observer {\n\tpublic void update(String desertLevel, String desertValue);\n}\n~~~\n이 인터페이스를 구현한(구독한) 구현클래스는 데이터 갱신, 이벤트가 발생하면 update 메소드를 통해 데이터를 받게 된다.  \n다시 말해 Observer 인터페이스를 구현해야 구독받을수 있다.\n\n\n### Publisher\n~~~ java\npublic interface Publisher {\n\tpublic void registerObserver(Observer o);\n\tpublic void removeObserver(Observer o);\n\tpublic void notifyObserver();\n}\n~~~\n\nObserver를 구현한 구현 클래스에 대한 등록, 삭제, 통지 기능을 명세하기 위해 필요하다.\n\n\n\n\n### 제공 관리자(Publisher)\n\nPublisher 인터페이스를 통해 등록, 삭제, 통지 기능을 구현하는 구현 클래스이다.  \n인터페이스를 구현하는 것이므로 다양한 비지니스 로직을 넣을 수 있고 실질적으로 클라이언트가 사용하는 클래스이다.\n\n~~~ java\npublic class NewsManager implements Publisher {\n\n\tprivate ArrayList<Observer> observers;\n\tprivate String desertLevel;\n\tprivate String desertValue;\n\t\n\tpublic NewsManager() {\n\t\tthis.observers = new ArrayList<>();\n\t}\n\t\n\t@Override\n\tpublic void registerObserver(Observer o) {\n\t\tobservers.add(o);\n\t}\n\n\t@Override\n\tpublic void removeObserver(Observer o) {\n\t\tint index = observers.indexOf(o);\n\t\tif(index >= 0) {\n\t\t\tSystem.out.println(\"구독취소\");\n\t\t\tobservers.remove(index);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void notifyObserver() {\n\t\tfor (Observer observer : observers) {\n\t\t\tobserver.update(desertLevel, desertValue);\n\t\t}\n\t}\n\t\n\tpublic void setNewsInfo(String desertLevel, String desertValue) {\n\t\tthis.desertLevel = desertLevel;\n\t\tthis.desertValue = desertValue;\n\t\tthis.notifyObserver();\n\t}\n}\n~~~\n\n### 구독자 (Subscriber)\n말그데로 구독이다. 특정 이벤트가 발생 할 때 데이터를 받을 수 있다.\n\n\n~~~ java\npublic class Person1Subscriber implements Observer{\n\n\tprivate String desertContents;\n\tprivate Publisher publisher;\n\t\n\tpublic Person1Subscriber(Publisher publisher) {\n\t\tthis.publisher = publisher;\n\t\tpublisher.registerObserver(this);\n\t}\n\t\n\t@Override\n\tpublic void update(String desertLevel, String desertValue) {\n\t\tthis.desertContents = \"오늘의 미세먼지 레벨: \" + desertLevel + \" | 미세먼지 농도: \" + desertValue;\n\t\tdisplay();\n\t}\n\t\n\tpublic void display() {\n\t\tSystem.out.println(\"Person1 구독자님 \" + desertContents + \" 입니다.\");\n\t}\n}\n\n~~~\n\n### 실행\n\n~~~ java\npublic static void main(String[] args) {\n    NewsManager newsManager = new NewsManager();\n    \n\t// 구독신청\n\tPerson1Subscriber p1 = new Person1Subscriber(newsManager);\n    Person2Subscriber p2 = new Person2Subscriber(newsManager);\n    Person3Subscriber p3 = new Person3Subscriber(newsManager);\n    \n\t// 데이터 통지\n    newsManager.setNewsInfo(\"최악\", \"200\");\n    newsManager.setNewsInfo(\"맑음\", \"0.5\");\n    \n\t// 특정 구독자 해지\n    newsManager.removeObserver(p2);\n    \n\t// 데이터 통지\n    newsManager.setNewsInfo(\"보통\", \"50\");\n}\n~~~ \n\n{% asset_img \"observer-result.png\" %}","source":"_posts/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편.md","raw":"---\ntitle: 옵저버 패턴, 도대체 왜 쓰는거야? - 기본 이론편\ncatalog: true\ndate: 2019-04-17 23:25:05\nsubtitle: 옵저버 패턴 파헤치기\nheader-img: \"bg_computer.jpg\"\ntags:\n- Design Patterns\ncatagories:\n- Design Patterns\n---\n\n### 옵저버 패턴이란?\n> 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정희 - 헤드퍼스트 참고\n\n\n### 언제 사용할까?\n\n\n**내가 만든 예제 (구독자에게 미세먼지 전달 하기)**\n{% asset_img \"observer.png\" %}  \n\nPublisher, Observer 가 핵심이다. 각 역활은 아래와 같다.\n\n### Observer\n~~~ java\npublic interface Observer {\n\tpublic void update(String desertLevel, String desertValue);\n}\n~~~\n이 인터페이스를 구현한(구독한) 구현클래스는 데이터 갱신, 이벤트가 발생하면 update 메소드를 통해 데이터를 받게 된다.  \n다시 말해 Observer 인터페이스를 구현해야 구독받을수 있다.\n\n\n### Publisher\n~~~ java\npublic interface Publisher {\n\tpublic void registerObserver(Observer o);\n\tpublic void removeObserver(Observer o);\n\tpublic void notifyObserver();\n}\n~~~\n\nObserver를 구현한 구현 클래스에 대한 등록, 삭제, 통지 기능을 명세하기 위해 필요하다.\n\n\n\n\n### 제공 관리자(Publisher)\n\nPublisher 인터페이스를 통해 등록, 삭제, 통지 기능을 구현하는 구현 클래스이다.  \n인터페이스를 구현하는 것이므로 다양한 비지니스 로직을 넣을 수 있고 실질적으로 클라이언트가 사용하는 클래스이다.\n\n~~~ java\npublic class NewsManager implements Publisher {\n\n\tprivate ArrayList<Observer> observers;\n\tprivate String desertLevel;\n\tprivate String desertValue;\n\t\n\tpublic NewsManager() {\n\t\tthis.observers = new ArrayList<>();\n\t}\n\t\n\t@Override\n\tpublic void registerObserver(Observer o) {\n\t\tobservers.add(o);\n\t}\n\n\t@Override\n\tpublic void removeObserver(Observer o) {\n\t\tint index = observers.indexOf(o);\n\t\tif(index >= 0) {\n\t\t\tSystem.out.println(\"구독취소\");\n\t\t\tobservers.remove(index);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void notifyObserver() {\n\t\tfor (Observer observer : observers) {\n\t\t\tobserver.update(desertLevel, desertValue);\n\t\t}\n\t}\n\t\n\tpublic void setNewsInfo(String desertLevel, String desertValue) {\n\t\tthis.desertLevel = desertLevel;\n\t\tthis.desertValue = desertValue;\n\t\tthis.notifyObserver();\n\t}\n}\n~~~\n\n### 구독자 (Subscriber)\n말그데로 구독이다. 특정 이벤트가 발생 할 때 데이터를 받을 수 있다.\n\n\n~~~ java\npublic class Person1Subscriber implements Observer{\n\n\tprivate String desertContents;\n\tprivate Publisher publisher;\n\t\n\tpublic Person1Subscriber(Publisher publisher) {\n\t\tthis.publisher = publisher;\n\t\tpublisher.registerObserver(this);\n\t}\n\t\n\t@Override\n\tpublic void update(String desertLevel, String desertValue) {\n\t\tthis.desertContents = \"오늘의 미세먼지 레벨: \" + desertLevel + \" | 미세먼지 농도: \" + desertValue;\n\t\tdisplay();\n\t}\n\t\n\tpublic void display() {\n\t\tSystem.out.println(\"Person1 구독자님 \" + desertContents + \" 입니다.\");\n\t}\n}\n\n~~~\n\n### 실행\n\n~~~ java\npublic static void main(String[] args) {\n    NewsManager newsManager = new NewsManager();\n    \n\t// 구독신청\n\tPerson1Subscriber p1 = new Person1Subscriber(newsManager);\n    Person2Subscriber p2 = new Person2Subscriber(newsManager);\n    Person3Subscriber p3 = new Person3Subscriber(newsManager);\n    \n\t// 데이터 통지\n    newsManager.setNewsInfo(\"최악\", \"200\");\n    newsManager.setNewsInfo(\"맑음\", \"0.5\");\n    \n\t// 특정 구독자 해지\n    newsManager.removeObserver(p2);\n    \n\t// 데이터 통지\n    newsManager.setNewsInfo(\"보통\", \"50\");\n}\n~~~ \n\n{% asset_img \"observer-result.png\" %}","slug":"Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편","published":1,"updated":"2019-07-10T14:42:50.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids07000jk0ott3uryz5b","content":"<h3><span id=\"옵저버-패턴이란\">옵저버 패턴이란?</span></h3>\n<blockquote>\n<p>한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정희 - 헤드퍼스트 참고</p>\n</blockquote>\n<h3><span id=\"언제-사용할까\">언제 사용할까?</span></h3>\n<p><strong>내가 만든 예제 (구독자에게 미세먼지 전달 하기)</strong></p>\n<img src=\"/2019/04/17/Design%20Patterns/[Design%20Patterns]%20옵저버%20패턴,%20도대체%20왜%20쓰는거야-기본%20이론편/observer.png\">  \n<p>Publisher, Observer 가 핵심이다. 각 역활은 아래와 같다.</p>\n<h3><span id=\"observer\">Observer</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(String desertLevel, String desertValue)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이 인터페이스를 구현한(구독한) 구현클래스는 데이터 갱신, 이벤트가 발생하면 update 메소드를 통해 데이터를 받게 된다.<br>\n다시 말해 Observer 인터페이스를 구현해야 구독받을수 있다.</p>\n<h3><span id=\"publisher\">Publisher</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Publisher</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer o)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer o)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObserver</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Observer를 구현한 구현 클래스에 대한 등록, 삭제, 통지 기능을 명세하기 위해 필요하다.</p>\n<h3><span id=\"제공-관리자publisher\">제공 관리자(Publisher)</span></h3>\n<p>Publisher 인터페이스를 통해 등록, 삭제, 통지 기능을 구현하는 구현 클래스이다.<br>\n인터페이스를 구현하는 것이므로 다양한 비지니스 로직을 넣을 수 있고 실질적으로 클라이언트가 사용하는 클래스이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewsManager</span> <span class=\"keyword\">implements</span> <span class=\"title\">Publisher</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String desertLevel;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String desertValue;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewsManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.observers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">\t\tobservers.add(o);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> index = observers.indexOf(o);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"구독취소\"</span>);</span><br><span class=\"line\">\t\t\tobservers.remove(index);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Observer observer : observers) &#123;</span><br><span class=\"line\">\t\t\tobserver.update(desertLevel, desertValue);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNewsInfo</span><span class=\"params\">(String desertLevel, String desertValue)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.desertLevel = desertLevel;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.desertValue = desertValue;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.notifyObserver();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"구독자-subscriber\">구독자 (Subscriber)</span></h3>\n<p>말그데로 구독이다. 특정 이벤트가 발생 할 때 데이터를 받을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person1Subscriber</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String desertContents;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Publisher publisher;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person1Subscriber</span><span class=\"params\">(Publisher publisher)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.publisher = publisher;</span><br><span class=\"line\">\t\tpublisher.registerObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(String desertLevel, String desertValue)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.desertContents = <span class=\"string\">\"오늘의 미세먼지 레벨: \"</span> + desertLevel + <span class=\"string\">\" | 미세먼지 농도: \"</span> + desertValue;</span><br><span class=\"line\">\t\tdisplay();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"Person1 구독자님 \"</span> + desertContents + <span class=\"string\">\" 입니다.\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"실행\">실행</span></h3>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n    NewsManager newsManager = new NewsManager();\n    \n\t// 구독신청\n\tPerson1Subscriber p1 = new Person1Subscriber(newsManager);\n    Person2Subscriber p2 = new Person2Subscriber(newsManager);\n    Person3Subscriber p3 = new Person3Subscriber(newsManager);\n    \n\t// 데이터 통지\n    newsManager.setNewsInfo(&quot;최악&quot;, &quot;200&quot;);\n    newsManager.setNewsInfo(&quot;맑음&quot;, &quot;0.5&quot;);\n    \n\t// 특정 구독자 해지\n    newsManager.removeObserver(p2);\n    \n\t// 데이터 통지\n    newsManager.setNewsInfo(&quot;보통&quot;, &quot;50&quot;);\n}\n</code></pre>\n<img src=\"/2019/04/17/Design%20Patterns/[Design%20Patterns]%20옵저버%20패턴,%20도대체%20왜%20쓰는거야-기본%20이론편/observer-result.png\">","site":{"data":{}},"excerpt":"","more":"<h3>옵저버 패턴이란?</h3>\n<blockquote>\n<p>한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정희 - 헤드퍼스트 참고</p>\n</blockquote>\n<h3>언제 사용할까?</h3>\n<p><strong>내가 만든 예제 (구독자에게 미세먼지 전달 하기)</strong></p>\n<img src=\"/2019/04/17/Design%20Patterns/[Design%20Patterns]%20옵저버%20패턴,%20도대체%20왜%20쓰는거야-기본%20이론편/observer.png\">  \n<p>Publisher, Observer 가 핵심이다. 각 역활은 아래와 같다.</p>\n<h3>Observer</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Observer</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(String desertLevel, String desertValue)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이 인터페이스를 구현한(구독한) 구현클래스는 데이터 갱신, 이벤트가 발생하면 update 메소드를 통해 데이터를 받게 된다.<br>\n다시 말해 Observer 인터페이스를 구현해야 구독받을수 있다.</p>\n<h3>Publisher</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Publisher</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer o)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer o)</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObserver</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Observer를 구현한 구현 클래스에 대한 등록, 삭제, 통지 기능을 명세하기 위해 필요하다.</p>\n<h3>제공 관리자(Publisher)</h3>\n<p>Publisher 인터페이스를 통해 등록, 삭제, 통지 기능을 구현하는 구현 클래스이다.<br>\n인터페이스를 구현하는 것이므로 다양한 비지니스 로직을 넣을 수 있고 실질적으로 클라이언트가 사용하는 클래스이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NewsManager</span> <span class=\"keyword\">implements</span> <span class=\"title\">Publisher</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String desertLevel;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String desertValue;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NewsManager</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.observers = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">\t\tobservers.add(o);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">removeObserver</span><span class=\"params\">(Observer o)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> index = observers.indexOf(o);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(index &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"구독취소\"</span>);</span><br><span class=\"line\">\t\t\tobservers.remove(index);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">notifyObserver</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Observer observer : observers) &#123;</span><br><span class=\"line\">\t\t\tobserver.update(desertLevel, desertValue);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setNewsInfo</span><span class=\"params\">(String desertLevel, String desertValue)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.desertLevel = desertLevel;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.desertValue = desertValue;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.notifyObserver();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>구독자 (Subscriber)</h3>\n<p>말그데로 구독이다. 특정 이벤트가 발생 할 때 데이터를 받을 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person1Subscriber</span> <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String desertContents;</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Publisher publisher;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Person1Subscriber</span><span class=\"params\">(Publisher publisher)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.publisher = publisher;</span><br><span class=\"line\">\t\tpublisher.registerObserver(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(String desertLevel, String desertValue)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">this</span>.desertContents = <span class=\"string\">\"오늘의 미세먼지 레벨: \"</span> + desertLevel + <span class=\"string\">\" | 미세먼지 농도: \"</span> + desertValue;</span><br><span class=\"line\">\t\tdisplay();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"Person1 구독자님 \"</span> + desertContents + <span class=\"string\">\" 입니다.\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>실행</h3>\n<pre><code class=\"language-java\">public static void main(String[] args) {\n    NewsManager newsManager = new NewsManager();\n    \n\t// 구독신청\n\tPerson1Subscriber p1 = new Person1Subscriber(newsManager);\n    Person2Subscriber p2 = new Person2Subscriber(newsManager);\n    Person3Subscriber p3 = new Person3Subscriber(newsManager);\n    \n\t// 데이터 통지\n    newsManager.setNewsInfo(&quot;최악&quot;, &quot;200&quot;);\n    newsManager.setNewsInfo(&quot;맑음&quot;, &quot;0.5&quot;);\n    \n\t// 특정 구독자 해지\n    newsManager.removeObserver(p2);\n    \n\t// 데이터 통지\n    newsManager.setNewsInfo(&quot;보통&quot;, &quot;50&quot;);\n}\n</code></pre>\n<img src=\"/2019/04/17/Design%20Patterns/[Design%20Patterns]%20옵저버%20패턴,%20도대체%20왜%20쓰는거야-기본%20이론편/observer-result.png\">"},{"title":"팩토리 패턴, 도대체 왜 쓰는거야? - 기본 이론편","catalog":true,"date":"2019-06-28T14:01:05.000Z","subtitle":"속 시원히 알게 되는 팩토리 패턴 개념","header-img":"bg_computer.jpg","catagories":["Design Patterns"],"_content":"\n### 결론부터 말하자면..\n객체 생성 하는 코드를 분리하여 클라이언트 코드와 결합도(의존성)를 낮추어 코드를 건드리는 횟수를 최소화 하기 위한 패턴이다.   \n\n자, 용어부터 이해하자 그래야 전체적으로 이해가 되니까  \n\n여기서 클라이언트 코드는 분리시킨 객체 생성 코드를 호출하는 쪽을 말한다.\n\n#### 결합도는 왜 낮아 지는가?  \n그것은 객체지향 성질중에 하나인 다형성을 이용 하였기 때문이다.  인터페이스를 구현한 객체들은 같은 인터페이스를 바라 보기 때문에 코드에 유연함이 있기 때문이다.\n\n#### 왜 코드를 건드리는 횟수가 최소화 될까?  \n객체를 생성하는 코드 부분을 분리 시켰기 때문에 객체를 추가/수정이 일어 나더라도 객체를 생성하는 코드만 건들면 되기 때문이다.  \n\n일단, 객체를 생성하는 일은 구상클래스를 만드는 일인데 새로운 객체가 추가 될 수도 있고 삭제 될 수 있는 가능성이 상대적으로 많다.  \n또한 객체를 생성하는 코드가 여러 클래스내 에서도 사용 되면 예를 들어 10개의 클래스 내에서 객체를 생성하는 if ~ else if 구문이 있다고 했을때 객체 추가/수정이 발생하면 10개의 클래스에 코드를 변경해 줘야 하는 일이 발생한다.  \n\n바로 이러한 문제점을 해결하기 위해 팩토리 패턴을 사용하는 것이다. \n\n이외에도 팩토리 패턴에 유용함이 있는데 아래 코드를 보면서 설명하겠다. \n\n\n### 팩토리 패턴 이란?\n> 팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만들게 하는 패턴\n\n### 내가 정의하는 팩토리 패턴 이란?\n객체를 생성하는 코드를 추상화하여 코드를 한곳에서 관리하지 않으면, 변화(생성,수정,삭제)가 발생 했을 때 해당 클라이언트 코드를 전부 수정해줘야 한다.   \n즉, 객체지향 디자인패턴 원칙 확장에 대해서는 열려고있고 변화에 대해서는 닫혀있어야 한다.\n때문에 변화가 일어날 수 있는 객체 생성 담당하는 클래스를 만들어 한곳에서 관리하여 결합도를 줄이기 위해 사용하는 패턴이다.\n\n\n\n### Simple Factorty\n스프링에서 Bean을 DI하는 생성자 방식으로 IronManLab 클래스에게 팩토리 클래스를 주입하여 객체를 생성하는 부분과 아닌 부분을 분리하여 객체 생성 하는 코드에 변화가 있더라도 클라이언트는 변함이 없도록 하였다.\n\n\n~~~ java\npublic class IronManLab {\n    \n    SimpleIronManFactory factory;\n\n    public IronManLab (SimpleIronManFactory factory) {\n        this.factory = factory\n    }\n\n    public IronMan createIronMan(Enum ironManType) {\n\n        IronMan ironMan;\n        \n        /**\n         * 다형성을 이용해 결합도를 최소화 하였으며 객체를 생성하는 코드에 변경이 일어나도\n         * 바로 여기 클라이언트 코드는 변경이 일어나지 않는다.\n        **/\n        ironMan = factory.createIronMan(ironManType);\n\n        /**\n         * 변경되지 않는 부분 \n        **/\n        ironMan.준비();\n        ironMan.조립();\n        ironMan.자비스설치();\n        ironMan.전원ON();\n\n        return ironMan;\n\n    }\n}\n~~~\n\n~~~ java\npublic class SimpleIronManFactory {\n\n    public IronMan createIronMan(IronManType ironManType) {\n        IronMan ironMan = null;\n\n        /**\n        자주 변경되는 코드 그래서 분리 함\n        **/\n        if(ironManType.equals(IronManType.Battle)) {\n            ironMan = new BattleIronMan();\n        } else if(ironManType.equals(IronManType.Nano)) {\n            ironMan = new NanoIronMan();\n        }\n        return ironMan;\n    }\n}\n~~~\n\n~~~ java\npublic abstract class IronMan {\n\n    String ironManName;\n\n    public void 부품준비() {\n        System.out.println(ironManName + \"의 머리를 가져옵니다.\");\n        System.out.println(ironManName + \"의 몸통을 가져옵니다.\");\n        System.out.println(ironManName + \"의 다리를 가져옵니다.\");\n        System.out.println(ironManName + \"의 팔을 가져옵니다.\");\n    }\n\n    public void 조립() {\n        System.out.println(ironManName + \"의 몸통과 다리를 조립합니다.\");\n        System.out.println(ironManName + \"의 몸통과 팔을 조립합니다.\");\n        System.out.println(ironManName + \"의 몸통과 머리를 조립합니다.\");\n    }\n\n    public void 자비스삽입() {\n        System.out.println(\"자비스 소프트웨어를 설치하였습니다.\");\n    }\n\n    public void 전원On() {\n        System.out.println(\"전원 ON 하였습니다.\");\n        System.out.println(ironManName + \"이 눈을 떴습니다!!\");\n    }\n}\n~~~\n\n~~~ java\npublic class BattleIronMan extends IronMan {\n    \n    public BattleIronMan() {\n        ironManName = \"BattleIronMan\";\n    }\n}\n~~~\n\n~~~ java\npublic class NanoIronMan extends IronMan {\n    \n    public NanoIronMan() {\n        ironManName = \"NanoIronMan\";\n    }\n}\n~~~\n\n\n### Simple Factory Pattern 에 한계\n\n무슨 한계 일까?? 아래 상황을 잘 보자  \n아이언맨이 불티나게 잘 팔리자 여러 나라에서 아이언맨을 사겠다고 난리이다.  사겠다고 한 나라들은 대한민국, 필리핀, 뉴질랜드 였다. 문제는 각 나라별로 요구사항이 조금씩 차이가 있는 것이다.  \n\n- 대한민국 : 미사일이 많이 장착된 아이언맨\n- 가나     : 총이 많이 장착된 아이언맨\n\n좀 억지스러운게 있지만 이해를 위해 비유를 위와 같이 들었다.  토니 스타크는 미국 본사에서 일을 해야 하므로 각 나라에 대표자들을 뽑고 각 입맛에 맞는 아이언맨 공장을 세우고 아이언맨을 생산하게 하였다.  \n\n그러면 Simpel Factory Pattern데로 아이언맨을 생산해 보자\n\n~~~ java\nKoreaIronManFactory koreaIronManFactory = new KoreaIronManFactory();\nIronManLab ironManLab = new IronManLab(koreaIronManFactory);\nironManLab.createIronMan(\"Battle\");\n\nGanaIronManFactory ganaIronManFactory = new KoreaIronManFactory();\nIronManLab ironManLab = new IronManLab(ganaIronManFactory);\nironManLab.createIronMan(\"Battle\");\n~~~ \n\n여기서부터가 문제가 발생한다.  \n\n일단, 토니스타크가 정의한 아이언맨을 제조하는 과정은\n> 준비 > 조립 > 자비스 설치 > 전원 ON 이었다.  \n\n근데, 대한민국 에서는 \n> 조립 > 자비스 설치 > 전원 ON   \n\n\n~~~ java\npublic IronMan createIronMan(Enum ironManType) {\n\n        IronMan ironMan;\n        ironMan = factory.createIronMan(ironManType);\n\n        //ironMan.준비();       // 빼먹었다!!!!!\n        ironMan.조립();\n        ironMan.자비스설치();\n        ironMan.전원ON();\n\n        return ironMan;        \n    }\n~~~\n\n\n준비 과정을 빼먹어서 조립이 잘 안되고 되더라도 움직이는 오류가 발생 하였고  \n\n가나 에서는 \n> 준비 > 조립 > 조비스 설치 > 전원 ON  \n\n~~~ java\npublic IronMan createIronMan(Enum ironManType) {\n\n        IronMan ironMan;\n        ironMan = factory.createIronMan(ironManType);\n\n        ironMan.준비();\n        ironMan.조립();\n        ironMan.조비스설치();       // 엥??? 이상한 소프트웨어를 붙이네???\n        ironMan.전원ON();\n\n        return ironMan;        \n    }\n\n~~~\n\n\n자비스가 아닌 가나 독자적으로 개발한 조비스를 설치하여 제어에 문제가 생긴것이다.  \n\n즉, 토니스타크가 정의한 아이언맨 제조 방식을 누락/수정이 발생하여 일관되게 아이언맨을 생성할 수가 없게 된것이다.  각 아이언맨에 성격은 여러가지 일 수 있으나 아이언맨을 생산하는 공정 과정은 똑같아야 하기 때문에 그 공정과정을 강제 시키는 과정이 필요 한 것이다.  \n\n\n### 그럼 어떻게 해야 할까?\n\n기존 IronManLab에 아이언맨 만드는 과정은 그데로 두고 각 나라에 맞는 IronManLab을 구현 할 수 있도록 한다. 다시 말해서 IronManLab를 추상 클래스로 만든다.\n\nSimple Factory Class인 IronManLab 수정한 클래스를 보자  \n\n~~~ java\npublic abstract class IronManLab {\n    \n    // SimpleIronManFactory factory;\n\n    /**\n     * 이 부분은 대한민국, 가나, 필리핀 각 입맛에 맞게 Factory 클래스를 만들수 있도록\n     * 추상메소드로 선언한다.\n     *\n     * public IronManLab (SimpleIronManFactory factory) {\n     *   this.factory = factory\n     * }\n    **/\n    abstract IronMan assembleIronMan(Enum ironManType);\n\n\n    public IronMan createIronMan(Enum ironManType) {\n\n        IronMan ironMan;\n        ironMan = factory.assembleIronMan(ironManType);\n\n        /**\n         * 이 부분은 변경 되지 않아야 한다.\n        **/\n        ironMan.준비();\n        ironMan.조립();\n        ironMan.자비스설치();\n        ironMan.전원ON();\n\n        return ironMan;\n    }\n}\n~~~\n\n그럼 대한민국, 가나에서 입맛에 맞는 아이언맨을 만들 Lab 클래스를 구현해보자\n\n~~~ java\npublic class KoreaIronManLab extends IronManLab {\n\n  /**\n   * 여기서는 구현만 담당하고 수퍼클래스에서는 아이언맨 일관된 제조를 담당한다.\n  **/  \n  public IronMan createIronMan(IronManType ironManType) {\n        IronMan ironMan = null;\n\n        if(ironManType.equals(IronManType.Battle)) {\n            ironMan = new KoreaBattleIronMan();\n        } else if(ironManType.equals(IronManType.Nano)) {\n            ironMan = new KoreaNanoIronMan();\n        }\n        return ironMan;\n    }\n}\n~~~\n\n~~~ java\npublic class KoreaBattleIronMan extends IronMan {\n    \n    public BattleIronMan() {\n        ironManName = \"한국형 전투용 아이언맨 입니다.\";\n        type = \"미사일을 많이 가지고 있습니다.\";\n    }\n}\n~~~\n\n\n~~~ java\npublic class GanaIronManLab extends IronManLab {\n\n  /**\n   * 여기서는 구현만 담당하고 수퍼클래스에서는 아이언맨 일관된 제조를 담당한다.\n  **/  \n  public IronMan createIronMan(IronManType ironManType) {\n        IronMan ironMan = null;\n\n        if(ironManType.equals(IronManType.Battle)) {\n            ironMan = new GanaHulkBattleIronMan();\n        } else if(ironManType.equals(IronManType.Nano)) {\n            ironMan = new GanaNanoIronMan();\n        }\n        return ironMan;\n    }\n}\n~~~\n\n~~~ java\npublic class GanaBattleIronMan extends IronMan {\n    \n    public BattleIronMan() {\n        ironManName = \"가나형 전투용 아이언맨 입니다.\";\n        type = \"총을 많이 가지고 있습니다.\";\n    }\n}\n~~~\n\n\n자 이제 직접 사용하는 클라이언트 코드를 만들어 보자 \n\n~~~ java\npublic static void main(String[] args) {\n    IronManLab koreaIronManLab = new KoreaIronManLab();\n    IronManLab ganaIronManLab = new GanaIronManLab();\n    \n    IronMan koreaIronMan = koreaIronManLab.createIronMan(IronManType.BATTLE);\n    IronMan ganaIronMan = ganaIronManLab.createIronMan(IronManType.BATTLE);    \n}\n~~~\n\n\n\n\n// TODO 추상팩토리\n\n\n\n\n\n\n\n\n### 팩토리 패턴에 장점은 무엇인가?\n{% asset_img \"simple-factory.png\" %}   \n팩토리 패턴에 대한 큰 그림이다. 왜 이런 패턴을 사용하는지 하나하나 따져 보겠다.  \n\n#### 여기저기 객체를 생성하는 곳이 산재해 있다. (수정 불편함)\n토니스타크가 여러 버전에 아이언맨을 설계해놨다. 그래서 클라이언트 1000명 에게 아이언맨 버전을 소개하는 소책자를 뿌렸다고 하자.\n어이쿠 근데 토니스타크가 이미 뿌린 아이언맨 버전중에 Mark-13에 오류가 생겨서 출시 안하기로 하고 Mark-16을 새로 만들어서 변경이 생겨버렸다.\n이미 1,000명에게 뿌린 소책자를 수정해야 한다. 즉, 1000번을 수정해야 하는것이다.\n\n이것을 객체를 생성하는 코드가 여기저기 산재해 있고 그코드가 빈번한 변경이 이루어졌을때 얼마나 코드를 여기저기 수정해야하는지 알겠는가?\n바로 이 문제를 해결하기 위해 만들어진 패턴이 팩토리 패턴이다.\n\n다시 말해, 객체지향 디자인 원칙 **변경이 일어나는 부분을 캡슐화** 하는 것이다.\n\n### 그럼 추상 팩토리 패턴은 뭐야?\n\n{% asset_img \"factory-pattern.png\" %}  \n\n토니스타크가 고민을 하기 시작했다. 기존 아이언맨 설계도 가지고 적들을 잘 상대해 왔었는데 **적들에 성격이 다양해 지면서 그에 맞는 아이언맨을 만들어야(Facotry) 하는것이다. 하지만 기존 설계도를 수정, 번복을 자꾸 하고 실수가 생겨 불량품이 나오는 것이다.**   \n해서 아이언맨을 만드는 공통 설계서(추상 팩토리)를 만들고 그 기반으로 각각에 유형에 맞는 아이언맨인 헐크버스터, 나도아이언맨 등 (구상 팩토리) 설계도를 방식을 생각한 것이다.\n\n~~~java\npublic abstract class IronManFactory {\n\n    public IronMan orderIronMan(Enum ironType) {\n        IronMan ironMan = createIronMan(type);\n        ironMan.linkRegs();\n        ironMan.linkArms();\n        ironMan.linkBody();\n        ironMan.linkHead();\n    }\n\n    // 각각에 맞는 헐크버스터, 나도아이언맨 팩토리르 메소드를 구현한다.\n    public abstract createIronMan(Enum ironType);\n}\n\npublic class Main {\n\n    public void main(String[] args) {\n        IronManFactory factory = new HulkIronManFactory();\n        IronMan hulkIronMan = factory.orderIroMan(BatchType.hulk);\n        ...\n    }\n}\n~~~\n\n이렇게 사용하는 이유는 \n**객체를 생성하는** 코드를 많이 사용하는데 **공통적인 부분은 있지만** 또 **성격에 따라 다른 유형에 객체를 생성하기 원할 때** 사용하는 패턴이다.  \n위와 같은 구조로 코드를 작성하게 되면 공통된 부분으로 **코드 중복을 줄일수 있고** 인터페이스(추상클래스, 인터페이스 등)를 구현하는 방식을 사용해 **다형성에 이점**을 가져 갈 수 있어 코드 수정없이 유연한 코드를 작성 할 수 있는 장점이 있어서 사용한다.","source":"_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편.md","raw":"---\ntitle: 팩토리 패턴, 도대체 왜 쓰는거야? - 기본 이론편\ncatalog: true\ndate: 2019-06-28 23:01:05\nsubtitle: 속 시원히 알게 되는 팩토리 패턴 개념\nheader-img: \"bg_computer.jpg\"\ntags:\n- Design Patterns\ncatagories:\n- Design Patterns\n---\n\n### 결론부터 말하자면..\n객체 생성 하는 코드를 분리하여 클라이언트 코드와 결합도(의존성)를 낮추어 코드를 건드리는 횟수를 최소화 하기 위한 패턴이다.   \n\n자, 용어부터 이해하자 그래야 전체적으로 이해가 되니까  \n\n여기서 클라이언트 코드는 분리시킨 객체 생성 코드를 호출하는 쪽을 말한다.\n\n#### 결합도는 왜 낮아 지는가?  \n그것은 객체지향 성질중에 하나인 다형성을 이용 하였기 때문이다.  인터페이스를 구현한 객체들은 같은 인터페이스를 바라 보기 때문에 코드에 유연함이 있기 때문이다.\n\n#### 왜 코드를 건드리는 횟수가 최소화 될까?  \n객체를 생성하는 코드 부분을 분리 시켰기 때문에 객체를 추가/수정이 일어 나더라도 객체를 생성하는 코드만 건들면 되기 때문이다.  \n\n일단, 객체를 생성하는 일은 구상클래스를 만드는 일인데 새로운 객체가 추가 될 수도 있고 삭제 될 수 있는 가능성이 상대적으로 많다.  \n또한 객체를 생성하는 코드가 여러 클래스내 에서도 사용 되면 예를 들어 10개의 클래스 내에서 객체를 생성하는 if ~ else if 구문이 있다고 했을때 객체 추가/수정이 발생하면 10개의 클래스에 코드를 변경해 줘야 하는 일이 발생한다.  \n\n바로 이러한 문제점을 해결하기 위해 팩토리 패턴을 사용하는 것이다. \n\n이외에도 팩토리 패턴에 유용함이 있는데 아래 코드를 보면서 설명하겠다. \n\n\n### 팩토리 패턴 이란?\n> 팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만들게 하는 패턴\n\n### 내가 정의하는 팩토리 패턴 이란?\n객체를 생성하는 코드를 추상화하여 코드를 한곳에서 관리하지 않으면, 변화(생성,수정,삭제)가 발생 했을 때 해당 클라이언트 코드를 전부 수정해줘야 한다.   \n즉, 객체지향 디자인패턴 원칙 확장에 대해서는 열려고있고 변화에 대해서는 닫혀있어야 한다.\n때문에 변화가 일어날 수 있는 객체 생성 담당하는 클래스를 만들어 한곳에서 관리하여 결합도를 줄이기 위해 사용하는 패턴이다.\n\n\n\n### Simple Factorty\n스프링에서 Bean을 DI하는 생성자 방식으로 IronManLab 클래스에게 팩토리 클래스를 주입하여 객체를 생성하는 부분과 아닌 부분을 분리하여 객체 생성 하는 코드에 변화가 있더라도 클라이언트는 변함이 없도록 하였다.\n\n\n~~~ java\npublic class IronManLab {\n    \n    SimpleIronManFactory factory;\n\n    public IronManLab (SimpleIronManFactory factory) {\n        this.factory = factory\n    }\n\n    public IronMan createIronMan(Enum ironManType) {\n\n        IronMan ironMan;\n        \n        /**\n         * 다형성을 이용해 결합도를 최소화 하였으며 객체를 생성하는 코드에 변경이 일어나도\n         * 바로 여기 클라이언트 코드는 변경이 일어나지 않는다.\n        **/\n        ironMan = factory.createIronMan(ironManType);\n\n        /**\n         * 변경되지 않는 부분 \n        **/\n        ironMan.준비();\n        ironMan.조립();\n        ironMan.자비스설치();\n        ironMan.전원ON();\n\n        return ironMan;\n\n    }\n}\n~~~\n\n~~~ java\npublic class SimpleIronManFactory {\n\n    public IronMan createIronMan(IronManType ironManType) {\n        IronMan ironMan = null;\n\n        /**\n        자주 변경되는 코드 그래서 분리 함\n        **/\n        if(ironManType.equals(IronManType.Battle)) {\n            ironMan = new BattleIronMan();\n        } else if(ironManType.equals(IronManType.Nano)) {\n            ironMan = new NanoIronMan();\n        }\n        return ironMan;\n    }\n}\n~~~\n\n~~~ java\npublic abstract class IronMan {\n\n    String ironManName;\n\n    public void 부품준비() {\n        System.out.println(ironManName + \"의 머리를 가져옵니다.\");\n        System.out.println(ironManName + \"의 몸통을 가져옵니다.\");\n        System.out.println(ironManName + \"의 다리를 가져옵니다.\");\n        System.out.println(ironManName + \"의 팔을 가져옵니다.\");\n    }\n\n    public void 조립() {\n        System.out.println(ironManName + \"의 몸통과 다리를 조립합니다.\");\n        System.out.println(ironManName + \"의 몸통과 팔을 조립합니다.\");\n        System.out.println(ironManName + \"의 몸통과 머리를 조립합니다.\");\n    }\n\n    public void 자비스삽입() {\n        System.out.println(\"자비스 소프트웨어를 설치하였습니다.\");\n    }\n\n    public void 전원On() {\n        System.out.println(\"전원 ON 하였습니다.\");\n        System.out.println(ironManName + \"이 눈을 떴습니다!!\");\n    }\n}\n~~~\n\n~~~ java\npublic class BattleIronMan extends IronMan {\n    \n    public BattleIronMan() {\n        ironManName = \"BattleIronMan\";\n    }\n}\n~~~\n\n~~~ java\npublic class NanoIronMan extends IronMan {\n    \n    public NanoIronMan() {\n        ironManName = \"NanoIronMan\";\n    }\n}\n~~~\n\n\n### Simple Factory Pattern 에 한계\n\n무슨 한계 일까?? 아래 상황을 잘 보자  \n아이언맨이 불티나게 잘 팔리자 여러 나라에서 아이언맨을 사겠다고 난리이다.  사겠다고 한 나라들은 대한민국, 필리핀, 뉴질랜드 였다. 문제는 각 나라별로 요구사항이 조금씩 차이가 있는 것이다.  \n\n- 대한민국 : 미사일이 많이 장착된 아이언맨\n- 가나     : 총이 많이 장착된 아이언맨\n\n좀 억지스러운게 있지만 이해를 위해 비유를 위와 같이 들었다.  토니 스타크는 미국 본사에서 일을 해야 하므로 각 나라에 대표자들을 뽑고 각 입맛에 맞는 아이언맨 공장을 세우고 아이언맨을 생산하게 하였다.  \n\n그러면 Simpel Factory Pattern데로 아이언맨을 생산해 보자\n\n~~~ java\nKoreaIronManFactory koreaIronManFactory = new KoreaIronManFactory();\nIronManLab ironManLab = new IronManLab(koreaIronManFactory);\nironManLab.createIronMan(\"Battle\");\n\nGanaIronManFactory ganaIronManFactory = new KoreaIronManFactory();\nIronManLab ironManLab = new IronManLab(ganaIronManFactory);\nironManLab.createIronMan(\"Battle\");\n~~~ \n\n여기서부터가 문제가 발생한다.  \n\n일단, 토니스타크가 정의한 아이언맨을 제조하는 과정은\n> 준비 > 조립 > 자비스 설치 > 전원 ON 이었다.  \n\n근데, 대한민국 에서는 \n> 조립 > 자비스 설치 > 전원 ON   \n\n\n~~~ java\npublic IronMan createIronMan(Enum ironManType) {\n\n        IronMan ironMan;\n        ironMan = factory.createIronMan(ironManType);\n\n        //ironMan.준비();       // 빼먹었다!!!!!\n        ironMan.조립();\n        ironMan.자비스설치();\n        ironMan.전원ON();\n\n        return ironMan;        \n    }\n~~~\n\n\n준비 과정을 빼먹어서 조립이 잘 안되고 되더라도 움직이는 오류가 발생 하였고  \n\n가나 에서는 \n> 준비 > 조립 > 조비스 설치 > 전원 ON  \n\n~~~ java\npublic IronMan createIronMan(Enum ironManType) {\n\n        IronMan ironMan;\n        ironMan = factory.createIronMan(ironManType);\n\n        ironMan.준비();\n        ironMan.조립();\n        ironMan.조비스설치();       // 엥??? 이상한 소프트웨어를 붙이네???\n        ironMan.전원ON();\n\n        return ironMan;        \n    }\n\n~~~\n\n\n자비스가 아닌 가나 독자적으로 개발한 조비스를 설치하여 제어에 문제가 생긴것이다.  \n\n즉, 토니스타크가 정의한 아이언맨 제조 방식을 누락/수정이 발생하여 일관되게 아이언맨을 생성할 수가 없게 된것이다.  각 아이언맨에 성격은 여러가지 일 수 있으나 아이언맨을 생산하는 공정 과정은 똑같아야 하기 때문에 그 공정과정을 강제 시키는 과정이 필요 한 것이다.  \n\n\n### 그럼 어떻게 해야 할까?\n\n기존 IronManLab에 아이언맨 만드는 과정은 그데로 두고 각 나라에 맞는 IronManLab을 구현 할 수 있도록 한다. 다시 말해서 IronManLab를 추상 클래스로 만든다.\n\nSimple Factory Class인 IronManLab 수정한 클래스를 보자  \n\n~~~ java\npublic abstract class IronManLab {\n    \n    // SimpleIronManFactory factory;\n\n    /**\n     * 이 부분은 대한민국, 가나, 필리핀 각 입맛에 맞게 Factory 클래스를 만들수 있도록\n     * 추상메소드로 선언한다.\n     *\n     * public IronManLab (SimpleIronManFactory factory) {\n     *   this.factory = factory\n     * }\n    **/\n    abstract IronMan assembleIronMan(Enum ironManType);\n\n\n    public IronMan createIronMan(Enum ironManType) {\n\n        IronMan ironMan;\n        ironMan = factory.assembleIronMan(ironManType);\n\n        /**\n         * 이 부분은 변경 되지 않아야 한다.\n        **/\n        ironMan.준비();\n        ironMan.조립();\n        ironMan.자비스설치();\n        ironMan.전원ON();\n\n        return ironMan;\n    }\n}\n~~~\n\n그럼 대한민국, 가나에서 입맛에 맞는 아이언맨을 만들 Lab 클래스를 구현해보자\n\n~~~ java\npublic class KoreaIronManLab extends IronManLab {\n\n  /**\n   * 여기서는 구현만 담당하고 수퍼클래스에서는 아이언맨 일관된 제조를 담당한다.\n  **/  \n  public IronMan createIronMan(IronManType ironManType) {\n        IronMan ironMan = null;\n\n        if(ironManType.equals(IronManType.Battle)) {\n            ironMan = new KoreaBattleIronMan();\n        } else if(ironManType.equals(IronManType.Nano)) {\n            ironMan = new KoreaNanoIronMan();\n        }\n        return ironMan;\n    }\n}\n~~~\n\n~~~ java\npublic class KoreaBattleIronMan extends IronMan {\n    \n    public BattleIronMan() {\n        ironManName = \"한국형 전투용 아이언맨 입니다.\";\n        type = \"미사일을 많이 가지고 있습니다.\";\n    }\n}\n~~~\n\n\n~~~ java\npublic class GanaIronManLab extends IronManLab {\n\n  /**\n   * 여기서는 구현만 담당하고 수퍼클래스에서는 아이언맨 일관된 제조를 담당한다.\n  **/  \n  public IronMan createIronMan(IronManType ironManType) {\n        IronMan ironMan = null;\n\n        if(ironManType.equals(IronManType.Battle)) {\n            ironMan = new GanaHulkBattleIronMan();\n        } else if(ironManType.equals(IronManType.Nano)) {\n            ironMan = new GanaNanoIronMan();\n        }\n        return ironMan;\n    }\n}\n~~~\n\n~~~ java\npublic class GanaBattleIronMan extends IronMan {\n    \n    public BattleIronMan() {\n        ironManName = \"가나형 전투용 아이언맨 입니다.\";\n        type = \"총을 많이 가지고 있습니다.\";\n    }\n}\n~~~\n\n\n자 이제 직접 사용하는 클라이언트 코드를 만들어 보자 \n\n~~~ java\npublic static void main(String[] args) {\n    IronManLab koreaIronManLab = new KoreaIronManLab();\n    IronManLab ganaIronManLab = new GanaIronManLab();\n    \n    IronMan koreaIronMan = koreaIronManLab.createIronMan(IronManType.BATTLE);\n    IronMan ganaIronMan = ganaIronManLab.createIronMan(IronManType.BATTLE);    \n}\n~~~\n\n\n\n\n// TODO 추상팩토리\n\n\n\n\n\n\n\n\n### 팩토리 패턴에 장점은 무엇인가?\n{% asset_img \"simple-factory.png\" %}   \n팩토리 패턴에 대한 큰 그림이다. 왜 이런 패턴을 사용하는지 하나하나 따져 보겠다.  \n\n#### 여기저기 객체를 생성하는 곳이 산재해 있다. (수정 불편함)\n토니스타크가 여러 버전에 아이언맨을 설계해놨다. 그래서 클라이언트 1000명 에게 아이언맨 버전을 소개하는 소책자를 뿌렸다고 하자.\n어이쿠 근데 토니스타크가 이미 뿌린 아이언맨 버전중에 Mark-13에 오류가 생겨서 출시 안하기로 하고 Mark-16을 새로 만들어서 변경이 생겨버렸다.\n이미 1,000명에게 뿌린 소책자를 수정해야 한다. 즉, 1000번을 수정해야 하는것이다.\n\n이것을 객체를 생성하는 코드가 여기저기 산재해 있고 그코드가 빈번한 변경이 이루어졌을때 얼마나 코드를 여기저기 수정해야하는지 알겠는가?\n바로 이 문제를 해결하기 위해 만들어진 패턴이 팩토리 패턴이다.\n\n다시 말해, 객체지향 디자인 원칙 **변경이 일어나는 부분을 캡슐화** 하는 것이다.\n\n### 그럼 추상 팩토리 패턴은 뭐야?\n\n{% asset_img \"factory-pattern.png\" %}  \n\n토니스타크가 고민을 하기 시작했다. 기존 아이언맨 설계도 가지고 적들을 잘 상대해 왔었는데 **적들에 성격이 다양해 지면서 그에 맞는 아이언맨을 만들어야(Facotry) 하는것이다. 하지만 기존 설계도를 수정, 번복을 자꾸 하고 실수가 생겨 불량품이 나오는 것이다.**   \n해서 아이언맨을 만드는 공통 설계서(추상 팩토리)를 만들고 그 기반으로 각각에 유형에 맞는 아이언맨인 헐크버스터, 나도아이언맨 등 (구상 팩토리) 설계도를 방식을 생각한 것이다.\n\n~~~java\npublic abstract class IronManFactory {\n\n    public IronMan orderIronMan(Enum ironType) {\n        IronMan ironMan = createIronMan(type);\n        ironMan.linkRegs();\n        ironMan.linkArms();\n        ironMan.linkBody();\n        ironMan.linkHead();\n    }\n\n    // 각각에 맞는 헐크버스터, 나도아이언맨 팩토리르 메소드를 구현한다.\n    public abstract createIronMan(Enum ironType);\n}\n\npublic class Main {\n\n    public void main(String[] args) {\n        IronManFactory factory = new HulkIronManFactory();\n        IronMan hulkIronMan = factory.orderIroMan(BatchType.hulk);\n        ...\n    }\n}\n~~~\n\n이렇게 사용하는 이유는 \n**객체를 생성하는** 코드를 많이 사용하는데 **공통적인 부분은 있지만** 또 **성격에 따라 다른 유형에 객체를 생성하기 원할 때** 사용하는 패턴이다.  \n위와 같은 구조로 코드를 작성하게 되면 공통된 부분으로 **코드 중복을 줄일수 있고** 인터페이스(추상클래스, 인터페이스 등)를 구현하는 방식을 사용해 **다형성에 이점**을 가져 갈 수 있어 코드 수정없이 유연한 코드를 작성 할 수 있는 장점이 있어서 사용한다.","slug":"Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편","published":1,"updated":"2019-07-10T14:42:50.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids09000kk0ot7q6njay7","content":"<h3><span id=\"결론부터-말하자면\">결론부터 말하자면…</span></h3>\n<p>객체 생성 하는 코드를 분리하여 클라이언트 코드와 결합도(의존성)를 낮추어 코드를 건드리는 횟수를 최소화 하기 위한 패턴이다.</p>\n<p>자, 용어부터 이해하자 그래야 전체적으로 이해가 되니까</p>\n<p>여기서 클라이언트 코드는 분리시킨 객체 생성 코드를 호출하는 쪽을 말한다.</p>\n<h4><span id=\"결합도는-왜-낮아-지는가\">결합도는 왜 낮아 지는가?</span></h4>\n<p>그것은 객체지향 성질중에 하나인 다형성을 이용 하였기 때문이다.  인터페이스를 구현한 객체들은 같은 인터페이스를 바라 보기 때문에 코드에 유연함이 있기 때문이다.</p>\n<h4><span id=\"왜-코드를-건드리는-횟수가-최소화-될까\">왜 코드를 건드리는 횟수가 최소화 될까?</span></h4>\n<p>객체를 생성하는 코드 부분을 분리 시켰기 때문에 객체를 추가/수정이 일어 나더라도 객체를 생성하는 코드만 건들면 되기 때문이다.</p>\n<p>일단, 객체를 생성하는 일은 구상클래스를 만드는 일인데 새로운 객체가 추가 될 수도 있고 삭제 될 수 있는 가능성이 상대적으로 많다.<br>\n또한 객체를 생성하는 코드가 여러 클래스내 에서도 사용 되면 예를 들어 10개의 클래스 내에서 객체를 생성하는 if ~ else if 구문이 있다고 했을때 객체 추가/수정이 발생하면 10개의 클래스에 코드를 변경해 줘야 하는 일이 발생한다.</p>\n<p>바로 이러한 문제점을 해결하기 위해 팩토리 패턴을 사용하는 것이다.</p>\n<p>이외에도 팩토리 패턴에 유용함이 있는데 아래 코드를 보면서 설명하겠다.</p>\n<h3><span id=\"팩토리-패턴-이란\">팩토리 패턴 이란?</span></h3>\n<blockquote>\n<p>팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만들게 하는 패턴</p>\n</blockquote>\n<h3><span id=\"내가-정의하는-팩토리-패턴-이란\">내가 정의하는 팩토리 패턴 이란?</span></h3>\n<p>객체를 생성하는 코드를 추상화하여 코드를 한곳에서 관리하지 않으면, 변화(생성,수정,삭제)가 발생 했을 때 해당 클라이언트 코드를 전부 수정해줘야 한다.<br>\n즉, 객체지향 디자인패턴 원칙 확장에 대해서는 열려고있고 변화에 대해서는 닫혀있어야 한다.<br>\n때문에 변화가 일어날 수 있는 객체 생성 담당하는 클래스를 만들어 한곳에서 관리하여 결합도를 줄이기 위해 사용하는 패턴이다.</p>\n<h3><span id=\"simple-factorty\">Simple Factorty</span></h3>\n<p>스프링에서 Bean을 DI하는 생성자 방식으로 IronManLab 클래스에게 팩토리 클래스를 주입하여 객체를 생성하는 부분과 아닌 부분을 분리하여 객체 생성 하는 코드에 변화가 있더라도 클라이언트는 변함이 없도록 하였다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronManLab</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SimpleIronManFactory factory;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IronManLab</span> <span class=\"params\">(SimpleIronManFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.factory = factory</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(Enum ironManType)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IronMan ironMan;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 다형성을 이용해 결합도를 최소화 하였으며 객체를 생성하는 코드에 변경이 일어나도</span></span><br><span class=\"line\"><span class=\"comment\">         * 바로 여기 클라이언트 코드는 변경이 일어나지 않는다.</span></span><br><span class=\"line\"><span class=\"comment\">        **/</span></span><br><span class=\"line\">        ironMan = factory.createIronMan(ironManType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 변경되지 않는 부분 </span></span><br><span class=\"line\"><span class=\"comment\">        **/</span></span><br><span class=\"line\">        ironMan.준비();</span><br><span class=\"line\">        ironMan.조립();</span><br><span class=\"line\">        ironMan.자비스설치();</span><br><span class=\"line\">        ironMan.전원ON();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleIronManFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(IronManType ironManType)</span> </span>&#123;</span><br><span class=\"line\">        IronMan ironMan = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        자주 변경되는 코드 그래서 분리 함</span></span><br><span class=\"line\"><span class=\"comment\">        **/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Battle)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> BattleIronMan();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Nano)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> NanoIronMan();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronMan</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String ironManName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 부품준비() &#123;</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 머리를 가져옵니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 몸통을 가져옵니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 다리를 가져옵니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 팔을 가져옵니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 조립() &#123;</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 몸통과 다리를 조립합니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 몸통과 팔을 조립합니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 몸통과 머리를 조립합니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 자비스삽입() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"자비스 소프트웨어를 설치하였습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 전원On() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"전원 ON 하였습니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"이 눈을 떴습니다!!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BattleIronMan</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronMan</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BattleIronMan</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ironManName = <span class=\"string\">\"BattleIronMan\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NanoIronMan</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronMan</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NanoIronMan</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ironManName = <span class=\"string\">\"NanoIronMan\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"simple-factory-pattern-에-한계\">Simple Factory Pattern 에 한계</span></h3>\n<p>무슨 한계 일까?? 아래 상황을 잘 보자<br>\n아이언맨이 불티나게 잘 팔리자 여러 나라에서 아이언맨을 사겠다고 난리이다.  사겠다고 한 나라들은 대한민국, 필리핀, 뉴질랜드 였다. 문제는 각 나라별로 요구사항이 조금씩 차이가 있는 것이다.</p>\n<ul>\n<li>대한민국 : 미사일이 많이 장착된 아이언맨</li>\n<li>가나     : 총이 많이 장착된 아이언맨</li>\n</ul>\n<p>좀 억지스러운게 있지만 이해를 위해 비유를 위와 같이 들었다.  토니 스타크는 미국 본사에서 일을 해야 하므로 각 나라에 대표자들을 뽑고 각 입맛에 맞는 아이언맨 공장을 세우고 아이언맨을 생산하게 하였다.</p>\n<p>그러면 Simpel Factory Pattern데로 아이언맨을 생산해 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KoreaIronManFactory koreaIronManFactory = <span class=\"keyword\">new</span> KoreaIronManFactory();</span><br><span class=\"line\">IronManLab ironManLab = <span class=\"keyword\">new</span> IronManLab(koreaIronManFactory);</span><br><span class=\"line\">ironManLab.createIronMan(<span class=\"string\">\"Battle\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">GanaIronManFactory ganaIronManFactory = <span class=\"keyword\">new</span> KoreaIronManFactory();</span><br><span class=\"line\">IronManLab ironManLab = <span class=\"keyword\">new</span> IronManLab(ganaIronManFactory);</span><br><span class=\"line\">ironManLab.createIronMan(<span class=\"string\">\"Battle\"</span>);</span><br><span class=\"line\">~~~ </span><br><span class=\"line\"></span><br><span class=\"line\">여기서부터가 문제가 발생한다.  </span><br><span class=\"line\"></span><br><span class=\"line\">일단, 토니스타크가 정의한 아이언맨을 제조하는 과정은</span><br><span class=\"line\">&gt; 준비 &gt; 조립 &gt; 자비스 설치 &gt; 전원 ON 이었다.  </span><br><span class=\"line\"></span><br><span class=\"line\">근데, 대한민국 에서는 </span><br><span class=\"line\">&gt; 조립 &gt; 자비스 설치 &gt; 전원 ON   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">~~~ java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(Enum ironManType)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IronMan ironMan;</span><br><span class=\"line\">        ironMan = factory.createIronMan(ironManType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//ironMan.준비();       // 빼먹었다!!!!!</span></span><br><span class=\"line\">        ironMan.조립();</span><br><span class=\"line\">        ironMan.자비스설치();</span><br><span class=\"line\">        ironMan.전원ON();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>준비 과정을 빼먹어서 조립이 잘 안되고 되더라도 움직이는 오류가 발생 하였고</p>\n<p>가나 에서는</p>\n<blockquote>\n<p>준비 &gt; 조립 &gt; 조비스 설치 &gt; 전원 ON</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(Enum ironManType)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IronMan ironMan;</span><br><span class=\"line\">        ironMan = factory.createIronMan(ironManType);</span><br><span class=\"line\"></span><br><span class=\"line\">        ironMan.준비();</span><br><span class=\"line\">        ironMan.조립();</span><br><span class=\"line\">        ironMan.조비스설치();       <span class=\"comment\">// 엥??? 이상한 소프트웨어를 붙이네???</span></span><br><span class=\"line\">        ironMan.전원ON();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>자비스가 아닌 가나 독자적으로 개발한 조비스를 설치하여 제어에 문제가 생긴것이다.</p>\n<p>즉, 토니스타크가 정의한 아이언맨 제조 방식을 누락/수정이 발생하여 일관되게 아이언맨을 생성할 수가 없게 된것이다.  각 아이언맨에 성격은 여러가지 일 수 있으나 아이언맨을 생산하는 공정 과정은 똑같아야 하기 때문에 그 공정과정을 강제 시키는 과정이 필요 한 것이다.</p>\n<h3><span id=\"그럼-어떻게-해야-할까\">그럼 어떻게 해야 할까?</span></h3>\n<p>기존 IronManLab에 아이언맨 만드는 과정은 그데로 두고 각 나라에 맞는 IronManLab을 구현 할 수 있도록 한다. 다시 말해서 IronManLab를 추상 클래스로 만든다.</p>\n<p>Simple Factory Class인 IronManLab 수정한 클래스를 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronManLab</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// SimpleIronManFactory factory;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 이 부분은 대한민국, 가나, 필리핀 각 입맛에 맞게 Factory 클래스를 만들수 있도록</span></span><br><span class=\"line\"><span class=\"comment\">     * 추상메소드로 선언한다.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * public IronManLab (SimpleIronManFactory factory) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">     *   this.factory = factory</span></span><br><span class=\"line\"><span class=\"comment\">     * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    **/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> IronMan <span class=\"title\">assembleIronMan</span><span class=\"params\">(Enum ironManType)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(Enum ironManType)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IronMan ironMan;</span><br><span class=\"line\">        ironMan = factory.assembleIronMan(ironManType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 이 부분은 변경 되지 않아야 한다.</span></span><br><span class=\"line\"><span class=\"comment\">        **/</span></span><br><span class=\"line\">        ironMan.준비();</span><br><span class=\"line\">        ironMan.조립();</span><br><span class=\"line\">        ironMan.자비스설치();</span><br><span class=\"line\">        ironMan.전원ON();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그럼 대한민국, 가나에서 입맛에 맞는 아이언맨을 만들 Lab 클래스를 구현해보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KoreaIronManLab</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronManLab</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 여기서는 구현만 담당하고 수퍼클래스에서는 아이언맨 일관된 제조를 담당한다.</span></span><br><span class=\"line\"><span class=\"comment\">  **/</span>  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(IronManType ironManType)</span> </span>&#123;</span><br><span class=\"line\">        IronMan ironMan = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Battle)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> KoreaBattleIronMan();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Nano)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> KoreaNanoIronMan();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KoreaBattleIronMan</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronMan</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BattleIronMan</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ironManName = <span class=\"string\">\"한국형 전투용 아이언맨 입니다.\"</span>;</span><br><span class=\"line\">        type = <span class=\"string\">\"미사일을 많이 가지고 있습니다.\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GanaIronManLab</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronManLab</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 여기서는 구현만 담당하고 수퍼클래스에서는 아이언맨 일관된 제조를 담당한다.</span></span><br><span class=\"line\"><span class=\"comment\">  **/</span>  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(IronManType ironManType)</span> </span>&#123;</span><br><span class=\"line\">        IronMan ironMan = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Battle)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> GanaHulkBattleIronMan();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Nano)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> GanaNanoIronMan();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GanaBattleIronMan</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronMan</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BattleIronMan</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ironManName = <span class=\"string\">\"가나형 전투용 아이언맨 입니다.\"</span>;</span><br><span class=\"line\">        type = <span class=\"string\">\"총을 많이 가지고 있습니다.\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>자 이제 직접 사용하는 클라이언트 코드를 만들어 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    IronManLab koreaIronManLab = <span class=\"keyword\">new</span> KoreaIronManLab();</span><br><span class=\"line\">    IronManLab ganaIronManLab = <span class=\"keyword\">new</span> GanaIronManLab();</span><br><span class=\"line\">    </span><br><span class=\"line\">    IronMan koreaIronMan = koreaIronManLab.createIronMan(IronManType.BATTLE);</span><br><span class=\"line\">    IronMan ganaIronMan = ganaIronManLab.createIronMan(IronManType.BATTLE);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>// TODO 추상팩토리</p>\n<h3><span id=\"팩토리-패턴에-장점은-무엇인가\">팩토리 패턴에 장점은 무엇인가?</span></h3>\n<img src=\"/2019/06/28/Design%20Patterns/[Design%20Patterns]%20팩토리%20패턴,%20도대체%20왜%20쓰는거야-기본%20이론편/simple-factory.png\">   \n<p>팩토리 패턴에 대한 큰 그림이다. 왜 이런 패턴을 사용하는지 하나하나 따져 보겠다.</p>\n<h4><span id=\"여기저기-객체를-생성하는-곳이-산재해-있다-수정-불편함\">여기저기 객체를 생성하는 곳이 산재해 있다. (수정 불편함)</span></h4>\n<p>토니스타크가 여러 버전에 아이언맨을 설계해놨다. 그래서 클라이언트 1000명 에게 아이언맨 버전을 소개하는 소책자를 뿌렸다고 하자.<br>\n어이쿠 근데 토니스타크가 이미 뿌린 아이언맨 버전중에 Mark-13에 오류가 생겨서 출시 안하기로 하고 Mark-16을 새로 만들어서 변경이 생겨버렸다.<br>\n이미 1,000명에게 뿌린 소책자를 수정해야 한다. 즉, 1000번을 수정해야 하는것이다.</p>\n<p>이것을 객체를 생성하는 코드가 여기저기 산재해 있고 그코드가 빈번한 변경이 이루어졌을때 얼마나 코드를 여기저기 수정해야하는지 알겠는가?<br>\n바로 이 문제를 해결하기 위해 만들어진 패턴이 팩토리 패턴이다.</p>\n<p>다시 말해, 객체지향 디자인 원칙 <strong>변경이 일어나는 부분을 캡슐화</strong> 하는 것이다.</p>\n<h3><span id=\"그럼-추상-팩토리-패턴은-뭐야\">그럼 추상 팩토리 패턴은 뭐야?</span></h3>\n<img src=\"/2019/06/28/Design%20Patterns/[Design%20Patterns]%20팩토리%20패턴,%20도대체%20왜%20쓰는거야-기본%20이론편/factory-pattern.png\">  \n<p>토니스타크가 고민을 하기 시작했다. 기존 아이언맨 설계도 가지고 적들을 잘 상대해 왔었는데 <strong>적들에 성격이 다양해 지면서 그에 맞는 아이언맨을 만들어야(Facotry) 하는것이다. 하지만 기존 설계도를 수정, 번복을 자꾸 하고 실수가 생겨 불량품이 나오는 것이다.</strong><br>\n해서 아이언맨을 만드는 공통 설계서(추상 팩토리)를 만들고 그 기반으로 각각에 유형에 맞는 아이언맨인 헐크버스터, 나도아이언맨 등 (구상 팩토리) 설계도를 방식을 생각한 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronManFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">orderIronMan</span><span class=\"params\">(Enum ironType)</span> </span>&#123;</span><br><span class=\"line\">        IronMan ironMan = createIronMan(type);</span><br><span class=\"line\">        ironMan.linkRegs();</span><br><span class=\"line\">        ironMan.linkArms();</span><br><span class=\"line\">        ironMan.linkBody();</span><br><span class=\"line\">        ironMan.linkHead();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 각각에 맞는 헐크버스터, 나도아이언맨 팩토리르 메소드를 구현한다.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"title\">createIronMan</span><span class=\"params\">(Enum ironType)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        IronManFactory factory = <span class=\"keyword\">new</span> HulkIronManFactory();</span><br><span class=\"line\">        IronMan hulkIronMan = factory.orderIroMan(BatchType.hulk);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 사용하는 이유는<br>\n<strong>객체를 생성하는</strong> 코드를 많이 사용하는데 <strong>공통적인 부분은 있지만</strong> 또 <strong>성격에 따라 다른 유형에 객체를 생성하기 원할 때</strong> 사용하는 패턴이다.<br>\n위와 같은 구조로 코드를 작성하게 되면 공통된 부분으로 <strong>코드 중복을 줄일수 있고</strong> 인터페이스(추상클래스, 인터페이스 등)를 구현하는 방식을 사용해 <strong>다형성에 이점</strong>을 가져 갈 수 있어 코드 수정없이 유연한 코드를 작성 할 수 있는 장점이 있어서 사용한다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>결론부터 말하자면…</h3>\n<p>객체 생성 하는 코드를 분리하여 클라이언트 코드와 결합도(의존성)를 낮추어 코드를 건드리는 횟수를 최소화 하기 위한 패턴이다.</p>\n<p>자, 용어부터 이해하자 그래야 전체적으로 이해가 되니까</p>\n<p>여기서 클라이언트 코드는 분리시킨 객체 생성 코드를 호출하는 쪽을 말한다.</p>\n<h4>결합도는 왜 낮아 지는가?</h4>\n<p>그것은 객체지향 성질중에 하나인 다형성을 이용 하였기 때문이다.  인터페이스를 구현한 객체들은 같은 인터페이스를 바라 보기 때문에 코드에 유연함이 있기 때문이다.</p>\n<h4>왜 코드를 건드리는 횟수가 최소화 될까?</h4>\n<p>객체를 생성하는 코드 부분을 분리 시켰기 때문에 객체를 추가/수정이 일어 나더라도 객체를 생성하는 코드만 건들면 되기 때문이다.</p>\n<p>일단, 객체를 생성하는 일은 구상클래스를 만드는 일인데 새로운 객체가 추가 될 수도 있고 삭제 될 수 있는 가능성이 상대적으로 많다.<br>\n또한 객체를 생성하는 코드가 여러 클래스내 에서도 사용 되면 예를 들어 10개의 클래스 내에서 객체를 생성하는 if ~ else if 구문이 있다고 했을때 객체 추가/수정이 발생하면 10개의 클래스에 코드를 변경해 줘야 하는 일이 발생한다.</p>\n<p>바로 이러한 문제점을 해결하기 위해 팩토리 패턴을 사용하는 것이다.</p>\n<p>이외에도 팩토리 패턴에 유용함이 있는데 아래 코드를 보면서 설명하겠다.</p>\n<h3>팩토리 패턴 이란?</h3>\n<blockquote>\n<p>팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만들게 하는 패턴</p>\n</blockquote>\n<h3>내가 정의하는 팩토리 패턴 이란?</h3>\n<p>객체를 생성하는 코드를 추상화하여 코드를 한곳에서 관리하지 않으면, 변화(생성,수정,삭제)가 발생 했을 때 해당 클라이언트 코드를 전부 수정해줘야 한다.<br>\n즉, 객체지향 디자인패턴 원칙 확장에 대해서는 열려고있고 변화에 대해서는 닫혀있어야 한다.<br>\n때문에 변화가 일어날 수 있는 객체 생성 담당하는 클래스를 만들어 한곳에서 관리하여 결합도를 줄이기 위해 사용하는 패턴이다.</p>\n<h3>Simple Factorty</h3>\n<p>스프링에서 Bean을 DI하는 생성자 방식으로 IronManLab 클래스에게 팩토리 클래스를 주입하여 객체를 생성하는 부분과 아닌 부분을 분리하여 객체 생성 하는 코드에 변화가 있더라도 클라이언트는 변함이 없도록 하였다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronManLab</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    SimpleIronManFactory factory;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IronManLab</span> <span class=\"params\">(SimpleIronManFactory factory)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.factory = factory</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(Enum ironManType)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IronMan ironMan;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 다형성을 이용해 결합도를 최소화 하였으며 객체를 생성하는 코드에 변경이 일어나도</span></span><br><span class=\"line\"><span class=\"comment\">         * 바로 여기 클라이언트 코드는 변경이 일어나지 않는다.</span></span><br><span class=\"line\"><span class=\"comment\">        **/</span></span><br><span class=\"line\">        ironMan = factory.createIronMan(ironManType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 변경되지 않는 부분 </span></span><br><span class=\"line\"><span class=\"comment\">        **/</span></span><br><span class=\"line\">        ironMan.준비();</span><br><span class=\"line\">        ironMan.조립();</span><br><span class=\"line\">        ironMan.자비스설치();</span><br><span class=\"line\">        ironMan.전원ON();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleIronManFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(IronManType ironManType)</span> </span>&#123;</span><br><span class=\"line\">        IronMan ironMan = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">        자주 변경되는 코드 그래서 분리 함</span></span><br><span class=\"line\"><span class=\"comment\">        **/</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Battle)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> BattleIronMan();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Nano)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> NanoIronMan();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronMan</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String ironManName;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 부품준비() &#123;</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 머리를 가져옵니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 몸통을 가져옵니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 다리를 가져옵니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 팔을 가져옵니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 조립() &#123;</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 몸통과 다리를 조립합니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 몸통과 팔을 조립합니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"의 몸통과 머리를 조립합니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 자비스삽입() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"자비스 소프트웨어를 설치하였습니다.\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 전원On() &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"전원 ON 하였습니다.\"</span>);</span><br><span class=\"line\">        System.out.println(ironManName + <span class=\"string\">\"이 눈을 떴습니다!!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BattleIronMan</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronMan</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BattleIronMan</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ironManName = <span class=\"string\">\"BattleIronMan\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NanoIronMan</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronMan</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">NanoIronMan</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ironManName = <span class=\"string\">\"NanoIronMan\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>Simple Factory Pattern 에 한계</h3>\n<p>무슨 한계 일까?? 아래 상황을 잘 보자<br>\n아이언맨이 불티나게 잘 팔리자 여러 나라에서 아이언맨을 사겠다고 난리이다.  사겠다고 한 나라들은 대한민국, 필리핀, 뉴질랜드 였다. 문제는 각 나라별로 요구사항이 조금씩 차이가 있는 것이다.</p>\n<ul>\n<li>대한민국 : 미사일이 많이 장착된 아이언맨</li>\n<li>가나     : 총이 많이 장착된 아이언맨</li>\n</ul>\n<p>좀 억지스러운게 있지만 이해를 위해 비유를 위와 같이 들었다.  토니 스타크는 미국 본사에서 일을 해야 하므로 각 나라에 대표자들을 뽑고 각 입맛에 맞는 아이언맨 공장을 세우고 아이언맨을 생산하게 하였다.</p>\n<p>그러면 Simpel Factory Pattern데로 아이언맨을 생산해 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KoreaIronManFactory koreaIronManFactory = <span class=\"keyword\">new</span> KoreaIronManFactory();</span><br><span class=\"line\">IronManLab ironManLab = <span class=\"keyword\">new</span> IronManLab(koreaIronManFactory);</span><br><span class=\"line\">ironManLab.createIronMan(<span class=\"string\">\"Battle\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">GanaIronManFactory ganaIronManFactory = <span class=\"keyword\">new</span> KoreaIronManFactory();</span><br><span class=\"line\">IronManLab ironManLab = <span class=\"keyword\">new</span> IronManLab(ganaIronManFactory);</span><br><span class=\"line\">ironManLab.createIronMan(<span class=\"string\">\"Battle\"</span>);</span><br><span class=\"line\">~~~ </span><br><span class=\"line\"></span><br><span class=\"line\">여기서부터가 문제가 발생한다.  </span><br><span class=\"line\"></span><br><span class=\"line\">일단, 토니스타크가 정의한 아이언맨을 제조하는 과정은</span><br><span class=\"line\">&gt; 준비 &gt; 조립 &gt; 자비스 설치 &gt; 전원 ON 이었다.  </span><br><span class=\"line\"></span><br><span class=\"line\">근데, 대한민국 에서는 </span><br><span class=\"line\">&gt; 조립 &gt; 자비스 설치 &gt; 전원 ON   </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">~~~ java</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(Enum ironManType)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IronMan ironMan;</span><br><span class=\"line\">        ironMan = factory.createIronMan(ironManType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//ironMan.준비();       // 빼먹었다!!!!!</span></span><br><span class=\"line\">        ironMan.조립();</span><br><span class=\"line\">        ironMan.자비스설치();</span><br><span class=\"line\">        ironMan.전원ON();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>준비 과정을 빼먹어서 조립이 잘 안되고 되더라도 움직이는 오류가 발생 하였고</p>\n<p>가나 에서는</p>\n<blockquote>\n<p>준비 &gt; 조립 &gt; 조비스 설치 &gt; 전원 ON</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(Enum ironManType)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IronMan ironMan;</span><br><span class=\"line\">        ironMan = factory.createIronMan(ironManType);</span><br><span class=\"line\"></span><br><span class=\"line\">        ironMan.준비();</span><br><span class=\"line\">        ironMan.조립();</span><br><span class=\"line\">        ironMan.조비스설치();       <span class=\"comment\">// 엥??? 이상한 소프트웨어를 붙이네???</span></span><br><span class=\"line\">        ironMan.전원ON();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;        </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>자비스가 아닌 가나 독자적으로 개발한 조비스를 설치하여 제어에 문제가 생긴것이다.</p>\n<p>즉, 토니스타크가 정의한 아이언맨 제조 방식을 누락/수정이 발생하여 일관되게 아이언맨을 생성할 수가 없게 된것이다.  각 아이언맨에 성격은 여러가지 일 수 있으나 아이언맨을 생산하는 공정 과정은 똑같아야 하기 때문에 그 공정과정을 강제 시키는 과정이 필요 한 것이다.</p>\n<h3>그럼 어떻게 해야 할까?</h3>\n<p>기존 IronManLab에 아이언맨 만드는 과정은 그데로 두고 각 나라에 맞는 IronManLab을 구현 할 수 있도록 한다. 다시 말해서 IronManLab를 추상 클래스로 만든다.</p>\n<p>Simple Factory Class인 IronManLab 수정한 클래스를 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronManLab</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// SimpleIronManFactory factory;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 이 부분은 대한민국, 가나, 필리핀 각 입맛에 맞게 Factory 클래스를 만들수 있도록</span></span><br><span class=\"line\"><span class=\"comment\">     * 추상메소드로 선언한다.</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * public IronManLab (SimpleIronManFactory factory) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">     *   this.factory = factory</span></span><br><span class=\"line\"><span class=\"comment\">     * &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    **/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> IronMan <span class=\"title\">assembleIronMan</span><span class=\"params\">(Enum ironManType)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(Enum ironManType)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IronMan ironMan;</span><br><span class=\"line\">        ironMan = factory.assembleIronMan(ironManType);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 이 부분은 변경 되지 않아야 한다.</span></span><br><span class=\"line\"><span class=\"comment\">        **/</span></span><br><span class=\"line\">        ironMan.준비();</span><br><span class=\"line\">        ironMan.조립();</span><br><span class=\"line\">        ironMan.자비스설치();</span><br><span class=\"line\">        ironMan.전원ON();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그럼 대한민국, 가나에서 입맛에 맞는 아이언맨을 만들 Lab 클래스를 구현해보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KoreaIronManLab</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronManLab</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 여기서는 구현만 담당하고 수퍼클래스에서는 아이언맨 일관된 제조를 담당한다.</span></span><br><span class=\"line\"><span class=\"comment\">  **/</span>  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(IronManType ironManType)</span> </span>&#123;</span><br><span class=\"line\">        IronMan ironMan = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Battle)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> KoreaBattleIronMan();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Nano)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> KoreaNanoIronMan();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KoreaBattleIronMan</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronMan</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BattleIronMan</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ironManName = <span class=\"string\">\"한국형 전투용 아이언맨 입니다.\"</span>;</span><br><span class=\"line\">        type = <span class=\"string\">\"미사일을 많이 가지고 있습니다.\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GanaIronManLab</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronManLab</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 여기서는 구현만 담당하고 수퍼클래스에서는 아이언맨 일관된 제조를 담당한다.</span></span><br><span class=\"line\"><span class=\"comment\">  **/</span>  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">createIronMan</span><span class=\"params\">(IronManType ironManType)</span> </span>&#123;</span><br><span class=\"line\">        IronMan ironMan = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Battle)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> GanaHulkBattleIronMan();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ironManType.equals(IronManType.Nano)) &#123;</span><br><span class=\"line\">            ironMan = <span class=\"keyword\">new</span> GanaNanoIronMan();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GanaBattleIronMan</span> <span class=\"keyword\">extends</span> <span class=\"title\">IronMan</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">BattleIronMan</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        ironManName = <span class=\"string\">\"가나형 전투용 아이언맨 입니다.\"</span>;</span><br><span class=\"line\">        type = <span class=\"string\">\"총을 많이 가지고 있습니다.\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>자 이제 직접 사용하는 클라이언트 코드를 만들어 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    IronManLab koreaIronManLab = <span class=\"keyword\">new</span> KoreaIronManLab();</span><br><span class=\"line\">    IronManLab ganaIronManLab = <span class=\"keyword\">new</span> GanaIronManLab();</span><br><span class=\"line\">    </span><br><span class=\"line\">    IronMan koreaIronMan = koreaIronManLab.createIronMan(IronManType.BATTLE);</span><br><span class=\"line\">    IronMan ganaIronMan = ganaIronManLab.createIronMan(IronManType.BATTLE);    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>// TODO 추상팩토리</p>\n<h3>팩토리 패턴에 장점은 무엇인가?</h3>\n<img src=\"/2019/06/28/Design%20Patterns/[Design%20Patterns]%20팩토리%20패턴,%20도대체%20왜%20쓰는거야-기본%20이론편/simple-factory.png\">   \n<p>팩토리 패턴에 대한 큰 그림이다. 왜 이런 패턴을 사용하는지 하나하나 따져 보겠다.</p>\n<h4>여기저기 객체를 생성하는 곳이 산재해 있다. (수정 불편함)</h4>\n<p>토니스타크가 여러 버전에 아이언맨을 설계해놨다. 그래서 클라이언트 1000명 에게 아이언맨 버전을 소개하는 소책자를 뿌렸다고 하자.<br>\n어이쿠 근데 토니스타크가 이미 뿌린 아이언맨 버전중에 Mark-13에 오류가 생겨서 출시 안하기로 하고 Mark-16을 새로 만들어서 변경이 생겨버렸다.<br>\n이미 1,000명에게 뿌린 소책자를 수정해야 한다. 즉, 1000번을 수정해야 하는것이다.</p>\n<p>이것을 객체를 생성하는 코드가 여기저기 산재해 있고 그코드가 빈번한 변경이 이루어졌을때 얼마나 코드를 여기저기 수정해야하는지 알겠는가?<br>\n바로 이 문제를 해결하기 위해 만들어진 패턴이 팩토리 패턴이다.</p>\n<p>다시 말해, 객체지향 디자인 원칙 <strong>변경이 일어나는 부분을 캡슐화</strong> 하는 것이다.</p>\n<h3>그럼 추상 팩토리 패턴은 뭐야?</h3>\n<img src=\"/2019/06/28/Design%20Patterns/[Design%20Patterns]%20팩토리%20패턴,%20도대체%20왜%20쓰는거야-기본%20이론편/factory-pattern.png\">  \n<p>토니스타크가 고민을 하기 시작했다. 기존 아이언맨 설계도 가지고 적들을 잘 상대해 왔었는데 <strong>적들에 성격이 다양해 지면서 그에 맞는 아이언맨을 만들어야(Facotry) 하는것이다. 하지만 기존 설계도를 수정, 번복을 자꾸 하고 실수가 생겨 불량품이 나오는 것이다.</strong><br>\n해서 아이언맨을 만드는 공통 설계서(추상 팩토리)를 만들고 그 기반으로 각각에 유형에 맞는 아이언맨인 헐크버스터, 나도아이언맨 등 (구상 팩토리) 설계도를 방식을 생각한 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronManFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">orderIronMan</span><span class=\"params\">(Enum ironType)</span> </span>&#123;</span><br><span class=\"line\">        IronMan ironMan = createIronMan(type);</span><br><span class=\"line\">        ironMan.linkRegs();</span><br><span class=\"line\">        ironMan.linkArms();</span><br><span class=\"line\">        ironMan.linkBody();</span><br><span class=\"line\">        ironMan.linkHead();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 각각에 맞는 헐크버스터, 나도아이언맨 팩토리르 메소드를 구현한다.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"title\">createIronMan</span><span class=\"params\">(Enum ironType)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        IronManFactory factory = <span class=\"keyword\">new</span> HulkIronManFactory();</span><br><span class=\"line\">        IronMan hulkIronMan = factory.orderIroMan(BatchType.hulk);</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 사용하는 이유는<br>\n<strong>객체를 생성하는</strong> 코드를 많이 사용하는데 <strong>공통적인 부분은 있지만</strong> 또 <strong>성격에 따라 다른 유형에 객체를 생성하기 원할 때</strong> 사용하는 패턴이다.<br>\n위와 같은 구조로 코드를 작성하게 되면 공통된 부분으로 <strong>코드 중복을 줄일수 있고</strong> 인터페이스(추상클래스, 인터페이스 등)를 구현하는 방식을 사용해 <strong>다형성에 이점</strong>을 가져 갈 수 있어 코드 수정없이 유연한 코드를 작성 할 수 있는 장점이 있어서 사용한다.</p>\n"},{"title":"템플릿 메소드 패턴, 도대체 왜 쓰는거야? - 기본 이론편","catalog":true,"date":"2019-05-15T02:36:45.000Z","subtitle":"템플릿 메소드 패턴 파헤치기","header-img":"bg_computer.jpg","catagories":["Design Patterns"],"_content":"\n### 템플릿 메소드 패턴이란?\n메소드 안에 규격화된 로직 또는 단계를 정의해놓고 그 규격화된 단계를 바탕으로 로직을 구현하는 패턴이며 포괄하고 있는 메서드를 템플릿 메서드라 한다.   \n일부 단계에서는 서브클래스에서 입맛에 맞게 로직을 구현하되 전체적인 템플릿(틀, 규격화된 로직)은 그대로 유지된다.\n\n\n### 언제 사용할까?\n예를 들어보자 토니스타크가 아이언맨 슈트를 자동으로 착용하는 장면을 상상해 보자  \n자비스는 토니스타크에게 아래와 같은 순서로 착용해 줄 것이다.  \n\n> 다리 -> 가슴 -> 팔 -> 머리\n\n그렇다 어떤 아이언맨 슈트라도 위 부분 순서데로 장착이 되는 것이다. 그럼 아이언맨 슈트 장착 명령을 자비스에게 내리기 위해 프로그램을 구상해 보자  \n\n순서는 다리, 가슴, 팔, 머리다. 어떤 아이언맨 슈트라도 말이다. 항상 저 순서데로라고 하면 그 순서를 규격화 템플릿화 해놓으면 순서가 꼬일 일도 없지 않을까?? 그리고 아이언맨 슈트별 각 단계에서 이루어지는 설정이 조금씩 다르더라고 그건 서브클래스에서 구현하면 되고 슈트가 장착 되는 순서는 어찌됬든 똑같은 것이다.  \n\n이대목에서 바로 템플릿 메소드 패턴을 사용하는 것이다.  \n\n코드로 구현해 보자\n\n~~~ java\nabstract class AbstractAssembl {\n\n    // 바로 여기가 템플릿 메소드이다.\n    final void 슈트조립() {\n        다리();\n        가슴();\n        팔();\n        머리();\n    }\n\n    abstract 머리();\n\n    void 다리() {\n        ..\n    }\n\n    void 가슴() {\n        ..\n    }\n\n    void 팔() {\n        ..\n    }\n}\n\n~~~\n\n### 후크\n아이언맨 슈트를 조립하는 템플릿 메소드는 만들었다. 근데 옵션으로 5개의 인피니티 스톤을 장착 할 수 있는 건틀렛을 끼고 싶을때 끼고 끼고 싶지 않을때 빼는 기능을 템플릿 메소드에 추가하려면 어떻게 해야 할까??  \n이부분이 후크가 필요한 기능이다. 아래 코드를 다시 보면 금방 이해가 될 것이다.  \n\n~~~ java\nabstract class AbstractAssembl {\n\n    // 바로 여기가 템플릿 메소드이다.\n    final void 슈트조립() {\n        다리();\n        가슴();\n        팔();\n        머리();\n        if(인피니티 건틀렛 사용 여부){\n            인피니티 건틀렛();\n        }\n    }\n\n    abstract 머리();\n\n    void 다리() {\n        ..\n    }\n\n    void 가슴() {\n        ..\n    }\n\n    void 팔() {\n        ..\n    }\n\n    // 이부분이 후크이다. 기본적으로 껍데기로 true 처리하고\n    // 후크를 사용하려면 서브클래스에서 오버라이드 해야한다.\n    boolean 인피니티 건틀렛 사용 여부(){\n        return true;\n    }\n}\n\n~~~","source":"_posts/Design Patterns/[Design Patterns] 템플릿 메소드 패턴, 도대체 왜 쓰는거야-기본 이론편.md","raw":"---\ntitle: 템플릿 메소드 패턴, 도대체 왜 쓰는거야? - 기본 이론편\ncatalog: true\ndate: 2019-05-15 11:36:45\nsubtitle: 템플릿 메소드 패턴 파헤치기\nheader-img: \"bg_computer.jpg\"\ntags:\n- Design Patterns\ncatagories:\n- Design Patterns\n---\n\n### 템플릿 메소드 패턴이란?\n메소드 안에 규격화된 로직 또는 단계를 정의해놓고 그 규격화된 단계를 바탕으로 로직을 구현하는 패턴이며 포괄하고 있는 메서드를 템플릿 메서드라 한다.   \n일부 단계에서는 서브클래스에서 입맛에 맞게 로직을 구현하되 전체적인 템플릿(틀, 규격화된 로직)은 그대로 유지된다.\n\n\n### 언제 사용할까?\n예를 들어보자 토니스타크가 아이언맨 슈트를 자동으로 착용하는 장면을 상상해 보자  \n자비스는 토니스타크에게 아래와 같은 순서로 착용해 줄 것이다.  \n\n> 다리 -> 가슴 -> 팔 -> 머리\n\n그렇다 어떤 아이언맨 슈트라도 위 부분 순서데로 장착이 되는 것이다. 그럼 아이언맨 슈트 장착 명령을 자비스에게 내리기 위해 프로그램을 구상해 보자  \n\n순서는 다리, 가슴, 팔, 머리다. 어떤 아이언맨 슈트라도 말이다. 항상 저 순서데로라고 하면 그 순서를 규격화 템플릿화 해놓으면 순서가 꼬일 일도 없지 않을까?? 그리고 아이언맨 슈트별 각 단계에서 이루어지는 설정이 조금씩 다르더라고 그건 서브클래스에서 구현하면 되고 슈트가 장착 되는 순서는 어찌됬든 똑같은 것이다.  \n\n이대목에서 바로 템플릿 메소드 패턴을 사용하는 것이다.  \n\n코드로 구현해 보자\n\n~~~ java\nabstract class AbstractAssembl {\n\n    // 바로 여기가 템플릿 메소드이다.\n    final void 슈트조립() {\n        다리();\n        가슴();\n        팔();\n        머리();\n    }\n\n    abstract 머리();\n\n    void 다리() {\n        ..\n    }\n\n    void 가슴() {\n        ..\n    }\n\n    void 팔() {\n        ..\n    }\n}\n\n~~~\n\n### 후크\n아이언맨 슈트를 조립하는 템플릿 메소드는 만들었다. 근데 옵션으로 5개의 인피니티 스톤을 장착 할 수 있는 건틀렛을 끼고 싶을때 끼고 끼고 싶지 않을때 빼는 기능을 템플릿 메소드에 추가하려면 어떻게 해야 할까??  \n이부분이 후크가 필요한 기능이다. 아래 코드를 다시 보면 금방 이해가 될 것이다.  \n\n~~~ java\nabstract class AbstractAssembl {\n\n    // 바로 여기가 템플릿 메소드이다.\n    final void 슈트조립() {\n        다리();\n        가슴();\n        팔();\n        머리();\n        if(인피니티 건틀렛 사용 여부){\n            인피니티 건틀렛();\n        }\n    }\n\n    abstract 머리();\n\n    void 다리() {\n        ..\n    }\n\n    void 가슴() {\n        ..\n    }\n\n    void 팔() {\n        ..\n    }\n\n    // 이부분이 후크이다. 기본적으로 껍데기로 true 처리하고\n    // 후크를 사용하려면 서브클래스에서 오버라이드 해야한다.\n    boolean 인피니티 건틀렛 사용 여부(){\n        return true;\n    }\n}\n\n~~~","slug":"Design Patterns/[Design Patterns] 템플릿 메소드 패턴, 도대체 왜 쓰는거야-기본 이론편","published":1,"updated":"2019-07-10T14:42:50.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids0c000nk0ot3atzibed","content":"<h3><span id=\"템플릿-메소드-패턴이란\">템플릿 메소드 패턴이란?</span></h3>\n<p>메소드 안에 규격화된 로직 또는 단계를 정의해놓고 그 규격화된 단계를 바탕으로 로직을 구현하는 패턴이며 포괄하고 있는 메서드를 템플릿 메서드라 한다.<br>\n일부 단계에서는 서브클래스에서 입맛에 맞게 로직을 구현하되 전체적인 템플릿(틀, 규격화된 로직)은 그대로 유지된다.</p>\n<h3><span id=\"언제-사용할까\">언제 사용할까?</span></h3>\n<p>예를 들어보자 토니스타크가 아이언맨 슈트를 자동으로 착용하는 장면을 상상해 보자<br>\n자비스는 토니스타크에게 아래와 같은 순서로 착용해 줄 것이다.</p>\n<blockquote>\n<p>다리 -&gt; 가슴 -&gt; 팔 -&gt; 머리</p>\n</blockquote>\n<p>그렇다 어떤 아이언맨 슈트라도 위 부분 순서데로 장착이 되는 것이다. 그럼 아이언맨 슈트 장착 명령을 자비스에게 내리기 위해 프로그램을 구상해 보자</p>\n<p>순서는 다리, 가슴, 팔, 머리다. 어떤 아이언맨 슈트라도 말이다. 항상 저 순서데로라고 하면 그 순서를 규격화 템플릿화 해놓으면 순서가 꼬일 일도 없지 않을까?? 그리고 아이언맨 슈트별 각 단계에서 이루어지는 설정이 조금씩 다르더라고 그건 서브클래스에서 구현하면 되고 슈트가 장착 되는 순서는 어찌됬든 똑같은 것이다.</p>\n<p>이대목에서 바로 템플릿 메소드 패턴을 사용하는 것이다.</p>\n<p>코드로 구현해 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractAssembl</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 바로 여기가 템플릿 메소드이다.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> 슈트조립() &#123;</span><br><span class=\"line\">        다리();</span><br><span class=\"line\">        가슴();</span><br><span class=\"line\">        팔();</span><br><span class=\"line\">        머리();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> 머리();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 다리() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 가슴() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 팔() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"후크\">후크</span></h3>\n<p>아이언맨 슈트를 조립하는 템플릿 메소드는 만들었다. 근데 옵션으로 5개의 인피니티 스톤을 장착 할 수 있는 건틀렛을 끼고 싶을때 끼고 끼고 싶지 않을때 빼는 기능을 템플릿 메소드에 추가하려면 어떻게 해야 할까??<br>\n이부분이 후크가 필요한 기능이다. 아래 코드를 다시 보면 금방 이해가 될 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractAssembl</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 바로 여기가 템플릿 메소드이다.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> 슈트조립() &#123;</span><br><span class=\"line\">        다리();</span><br><span class=\"line\">        가슴();</span><br><span class=\"line\">        팔();</span><br><span class=\"line\">        머리();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(인피니티 건틀렛 사용 여부)&#123;</span><br><span class=\"line\">            인피니티 건틀렛();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> 머리();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 다리() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 가슴() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 팔() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 이부분이 후크이다. 기본적으로 껍데기로 true 처리하고</span></span><br><span class=\"line\">    <span class=\"comment\">// 후크를 사용하려면 서브클래스에서 오버라이드 해야한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> 인피니티 건틀렛 사용 여부()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3>템플릿 메소드 패턴이란?</h3>\n<p>메소드 안에 규격화된 로직 또는 단계를 정의해놓고 그 규격화된 단계를 바탕으로 로직을 구현하는 패턴이며 포괄하고 있는 메서드를 템플릿 메서드라 한다.<br>\n일부 단계에서는 서브클래스에서 입맛에 맞게 로직을 구현하되 전체적인 템플릿(틀, 규격화된 로직)은 그대로 유지된다.</p>\n<h3>언제 사용할까?</h3>\n<p>예를 들어보자 토니스타크가 아이언맨 슈트를 자동으로 착용하는 장면을 상상해 보자<br>\n자비스는 토니스타크에게 아래와 같은 순서로 착용해 줄 것이다.</p>\n<blockquote>\n<p>다리 -&gt; 가슴 -&gt; 팔 -&gt; 머리</p>\n</blockquote>\n<p>그렇다 어떤 아이언맨 슈트라도 위 부분 순서데로 장착이 되는 것이다. 그럼 아이언맨 슈트 장착 명령을 자비스에게 내리기 위해 프로그램을 구상해 보자</p>\n<p>순서는 다리, 가슴, 팔, 머리다. 어떤 아이언맨 슈트라도 말이다. 항상 저 순서데로라고 하면 그 순서를 규격화 템플릿화 해놓으면 순서가 꼬일 일도 없지 않을까?? 그리고 아이언맨 슈트별 각 단계에서 이루어지는 설정이 조금씩 다르더라고 그건 서브클래스에서 구현하면 되고 슈트가 장착 되는 순서는 어찌됬든 똑같은 것이다.</p>\n<p>이대목에서 바로 템플릿 메소드 패턴을 사용하는 것이다.</p>\n<p>코드로 구현해 보자</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractAssembl</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 바로 여기가 템플릿 메소드이다.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> 슈트조립() &#123;</span><br><span class=\"line\">        다리();</span><br><span class=\"line\">        가슴();</span><br><span class=\"line\">        팔();</span><br><span class=\"line\">        머리();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> 머리();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 다리() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 가슴() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 팔() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>후크</h3>\n<p>아이언맨 슈트를 조립하는 템플릿 메소드는 만들었다. 근데 옵션으로 5개의 인피니티 스톤을 장착 할 수 있는 건틀렛을 끼고 싶을때 끼고 끼고 싶지 않을때 빼는 기능을 템플릿 메소드에 추가하려면 어떻게 해야 할까??<br>\n이부분이 후크가 필요한 기능이다. 아래 코드를 다시 보면 금방 이해가 될 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AbstractAssembl</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 바로 여기가 템플릿 메소드이다.</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> 슈트조립() &#123;</span><br><span class=\"line\">        다리();</span><br><span class=\"line\">        가슴();</span><br><span class=\"line\">        팔();</span><br><span class=\"line\">        머리();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(인피니티 건틀렛 사용 여부)&#123;</span><br><span class=\"line\">            인피니티 건틀렛();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">abstract</span> 머리();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 다리() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 가슴() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> 팔() &#123;</span><br><span class=\"line\">        ..</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 이부분이 후크이다. 기본적으로 껍데기로 true 처리하고</span></span><br><span class=\"line\">    <span class=\"comment\">// 후크를 사용하려면 서브클래스에서 오버라이드 해야한다.</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> 인피니티 건틀렛 사용 여부()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"서버가 여러대 있때 redirect 사용시 발생하는 문제","catalog":true,"date":"2019-08-18T00:06:21.000Z","subtitle":null,"header-img":"bg_computer.jpg","_content":"\n### 왜 alert 메시지가 안보이지? (Rdierect에 위험성)\n\n기획자, QA와 남은 항목에 대해서 회의하고 차주 월요일날에 서비스 오픈이 예정되어 있었다.  \n퇴근 30분전 크게 문제 될 상황은 없었고 내가 개발한 회원 탈퇴에 대한 테스트를 해봐야 겠다??? 너무 늦은감은 있지만 QA에서도 통과 되었었고 이상없겠지 하고 안하고 있었다... 자 해보자 했는데 운영서버에서 탈퇴 신청을 했는데 alert 창이 뜨지 않는 것이었다. 왜지???\n \n\n### 멀티서버\n\n얼른 선배 개발자에게 해당 내용을 공유를 하고 scouter에서 로그를 보는데 이상하다.. 내가 게대한 거는 비밀번호 불일치 됬다는 메시지를 띄워야 하는데 안띄워서 그런건데 탈퇴 프로세스가 동작한것처럼 로그가 찍혀있었다. 뭐지?? 맨붕이 오기 시작하였는데 선배 개발자가 얘기해 주었다. redirect 쓰지 않았어요??  \n\n처음엔 그게 뭐가 문제가 되지 했는데 설명을 듣고 보니 이해가 빡!! 됬다. redirect는 서버가 클라이언트에게 다시 서버로 재오청 하라는 말인데 재 요청 할 때 서버가 여러대 있으면 어디로 갈까?? 어디로 갈지 알 수 없는 것이다. 윗단에서 핸들링 해주기 때문이다. \n\n\n### 나는 왜 redcirect를 사용 하였는가?\n\najax 호출이 아닌 submit방식으로 사용자가 취한 액션에 대한 응답을 서버에서 메시지를 만들고 alert을 띄우는 로직을 만들어야 했다. 그럼 사용자가 요청한 url로 지금 같은 경우는 탈퇴를 처리하는 기능을 수행하고 결과를 리턴할때 다시 해당 페이지에 alert메시지를 담아서 보여줘야 한다. 그 메시지를 어떻게 전달할까 고민하였다.  \n\n#### alert 메시지만 뿌리고 redirect 해주는 html \n\n이방식은 별로 하고 싶지 않았다. alert 메시지를 뿌리는 용도에 html을 별도로 만드는게 맘에 들지 않았다.\n\n#### forward\n\n이방식은 url이 변하지 않아 사용자가 새로고침하게 되면 요청이 계속 반복 될 수 있어서 선호 하지 않았다.  \n\n(하지만 결국 답은 forward로 해결해도 되었다. 페이지를 호출하는 url(GET)이랑 처리를 위한 url(POST)을 같게 한다면 새로고침 하면 GET으로 호출 되어 페이지가 다시 호출 되기 때문에 처리를 위한 url이 실행되지 않을 것이기 때문이다.) \n\n### 그래서 찾은 Spring RedirectAttributes\n\nalert용 html 파일을 만들지 않고도 Spring에서 제공해주는 RedirectAttributes 클래스를 사용하면 alert을 담고 해당 페이지로 호출을 한다. 아래처럼 말이다~!\n\n~~~ java\n@PostMapping(value = \"/something-url\")\npublic String applyLeave(Errors erros, RedirectAttributes redirectAttributes, ...) {\n\n    boolean isValid = validator.validate(memberLeaveDTOV1, erros);\n        if (!isValid || erros.hasErrors()) {\n            redirectAttributes.addFlashAttribute(\"alertMsg\", erros);\n            return \"redirect:/something/redirect/url\";\n        }\n\n    // do something..\n}\n~~~\n\n결국 이방식은 서버가 여러대 있을때 사용하게 되면 alert메시지가 유실 된다는 것을 금요일 퇴근 30분전에 알게 된것이다.  \n\n1번서버에서 담은 alert 메시지가 redirect되어 다시 서버로 올때는 2, 3, 4, 5... 어느 서버로 갈지 모르기때문에 1번서버가 아닌 다른 서버로 가게 되면 request에 담은 alert메시지가 없는것이다. 아래 코드를 보면 이해가 될 것이다.  \n\n~~~ java\n@GetMapping(value = \"/leave\")\npublic String viewLeave(HttpServletRequest request) {\n\n    Map<String, ?> redirectMap = RequestContextUtils.getInputFlashMap(request);\n        \n        if (redirectMap != null) {\n            Object object = redirectMap.get(\"alertMsg\");\n        }\n    }\n\n    // do something..\n}\n~~~\n\n다시 리다이렉트 되어 넘어온 request안에 alert 메시지가 있을수도 없을수도 있는 것이다. 그래서 새로고침을 하다 보면 alert 메시지가 나오는 이유가 바로 이 이유였던 것이었다.  \n\n### 어떻게 해결 했나?? 그리고 남은 것은?\n\n결국 submit 방식을 버리고 ajax로 호출하여 브라우저에서 바로 리턴 받아 alert을 띄웠다.  \n\n궁금한것은 ajax 방식을 안쓰고 submit 방식으로 alert을 띄우게 하려면 어떻게 해야 할까?? 이다. alert을 유실시키지 않고 하는 방식이 분명히 있을텐데 그 방식은 다시 서치를 해야 겠다.","source":"_posts/ETC/서버가 여러대 있때 redirect 사용시 발생하는 문제.md","raw":"---\ntitle: 서버가 여러대 있때 redirect 사용시 발생하는 문제\ncatalog: true\ndate: 2019-08-18 09:06:21\nsubtitle:\nheader-img: \"bg_computer.jpg\"\ntags:\n- Experience\n---\n\n### 왜 alert 메시지가 안보이지? (Rdierect에 위험성)\n\n기획자, QA와 남은 항목에 대해서 회의하고 차주 월요일날에 서비스 오픈이 예정되어 있었다.  \n퇴근 30분전 크게 문제 될 상황은 없었고 내가 개발한 회원 탈퇴에 대한 테스트를 해봐야 겠다??? 너무 늦은감은 있지만 QA에서도 통과 되었었고 이상없겠지 하고 안하고 있었다... 자 해보자 했는데 운영서버에서 탈퇴 신청을 했는데 alert 창이 뜨지 않는 것이었다. 왜지???\n \n\n### 멀티서버\n\n얼른 선배 개발자에게 해당 내용을 공유를 하고 scouter에서 로그를 보는데 이상하다.. 내가 게대한 거는 비밀번호 불일치 됬다는 메시지를 띄워야 하는데 안띄워서 그런건데 탈퇴 프로세스가 동작한것처럼 로그가 찍혀있었다. 뭐지?? 맨붕이 오기 시작하였는데 선배 개발자가 얘기해 주었다. redirect 쓰지 않았어요??  \n\n처음엔 그게 뭐가 문제가 되지 했는데 설명을 듣고 보니 이해가 빡!! 됬다. redirect는 서버가 클라이언트에게 다시 서버로 재오청 하라는 말인데 재 요청 할 때 서버가 여러대 있으면 어디로 갈까?? 어디로 갈지 알 수 없는 것이다. 윗단에서 핸들링 해주기 때문이다. \n\n\n### 나는 왜 redcirect를 사용 하였는가?\n\najax 호출이 아닌 submit방식으로 사용자가 취한 액션에 대한 응답을 서버에서 메시지를 만들고 alert을 띄우는 로직을 만들어야 했다. 그럼 사용자가 요청한 url로 지금 같은 경우는 탈퇴를 처리하는 기능을 수행하고 결과를 리턴할때 다시 해당 페이지에 alert메시지를 담아서 보여줘야 한다. 그 메시지를 어떻게 전달할까 고민하였다.  \n\n#### alert 메시지만 뿌리고 redirect 해주는 html \n\n이방식은 별로 하고 싶지 않았다. alert 메시지를 뿌리는 용도에 html을 별도로 만드는게 맘에 들지 않았다.\n\n#### forward\n\n이방식은 url이 변하지 않아 사용자가 새로고침하게 되면 요청이 계속 반복 될 수 있어서 선호 하지 않았다.  \n\n(하지만 결국 답은 forward로 해결해도 되었다. 페이지를 호출하는 url(GET)이랑 처리를 위한 url(POST)을 같게 한다면 새로고침 하면 GET으로 호출 되어 페이지가 다시 호출 되기 때문에 처리를 위한 url이 실행되지 않을 것이기 때문이다.) \n\n### 그래서 찾은 Spring RedirectAttributes\n\nalert용 html 파일을 만들지 않고도 Spring에서 제공해주는 RedirectAttributes 클래스를 사용하면 alert을 담고 해당 페이지로 호출을 한다. 아래처럼 말이다~!\n\n~~~ java\n@PostMapping(value = \"/something-url\")\npublic String applyLeave(Errors erros, RedirectAttributes redirectAttributes, ...) {\n\n    boolean isValid = validator.validate(memberLeaveDTOV1, erros);\n        if (!isValid || erros.hasErrors()) {\n            redirectAttributes.addFlashAttribute(\"alertMsg\", erros);\n            return \"redirect:/something/redirect/url\";\n        }\n\n    // do something..\n}\n~~~\n\n결국 이방식은 서버가 여러대 있을때 사용하게 되면 alert메시지가 유실 된다는 것을 금요일 퇴근 30분전에 알게 된것이다.  \n\n1번서버에서 담은 alert 메시지가 redirect되어 다시 서버로 올때는 2, 3, 4, 5... 어느 서버로 갈지 모르기때문에 1번서버가 아닌 다른 서버로 가게 되면 request에 담은 alert메시지가 없는것이다. 아래 코드를 보면 이해가 될 것이다.  \n\n~~~ java\n@GetMapping(value = \"/leave\")\npublic String viewLeave(HttpServletRequest request) {\n\n    Map<String, ?> redirectMap = RequestContextUtils.getInputFlashMap(request);\n        \n        if (redirectMap != null) {\n            Object object = redirectMap.get(\"alertMsg\");\n        }\n    }\n\n    // do something..\n}\n~~~\n\n다시 리다이렉트 되어 넘어온 request안에 alert 메시지가 있을수도 없을수도 있는 것이다. 그래서 새로고침을 하다 보면 alert 메시지가 나오는 이유가 바로 이 이유였던 것이었다.  \n\n### 어떻게 해결 했나?? 그리고 남은 것은?\n\n결국 submit 방식을 버리고 ajax로 호출하여 브라우저에서 바로 리턴 받아 alert을 띄웠다.  \n\n궁금한것은 ajax 방식을 안쓰고 submit 방식으로 alert을 띄우게 하려면 어떻게 해야 할까?? 이다. alert을 유실시키지 않고 하는 방식이 분명히 있을텐데 그 방식은 다시 서치를 해야 겠다.","slug":"ETC/서버가 여러대 있때 redirect 사용시 발생하는 문제","published":1,"updated":"2019-08-19T13:24:56.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids0f000ok0ot57tgl2sq","content":"<h3><span id=\"왜-alert-메시지가-안보이지-rdierect에-위험성\">왜 alert 메시지가 안보이지? (Rdierect에 위험성)</span></h3>\n<p>기획자, QA와 남은 항목에 대해서 회의하고 차주 월요일날에 서비스 오픈이 예정되어 있었다.<br>\n퇴근 30분전 크게 문제 될 상황은 없었고 내가 개발한 회원 탈퇴에 대한 테스트를 해봐야 겠다??? 너무 늦은감은 있지만 QA에서도 통과 되었었고 이상없겠지 하고 안하고 있었다… 자 해보자 했는데 운영서버에서 탈퇴 신청을 했는데 alert 창이 뜨지 않는 것이었다. 왜지???</p>\n<h3><span id=\"멀티서버\">멀티서버</span></h3>\n<p>얼른 선배 개발자에게 해당 내용을 공유를 하고 scouter에서 로그를 보는데 이상하다… 내가 게대한 거는 비밀번호 불일치 됬다는 메시지를 띄워야 하는데 안띄워서 그런건데 탈퇴 프로세스가 동작한것처럼 로그가 찍혀있었다. 뭐지?? 맨붕이 오기 시작하였는데 선배 개발자가 얘기해 주었다. redirect 쓰지 않았어요??</p>\n<p>처음엔 그게 뭐가 문제가 되지 했는데 설명을 듣고 보니 이해가 빡!! 됬다. redirect는 서버가 클라이언트에게 다시 서버로 재오청 하라는 말인데 재 요청 할 때 서버가 여러대 있으면 어디로 갈까?? 어디로 갈지 알 수 없는 것이다. 윗단에서 핸들링 해주기 때문이다.</p>\n<h3><span id=\"나는-왜-redcirect를-사용-하였는가\">나는 왜 redcirect를 사용 하였는가?</span></h3>\n<p>ajax 호출이 아닌 submit방식으로 사용자가 취한 액션에 대한 응답을 서버에서 메시지를 만들고 alert을 띄우는 로직을 만들어야 했다. 그럼 사용자가 요청한 url로 지금 같은 경우는 탈퇴를 처리하는 기능을 수행하고 결과를 리턴할때 다시 해당 페이지에 alert메시지를 담아서 보여줘야 한다. 그 메시지를 어떻게 전달할까 고민하였다.</p>\n<h4><span id=\"alert-메시지만-뿌리고-redirect-해주는-html\">alert 메시지만 뿌리고 redirect 해주는 html</span></h4>\n<p>이방식은 별로 하고 싶지 않았다. alert 메시지를 뿌리는 용도에 html을 별도로 만드는게 맘에 들지 않았다.</p>\n<h4><span id=\"forward\">forward</span></h4>\n<p>이방식은 url이 변하지 않아 사용자가 새로고침하게 되면 요청이 계속 반복 될 수 있어서 선호 하지 않았다.</p>\n<p>(하지만 결국 답은 forward로 해결해도 되었다. 페이지를 호출하는 url(GET)이랑 처리를 위한 url(POST)을 같게 한다면 새로고침 하면 GET으로 호출 되어 페이지가 다시 호출 되기 때문에 처리를 위한 url이 실행되지 않을 것이기 때문이다.)</p>\n<h3><span id=\"그래서-찾은-spring-redirectattributes\">그래서 찾은 Spring RedirectAttributes</span></h3>\n<p>alert용 html 파일을 만들지 않고도 Spring에서 제공해주는 RedirectAttributes 클래스를 사용하면 alert을 담고 해당 페이지로 호출을 한다. 아래처럼 말이다~!</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping</span>(value = <span class=\"string\">\"/something-url\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">applyLeave</span><span class=\"params\">(Errors erros, RedirectAttributes redirectAttributes, ...)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isValid = validator.validate(memberLeaveDTOV1, erros);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isValid || erros.hasErrors()) &#123;</span><br><span class=\"line\">            redirectAttributes.addFlashAttribute(<span class=\"string\">\"alertMsg\"</span>, erros);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"redirect:/something/redirect/url\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// do something..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>결국 이방식은 서버가 여러대 있을때 사용하게 되면 alert메시지가 유실 된다는 것을 금요일 퇴근 30분전에 알게 된것이다.</p>\n<p>1번서버에서 담은 alert 메시지가 redirect되어 다시 서버로 올때는 2, 3, 4, 5… 어느 서버로 갈지 모르기때문에 1번서버가 아닌 다른 서버로 가게 되면 request에 담은 alert메시지가 없는것이다. 아래 코드를 보면 이해가 될 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(value = <span class=\"string\">\"/leave\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">viewLeave</span><span class=\"params\">(HttpServletRequest request)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, ?&gt; redirectMap = RequestContextUtils.getInputFlashMap(request);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (redirectMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Object object = redirectMap.get(<span class=\"string\">\"alertMsg\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// do something..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>다시 리다이렉트 되어 넘어온 request안에 alert 메시지가 있을수도 없을수도 있는 것이다. 그래서 새로고침을 하다 보면 alert 메시지가 나오는 이유가 바로 이 이유였던 것이었다.</p>\n<h3><span id=\"어떻게-해결-했나-그리고-남은-것은\">어떻게 해결 했나?? 그리고 남은 것은?</span></h3>\n<p>결국 submit 방식을 버리고 ajax로 호출하여 브라우저에서 바로 리턴 받아 alert을 띄웠다.</p>\n<p>궁금한것은 ajax 방식을 안쓰고 submit 방식으로 alert을 띄우게 하려면 어떻게 해야 할까?? 이다. alert을 유실시키지 않고 하는 방식이 분명히 있을텐데 그 방식은 다시 서치를 해야 겠다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>왜 alert 메시지가 안보이지? (Rdierect에 위험성)</h3>\n<p>기획자, QA와 남은 항목에 대해서 회의하고 차주 월요일날에 서비스 오픈이 예정되어 있었다.<br>\n퇴근 30분전 크게 문제 될 상황은 없었고 내가 개발한 회원 탈퇴에 대한 테스트를 해봐야 겠다??? 너무 늦은감은 있지만 QA에서도 통과 되었었고 이상없겠지 하고 안하고 있었다… 자 해보자 했는데 운영서버에서 탈퇴 신청을 했는데 alert 창이 뜨지 않는 것이었다. 왜지???</p>\n<h3>멀티서버</h3>\n<p>얼른 선배 개발자에게 해당 내용을 공유를 하고 scouter에서 로그를 보는데 이상하다… 내가 게대한 거는 비밀번호 불일치 됬다는 메시지를 띄워야 하는데 안띄워서 그런건데 탈퇴 프로세스가 동작한것처럼 로그가 찍혀있었다. 뭐지?? 맨붕이 오기 시작하였는데 선배 개발자가 얘기해 주었다. redirect 쓰지 않았어요??</p>\n<p>처음엔 그게 뭐가 문제가 되지 했는데 설명을 듣고 보니 이해가 빡!! 됬다. redirect는 서버가 클라이언트에게 다시 서버로 재오청 하라는 말인데 재 요청 할 때 서버가 여러대 있으면 어디로 갈까?? 어디로 갈지 알 수 없는 것이다. 윗단에서 핸들링 해주기 때문이다.</p>\n<h3>나는 왜 redcirect를 사용 하였는가?</h3>\n<p>ajax 호출이 아닌 submit방식으로 사용자가 취한 액션에 대한 응답을 서버에서 메시지를 만들고 alert을 띄우는 로직을 만들어야 했다. 그럼 사용자가 요청한 url로 지금 같은 경우는 탈퇴를 처리하는 기능을 수행하고 결과를 리턴할때 다시 해당 페이지에 alert메시지를 담아서 보여줘야 한다. 그 메시지를 어떻게 전달할까 고민하였다.</p>\n<h4>alert 메시지만 뿌리고 redirect 해주는 html</h4>\n<p>이방식은 별로 하고 싶지 않았다. alert 메시지를 뿌리는 용도에 html을 별도로 만드는게 맘에 들지 않았다.</p>\n<h4>forward</h4>\n<p>이방식은 url이 변하지 않아 사용자가 새로고침하게 되면 요청이 계속 반복 될 수 있어서 선호 하지 않았다.</p>\n<p>(하지만 결국 답은 forward로 해결해도 되었다. 페이지를 호출하는 url(GET)이랑 처리를 위한 url(POST)을 같게 한다면 새로고침 하면 GET으로 호출 되어 페이지가 다시 호출 되기 때문에 처리를 위한 url이 실행되지 않을 것이기 때문이다.)</p>\n<h3>그래서 찾은 Spring RedirectAttributes</h3>\n<p>alert용 html 파일을 만들지 않고도 Spring에서 제공해주는 RedirectAttributes 클래스를 사용하면 alert을 담고 해당 페이지로 호출을 한다. 아래처럼 말이다~!</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping</span>(value = <span class=\"string\">\"/something-url\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">applyLeave</span><span class=\"params\">(Errors erros, RedirectAttributes redirectAttributes, ...)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isValid = validator.validate(memberLeaveDTOV1, erros);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isValid || erros.hasErrors()) &#123;</span><br><span class=\"line\">            redirectAttributes.addFlashAttribute(<span class=\"string\">\"alertMsg\"</span>, erros);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">\"redirect:/something/redirect/url\"</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// do something..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>결국 이방식은 서버가 여러대 있을때 사용하게 되면 alert메시지가 유실 된다는 것을 금요일 퇴근 30분전에 알게 된것이다.</p>\n<p>1번서버에서 담은 alert 메시지가 redirect되어 다시 서버로 올때는 2, 3, 4, 5… 어느 서버로 갈지 모르기때문에 1번서버가 아닌 다른 서버로 가게 되면 request에 담은 alert메시지가 없는것이다. 아래 코드를 보면 이해가 될 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping</span>(value = <span class=\"string\">\"/leave\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">viewLeave</span><span class=\"params\">(HttpServletRequest request)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String, ?&gt; redirectMap = RequestContextUtils.getInputFlashMap(request);</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (redirectMap != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Object object = redirectMap.get(<span class=\"string\">\"alertMsg\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// do something..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>다시 리다이렉트 되어 넘어온 request안에 alert 메시지가 있을수도 없을수도 있는 것이다. 그래서 새로고침을 하다 보면 alert 메시지가 나오는 이유가 바로 이 이유였던 것이었다.</p>\n<h3>어떻게 해결 했나?? 그리고 남은 것은?</h3>\n<p>결국 submit 방식을 버리고 ajax로 호출하여 브라우저에서 바로 리턴 받아 alert을 띄웠다.</p>\n<p>궁금한것은 ajax 방식을 안쓰고 submit 방식으로 alert을 띄우게 하려면 어떻게 해야 할까?? 이다. alert을 유실시키지 않고 하는 방식이 분명히 있을텐데 그 방식은 다시 서치를 해야 겠다.</p>\n"},{"title":"Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기","catalog":true,"date":"2019-09-07T14:28:23.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["Docker"],"_content":"\n### Docker로 난 무얼 하고 싶었나??\n\n환경에 제약 없이 개발 DB를 구성하고 싶었다.  환경이라 함은 Window든 Mac이든 내컴퓨터든 다른 사람 컴퓨터든 말이다. Mac PC에서 공부한 내용을 Github에 올리고 집 Window PC에서도 Github에서 소스를 받아서 하면됬다. 근데, DB는?? 내가 저장한 데이터 DB 컨텍스트 정보는 환경이 바뀌면 매번 설치하고 데이터 싱크 맞추기 위해 쿼리 만들고 스크립트 돌려야 하나?  게다가 집은 Window PC이다.\n\n**개발하기도 전에 환경 구성하는 것 때문에 지친다!!!**\n\n그러다 문득 Docker! Docker로 이미지 만들고 Docker Hub 에 올려 놓으면 그 짜증나는 환경 구성이 해결 되지 않을까?? Docker를 왜 쓸까? 했는데 나에게 Docker가 필요해진 경우가 생긴 것이다. \n\n### 하지만 반영되지 않는 DB 데이터\n\nmysql 을 이미지를 받아 아래 처럼 셋팅 후 \n\n~~~ java\n- docker pull mysql:5.7 \n- docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1111 --name ryu mysql:5.7\n- docker exec -it ryu bash\n~~~\n\n아무리 삽질을해도 MySql 컨테이너에서 만든 데이터를 Docker Hub에 Push를 해도 반영이 되지 않았다.  알고보니 Docker에서 데이터를 저장하고 싶으면 Docker Container 외 별도 디렉토리(Volume)에 보관을 해야 한다는 것이다. 아래 블로그에서 도움을 받았다.  \n\n[Docker Volume 개념 및 MySql을 Docker상에서 운용하는 방법](https://joonhwan.github.io/2018-11-14-fix-mysql-volume-share-issue/)  \n\nDocker Container 가 삭제 되면 데이터는 보관되지 않고 같이 삭제된다. 즉, DB 데이터가 날라간다...  \n사실 이것이 Docker에 철학이라 생각한다. Docker 이미지, 컨테이너는 언제든지 갈아 치울수 있어야 하고 그럴려면 상태값을 당연히 보관하고 있으면 안된다.\n\n### 어떻게 데이터를 보관 할까?? 호스트 마운트\n\n**Mac 기준**\n~~~ java\ndocker container run -d -p 3306:3306     \\\n-e MYSQL_ROOT_PASSWORD=1111         \\\n-v /Users/ryu/mysql:/var/lib/mysql     \\\n--name ryu-mysql mysql\n~~~\n\n이런식으로 mysql 이미지에 특정 디렉토리에 내 홈 피씨 (현재 맥북) 에 파일을 공유 할 수 있다.  \n즉 Mysql 에서 쌓이는 데이터들을 /User/ryu/mariadb 에 가면 파일을 외부 반출 할 수 있는 것이다.  \n\n참고로 삽질을 많이 했었는데 [[docker] MariaDB + 로컬에 데이터저장소 연결](https://lemontia.tistory.com/740) 에서 도움을 받아 해결 하게 되었다.\n\n### 어? 그럼 dump 떠서 파일을 뜨면 어디서도 동일한 환경 이겠는데?\n\n그렇다. 맥북 피씨던 윈도우 피씨던 도커 Mysql 이미지와 덤프 파일만 있으면 동일한 환경에 나만의 개발 DB를 구축 할 수 있다. \n\n덤프 파일 명령어는 이렇다.\n\n~~~ java\nroot@xxxxx:/# mysqldump -u root -p --all-databases > /var/lib/mysql/dump_ryu_20190907.sql\n~~~\n\n~~~ java\nroot@xxxxx:/# mysqldump -u root -p ryu > /var/lib/mysql/dump/dump_ryu_20190907.sql\n~~~\n\n\n### 이제 Window에서도 mysql 개발 환경을 구성해 보자\n\n~~~ java\ndocker container run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1111 -v c:/Users/hmsarang/mysql:/var/lib/mysql --name ryu-mysql mysql\n~~~\n\n### Mysql 도커 컨테이너는 언제든 날려도 상관없다!!\n\nmysql 데이터 저장소를 지정한 영역에 따로 mount 하였기 때문이다.\n\n언제든지 컨테이너를 교체해도 된다.\n\n### 자이제 내가 하고싶은 IDE에서 Docker Mysql DB 띄워보자\n\n~~~ java\nspring:\n  datasource:\n    url: jdbc:mysql://10.0.75.1:3306/ryu\n    username: root\n    password: 1111\n    driver-class-name: com.mysql.jdbc.Driver\n\n    ...\n~~~\n\nWindow에서는 cmd 명령어인 ipconfig/all 을 입력하면 각 ip주소를 확인하면 된다. (Mac도 같은 방식으로 ip를 찾아보면 된다.)\n\n\n### 자주 사용하는 Docker 명령어\n\n**컨테이너, 이미지 모두 삭제**\n~~~ java\ndocker stop $(docker ps -a -q)\ndocker rm $(docker ps -a -q)\ndocker rmi $(docker images -q)\n~~~\n\n\n### 참고\n- [MySQL by Examples for Beginners](https://www3.ntu.edu.sg/home/ehchua/programming/sql/MySQL_Beginner.html)","source":"_posts/Docker/Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기.md","raw":"---\ntitle: Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기\ncatalog: true\ndate: 2019-09-07 23:28:23\nsubtitle:\nheader-img: \"bg_computer.jpg\"\ntags: \n- Learnning\ncatagories:\n- Docker\n---\n\n### Docker로 난 무얼 하고 싶었나??\n\n환경에 제약 없이 개발 DB를 구성하고 싶었다.  환경이라 함은 Window든 Mac이든 내컴퓨터든 다른 사람 컴퓨터든 말이다. Mac PC에서 공부한 내용을 Github에 올리고 집 Window PC에서도 Github에서 소스를 받아서 하면됬다. 근데, DB는?? 내가 저장한 데이터 DB 컨텍스트 정보는 환경이 바뀌면 매번 설치하고 데이터 싱크 맞추기 위해 쿼리 만들고 스크립트 돌려야 하나?  게다가 집은 Window PC이다.\n\n**개발하기도 전에 환경 구성하는 것 때문에 지친다!!!**\n\n그러다 문득 Docker! Docker로 이미지 만들고 Docker Hub 에 올려 놓으면 그 짜증나는 환경 구성이 해결 되지 않을까?? Docker를 왜 쓸까? 했는데 나에게 Docker가 필요해진 경우가 생긴 것이다. \n\n### 하지만 반영되지 않는 DB 데이터\n\nmysql 을 이미지를 받아 아래 처럼 셋팅 후 \n\n~~~ java\n- docker pull mysql:5.7 \n- docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1111 --name ryu mysql:5.7\n- docker exec -it ryu bash\n~~~\n\n아무리 삽질을해도 MySql 컨테이너에서 만든 데이터를 Docker Hub에 Push를 해도 반영이 되지 않았다.  알고보니 Docker에서 데이터를 저장하고 싶으면 Docker Container 외 별도 디렉토리(Volume)에 보관을 해야 한다는 것이다. 아래 블로그에서 도움을 받았다.  \n\n[Docker Volume 개념 및 MySql을 Docker상에서 운용하는 방법](https://joonhwan.github.io/2018-11-14-fix-mysql-volume-share-issue/)  \n\nDocker Container 가 삭제 되면 데이터는 보관되지 않고 같이 삭제된다. 즉, DB 데이터가 날라간다...  \n사실 이것이 Docker에 철학이라 생각한다. Docker 이미지, 컨테이너는 언제든지 갈아 치울수 있어야 하고 그럴려면 상태값을 당연히 보관하고 있으면 안된다.\n\n### 어떻게 데이터를 보관 할까?? 호스트 마운트\n\n**Mac 기준**\n~~~ java\ndocker container run -d -p 3306:3306     \\\n-e MYSQL_ROOT_PASSWORD=1111         \\\n-v /Users/ryu/mysql:/var/lib/mysql     \\\n--name ryu-mysql mysql\n~~~\n\n이런식으로 mysql 이미지에 특정 디렉토리에 내 홈 피씨 (현재 맥북) 에 파일을 공유 할 수 있다.  \n즉 Mysql 에서 쌓이는 데이터들을 /User/ryu/mariadb 에 가면 파일을 외부 반출 할 수 있는 것이다.  \n\n참고로 삽질을 많이 했었는데 [[docker] MariaDB + 로컬에 데이터저장소 연결](https://lemontia.tistory.com/740) 에서 도움을 받아 해결 하게 되었다.\n\n### 어? 그럼 dump 떠서 파일을 뜨면 어디서도 동일한 환경 이겠는데?\n\n그렇다. 맥북 피씨던 윈도우 피씨던 도커 Mysql 이미지와 덤프 파일만 있으면 동일한 환경에 나만의 개발 DB를 구축 할 수 있다. \n\n덤프 파일 명령어는 이렇다.\n\n~~~ java\nroot@xxxxx:/# mysqldump -u root -p --all-databases > /var/lib/mysql/dump_ryu_20190907.sql\n~~~\n\n~~~ java\nroot@xxxxx:/# mysqldump -u root -p ryu > /var/lib/mysql/dump/dump_ryu_20190907.sql\n~~~\n\n\n### 이제 Window에서도 mysql 개발 환경을 구성해 보자\n\n~~~ java\ndocker container run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1111 -v c:/Users/hmsarang/mysql:/var/lib/mysql --name ryu-mysql mysql\n~~~\n\n### Mysql 도커 컨테이너는 언제든 날려도 상관없다!!\n\nmysql 데이터 저장소를 지정한 영역에 따로 mount 하였기 때문이다.\n\n언제든지 컨테이너를 교체해도 된다.\n\n### 자이제 내가 하고싶은 IDE에서 Docker Mysql DB 띄워보자\n\n~~~ java\nspring:\n  datasource:\n    url: jdbc:mysql://10.0.75.1:3306/ryu\n    username: root\n    password: 1111\n    driver-class-name: com.mysql.jdbc.Driver\n\n    ...\n~~~\n\nWindow에서는 cmd 명령어인 ipconfig/all 을 입력하면 각 ip주소를 확인하면 된다. (Mac도 같은 방식으로 ip를 찾아보면 된다.)\n\n\n### 자주 사용하는 Docker 명령어\n\n**컨테이너, 이미지 모두 삭제**\n~~~ java\ndocker stop $(docker ps -a -q)\ndocker rm $(docker ps -a -q)\ndocker rmi $(docker images -q)\n~~~\n\n\n### 참고\n- [MySQL by Examples for Beginners](https://www3.ntu.edu.sg/home/ehchua/programming/sql/MySQL_Beginner.html)","slug":"Docker/Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기","published":1,"updated":"2019-09-22T07:00:34.641Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids0h000rk0otqqv621mm","content":"<h3><span id=\"docker로-난-무얼-하고-싶었나\">Docker로 난 무얼 하고 싶었나??</span></h3>\n<p>환경에 제약 없이 개발 DB를 구성하고 싶었다.  환경이라 함은 Window든 Mac이든 내컴퓨터든 다른 사람 컴퓨터든 말이다. Mac PC에서 공부한 내용을 Github에 올리고 집 Window PC에서도 Github에서 소스를 받아서 하면됬다. 근데, DB는?? 내가 저장한 데이터 DB 컨텍스트 정보는 환경이 바뀌면 매번 설치하고 데이터 싱크 맞추기 위해 쿼리 만들고 스크립트 돌려야 하나?  게다가 집은 Window PC이다.</p>\n<p><strong>개발하기도 전에 환경 구성하는 것 때문에 지친다!!!</strong></p>\n<p>그러다 문득 Docker! Docker로 이미지 만들고 Docker Hub 에 올려 놓으면 그 짜증나는 환경 구성이 해결 되지 않을까?? Docker를 왜 쓸까? 했는데 나에게 Docker가 필요해진 경우가 생긴 것이다.</p>\n<h3><span id=\"하지만-반영되지-않는-db-데이터\">하지만 반영되지 않는 DB 데이터</span></h3>\n<p>mysql 을 이미지를 받아 아래 처럼 셋팅 후</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- docker pull mysql:<span class=\"number\">5.7</span> </span><br><span class=\"line\">- docker run -d -p <span class=\"number\">3306</span>:<span class=\"number\">3306</span> -e MYSQL_ROOT_PASSWORD=<span class=\"number\">1111</span> --name ryu mysql:<span class=\"number\">5.7</span></span><br><span class=\"line\">- docker exec -it ryu bash</span><br></pre></td></tr></table></figure>\n<p>아무리 삽질을해도 MySql 컨테이너에서 만든 데이터를 Docker Hub에 Push를 해도 반영이 되지 않았다.  알고보니 Docker에서 데이터를 저장하고 싶으면 Docker Container 외 별도 디렉토리(Volume)에 보관을 해야 한다는 것이다. 아래 블로그에서 도움을 받았다.</p>\n<p><a href=\"https://joonhwan.github.io/2018-11-14-fix-mysql-volume-share-issue/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Docker Volume 개념 및 MySql을 Docker상에서 운용하는 방법</a></p>\n<p>Docker Container 가 삭제 되면 데이터는 보관되지 않고 같이 삭제된다. 즉, DB 데이터가 날라간다…<br>\n사실 이것이 Docker에 철학이라 생각한다. Docker 이미지, 컨테이너는 언제든지 갈아 치울수 있어야 하고 그럴려면 상태값을 당연히 보관하고 있으면 안된다.</p>\n<h3><span id=\"어떻게-데이터를-보관-할까-호스트-마운트\">어떻게 데이터를 보관 할까?? 호스트 마운트</span></h3>\n<p><strong>Mac 기준</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d -p <span class=\"number\">3306</span>:<span class=\"number\">3306</span>     \\</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=<span class=\"number\">1111</span>         \\</span><br><span class=\"line\">-v /Users/ryu/mysql:/<span class=\"keyword\">var</span>/lib/mysql     \\</span><br><span class=\"line\">--name ryu-mysql mysql</span><br></pre></td></tr></table></figure>\n<p>이런식으로 mysql 이미지에 특정 디렉토리에 내 홈 피씨 (현재 맥북) 에 파일을 공유 할 수 있다.<br>\n즉 Mysql 에서 쌓이는 데이터들을 /User/ryu/mariadb 에 가면 파일을 외부 반출 할 수 있는 것이다.</p>\n<p>참고로 삽질을 많이 했었는데 <a href=\"https://lemontia.tistory.com/740\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">[docker] MariaDB + 로컬에 데이터저장소 연결</a> 에서 도움을 받아 해결 하게 되었다.</p>\n<h3><span id=\"어-그럼-dump-떠서-파일을-뜨면-어디서도-동일한-환경-이겠는데\">어? 그럼 dump 떠서 파일을 뜨면 어디서도 동일한 환경 이겠는데?</span></h3>\n<p>그렇다. 맥북 피씨던 윈도우 피씨던 도커 Mysql 이미지와 덤프 파일만 있으면 동일한 환경에 나만의 개발 DB를 구축 할 수 있다.</p>\n<p>덤프 파일 명령어는 이렇다.</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@xxxxx:/# mysqldump -u root -p --all-databases &gt; /var/lib/mysql/dump_ryu_20190907.sql</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@xxxxx:/# mysqldump -u root -p ryu &gt; /var/lib/mysql/dump/dump_ryu_20190907.sql</span><br></pre></td></tr></table></figure>\n<h3><span id=\"이제-window에서도-mysql-개발-환경을-구성해-보자\">이제 Window에서도 mysql 개발 환경을 구성해 보자</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d -p <span class=\"number\">3306</span>:<span class=\"number\">3306</span> -e MYSQL_ROOT_PASSWORD=<span class=\"number\">1111</span> -v c:/Users/hmsarang/mysql:/<span class=\"keyword\">var</span>/lib/mysql --name ryu-mysql mysql</span><br></pre></td></tr></table></figure>\n<h3><span id=\"mysql-도커-컨테이너는-언제든-날려도-상관없다\">Mysql 도커 컨테이너는 언제든 날려도 상관없다!!</span></h3>\n<p>mysql 데이터 저장소를 지정한 영역에 따로 mount 하였기 때문이다.</p>\n<p>언제든지 컨테이너를 교체해도 된다.</p>\n<h3><span id=\"자이제-내가-하고싶은-ide에서-docker-mysql-db-띄워보자\">자이제 내가 하고싶은 IDE에서 Docker Mysql DB 띄워보자</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  datasource:</span><br><span class=\"line\">    url: jdbc:mysql:<span class=\"comment\">//10.0.75.1:3306/ryu</span></span><br><span class=\"line\">    username: root</span><br><span class=\"line\">    password: <span class=\"number\">1111</span></span><br><span class=\"line\">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>Window에서는 cmd 명령어인 ipconfig/all 을 입력하면 각 ip주소를 확인하면 된다. (Mac도 같은 방식으로 ip를 찾아보면 된다.)</p>\n<h3><span id=\"자주-사용하는-docker-명령어\">자주 사용하는 Docker 명령어</span></h3>\n<p><strong>컨테이너, 이미지 모두 삭제</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop $(docker ps -a -q)</span><br><span class=\"line\">docker rm $(docker ps -a -q)</span><br><span class=\"line\">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>\n<h3><span id=\"참고\">참고</span></h3>\n<ul>\n<li><a href=\"https://www3.ntu.edu.sg/home/ehchua/programming/sql/MySQL_Beginner.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MySQL by Examples for Beginners</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3>Docker로 난 무얼 하고 싶었나??</h3>\n<p>환경에 제약 없이 개발 DB를 구성하고 싶었다.  환경이라 함은 Window든 Mac이든 내컴퓨터든 다른 사람 컴퓨터든 말이다. Mac PC에서 공부한 내용을 Github에 올리고 집 Window PC에서도 Github에서 소스를 받아서 하면됬다. 근데, DB는?? 내가 저장한 데이터 DB 컨텍스트 정보는 환경이 바뀌면 매번 설치하고 데이터 싱크 맞추기 위해 쿼리 만들고 스크립트 돌려야 하나?  게다가 집은 Window PC이다.</p>\n<p><strong>개발하기도 전에 환경 구성하는 것 때문에 지친다!!!</strong></p>\n<p>그러다 문득 Docker! Docker로 이미지 만들고 Docker Hub 에 올려 놓으면 그 짜증나는 환경 구성이 해결 되지 않을까?? Docker를 왜 쓸까? 했는데 나에게 Docker가 필요해진 경우가 생긴 것이다.</p>\n<h3>하지만 반영되지 않는 DB 데이터</h3>\n<p>mysql 을 이미지를 받아 아래 처럼 셋팅 후</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- docker pull mysql:<span class=\"number\">5.7</span> </span><br><span class=\"line\">- docker run -d -p <span class=\"number\">3306</span>:<span class=\"number\">3306</span> -e MYSQL_ROOT_PASSWORD=<span class=\"number\">1111</span> --name ryu mysql:<span class=\"number\">5.7</span></span><br><span class=\"line\">- docker exec -it ryu bash</span><br></pre></td></tr></table></figure>\n<p>아무리 삽질을해도 MySql 컨테이너에서 만든 데이터를 Docker Hub에 Push를 해도 반영이 되지 않았다.  알고보니 Docker에서 데이터를 저장하고 싶으면 Docker Container 외 별도 디렉토리(Volume)에 보관을 해야 한다는 것이다. 아래 블로그에서 도움을 받았다.</p>\n<p><a href=\"https://joonhwan.github.io/2018-11-14-fix-mysql-volume-share-issue/\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Docker Volume 개념 및 MySql을 Docker상에서 운용하는 방법</a></p>\n<p>Docker Container 가 삭제 되면 데이터는 보관되지 않고 같이 삭제된다. 즉, DB 데이터가 날라간다…<br>\n사실 이것이 Docker에 철학이라 생각한다. Docker 이미지, 컨테이너는 언제든지 갈아 치울수 있어야 하고 그럴려면 상태값을 당연히 보관하고 있으면 안된다.</p>\n<h3>어떻게 데이터를 보관 할까?? 호스트 마운트</h3>\n<p><strong>Mac 기준</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d -p <span class=\"number\">3306</span>:<span class=\"number\">3306</span>     \\</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=<span class=\"number\">1111</span>         \\</span><br><span class=\"line\">-v /Users/ryu/mysql:/<span class=\"keyword\">var</span>/lib/mysql     \\</span><br><span class=\"line\">--name ryu-mysql mysql</span><br></pre></td></tr></table></figure>\n<p>이런식으로 mysql 이미지에 특정 디렉토리에 내 홈 피씨 (현재 맥북) 에 파일을 공유 할 수 있다.<br>\n즉 Mysql 에서 쌓이는 데이터들을 /User/ryu/mariadb 에 가면 파일을 외부 반출 할 수 있는 것이다.</p>\n<p>참고로 삽질을 많이 했었는데 <a href=\"https://lemontia.tistory.com/740\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">[docker] MariaDB + 로컬에 데이터저장소 연결</a> 에서 도움을 받아 해결 하게 되었다.</p>\n<h3>어? 그럼 dump 떠서 파일을 뜨면 어디서도 동일한 환경 이겠는데?</h3>\n<p>그렇다. 맥북 피씨던 윈도우 피씨던 도커 Mysql 이미지와 덤프 파일만 있으면 동일한 환경에 나만의 개발 DB를 구축 할 수 있다.</p>\n<p>덤프 파일 명령어는 이렇다.</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@xxxxx:/# mysqldump -u root -p --all-databases &gt; /var/lib/mysql/dump_ryu_20190907.sql</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@xxxxx:/# mysqldump -u root -p ryu &gt; /var/lib/mysql/dump/dump_ryu_20190907.sql</span><br></pre></td></tr></table></figure>\n<h3>이제 Window에서도 mysql 개발 환경을 구성해 보자</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker container run -d -p <span class=\"number\">3306</span>:<span class=\"number\">3306</span> -e MYSQL_ROOT_PASSWORD=<span class=\"number\">1111</span> -v c:/Users/hmsarang/mysql:/<span class=\"keyword\">var</span>/lib/mysql --name ryu-mysql mysql</span><br></pre></td></tr></table></figure>\n<h3>Mysql 도커 컨테이너는 언제든 날려도 상관없다!!</h3>\n<p>mysql 데이터 저장소를 지정한 영역에 따로 mount 하였기 때문이다.</p>\n<p>언제든지 컨테이너를 교체해도 된다.</p>\n<h3>자이제 내가 하고싶은 IDE에서 Docker Mysql DB 띄워보자</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring:</span><br><span class=\"line\">  datasource:</span><br><span class=\"line\">    url: jdbc:mysql:<span class=\"comment\">//10.0.75.1:3306/ryu</span></span><br><span class=\"line\">    username: root</span><br><span class=\"line\">    password: <span class=\"number\">1111</span></span><br><span class=\"line\">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n<p>Window에서는 cmd 명령어인 ipconfig/all 을 입력하면 각 ip주소를 확인하면 된다. (Mac도 같은 방식으로 ip를 찾아보면 된다.)</p>\n<h3>자주 사용하는 Docker 명령어</h3>\n<p><strong>컨테이너, 이미지 모두 삭제</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker stop $(docker ps -a -q)</span><br><span class=\"line\">docker rm $(docker ps -a -q)</span><br><span class=\"line\">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure>\n<h3>참고</h3>\n<ul>\n<li><a href=\"https://www3.ntu.edu.sg/home/ehchua/programming/sql/MySQL_Beginner.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">MySQL by Examples for Beginners</a></li>\n</ul>\n"},{"title":"팩토리 패턴, 도대체 왜 쓰는거야? - 실전 적용편","catalog":true,"date":"2019-04-17T14:25:05.000Z","subtitle":"팩토리 패턴 파헤치기","header-img":"bg_computer.jpg","catagories":["Design Patterns"],"_content":"\n### 왜 팩토리 패턴을 적용했는가?\n스케줄링 되는 배치를 개발 중이었다.  \n기존 배치(General)가 주기적으로 Source DB에 데이터를 이관하고 있었다. 이후 추가 배치를 개발 해야 되는 상황이 왔다.  \n언제나 그랬듯이 항상 수정 및 추가 개발 건이 생긴다.  \n추가로 배치를 개발 해야 하는 것은 **데이터 무결성을 체크하는 비교 배치**, **적재 실패된 데이터를 Retry하는 Retry배치** 였다.  \n여기서 가장 먼저 든 생각은 아.. 코드 중복이 생기겠구나 였다. 각각에 유형이 조금씩 다를 뿐 배치는 어차피 read, process, write 이기 때문이다.  \n\n그래서 디자인 패턴 및 객체지향적으로 코드를 작성해봐야 겠다. 라는 다짐이 리팩토링 및 디자인패턴 적용에 시초가 되었다.  \n가장먼저 생각이 드는 부분은 코드 중복을 최소화 하기 위해 공통적인 배치는 추상클래스로 만들어 놓고 각각에 입맛에 맞게 구상 배치 클래스를 두는 구조였다.  \n\n추가적으로 나는 배치 객체를 생성할 때 read, process, write 를 담당하는 각 객체들 또한 framework 화 하여 한꺼번에 객체를 생성하게끔 하여 나 말고 다른 개발자들이 또 새로운 배치를 만들어야 할 때 한가지 팩토리 클래스만 인스턴스하면 해당 배치를 사용 할 수 있게 하고 싶었다.  \n\n그랬다, 그래서 추상 팩토리 패턴을 선택하게 되었다.\n\n\n### 그래서 내가 직접 사용해본 소감은?\n추상 팩토리에 장점중에 하나는 클라이언트 코드에서 여기저기서 객체를 생성하는 코드가 퍼져있는 것을 다시 말해 변화되기 쉬운 코드 부분을 객체 생성을 담당하는 클래스(팩토리)를 만들어 놓으므로써 코드 수정을 한곳에서 할 수 있고 인터페이스, 추상클래스로 다형성을 활용하여 유연한 코드를 할 수 있다는것이 장점이라고 생각한다.  \n\n사실, 내가 실무에 적용한 팩토리 패턴에 큰 장점을 가질수 있는 상황은 아니었다.  \n배치 객체를 생성하는 코드 부분이 고작 각 배치별로 1개씩 밖에 없고 (배치라는 개발 특성인거 같다.) 한번 배치를 생성하면 다신 생성 할 필요가 없기 때문에 배치 객체를 생성하는 일이 그렇게 많지도 않다.  \n\n하지만 나는 배치와 배치를 생성하는 팩토리 배치 구조로 실무에 적용해봄으로써 디자인패턴을 하나하나 적용하면서 피부로 느껴 머릿속에 장기기억으로 남기고 싶어 적용해 본 것이다.  \n\n그렇다고 팩토리 패턴에 아예 효과를 보지 않았다는 소리는 아니다. read, process, write 에 대한 객체를 하나의 framework 역활을 한 것은 나이스했다고 생각한다.\n\n\n### 그래서 언제 사용하면 좋을까?\n객체를 인스턴스하는 코드가 클라이언트에서 많이 이용되고 자주 변화가 이루어진다면 팩토리 패턴을 사용하기 적합하다고 생각한다.\n\n\n### 다른 유용한 패턴을 적용해 볼게 있다면?\n배치 객체안에 reader, processor, writer 를 담당하는 각 객체가 있는데 그 step들이 끝날때 마다 결과 데이터를 갱신해주는 결과 객체를 반환하고 싶은데 이것을 옵저버 패턴을 이용하면 좋을 것 같다는 생각이 들었다.  \n그래서 다음 포스팅은 옵저버 패턴을 활용한 포스팅을 올리도록 하겠다.","source":"_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편.md","raw":"---\ntitle: 팩토리 패턴, 도대체 왜 쓰는거야? - 실전 적용편\ncatalog: true\ndate: 2019-04-17 23:25:05\nsubtitle: 팩토리 패턴 파헤치기\nheader-img: \"bg_computer.jpg\"\ntags:\n- Design Patterns\ncatagories:\n- Design Patterns\n---\n\n### 왜 팩토리 패턴을 적용했는가?\n스케줄링 되는 배치를 개발 중이었다.  \n기존 배치(General)가 주기적으로 Source DB에 데이터를 이관하고 있었다. 이후 추가 배치를 개발 해야 되는 상황이 왔다.  \n언제나 그랬듯이 항상 수정 및 추가 개발 건이 생긴다.  \n추가로 배치를 개발 해야 하는 것은 **데이터 무결성을 체크하는 비교 배치**, **적재 실패된 데이터를 Retry하는 Retry배치** 였다.  \n여기서 가장 먼저 든 생각은 아.. 코드 중복이 생기겠구나 였다. 각각에 유형이 조금씩 다를 뿐 배치는 어차피 read, process, write 이기 때문이다.  \n\n그래서 디자인 패턴 및 객체지향적으로 코드를 작성해봐야 겠다. 라는 다짐이 리팩토링 및 디자인패턴 적용에 시초가 되었다.  \n가장먼저 생각이 드는 부분은 코드 중복을 최소화 하기 위해 공통적인 배치는 추상클래스로 만들어 놓고 각각에 입맛에 맞게 구상 배치 클래스를 두는 구조였다.  \n\n추가적으로 나는 배치 객체를 생성할 때 read, process, write 를 담당하는 각 객체들 또한 framework 화 하여 한꺼번에 객체를 생성하게끔 하여 나 말고 다른 개발자들이 또 새로운 배치를 만들어야 할 때 한가지 팩토리 클래스만 인스턴스하면 해당 배치를 사용 할 수 있게 하고 싶었다.  \n\n그랬다, 그래서 추상 팩토리 패턴을 선택하게 되었다.\n\n\n### 그래서 내가 직접 사용해본 소감은?\n추상 팩토리에 장점중에 하나는 클라이언트 코드에서 여기저기서 객체를 생성하는 코드가 퍼져있는 것을 다시 말해 변화되기 쉬운 코드 부분을 객체 생성을 담당하는 클래스(팩토리)를 만들어 놓으므로써 코드 수정을 한곳에서 할 수 있고 인터페이스, 추상클래스로 다형성을 활용하여 유연한 코드를 할 수 있다는것이 장점이라고 생각한다.  \n\n사실, 내가 실무에 적용한 팩토리 패턴에 큰 장점을 가질수 있는 상황은 아니었다.  \n배치 객체를 생성하는 코드 부분이 고작 각 배치별로 1개씩 밖에 없고 (배치라는 개발 특성인거 같다.) 한번 배치를 생성하면 다신 생성 할 필요가 없기 때문에 배치 객체를 생성하는 일이 그렇게 많지도 않다.  \n\n하지만 나는 배치와 배치를 생성하는 팩토리 배치 구조로 실무에 적용해봄으로써 디자인패턴을 하나하나 적용하면서 피부로 느껴 머릿속에 장기기억으로 남기고 싶어 적용해 본 것이다.  \n\n그렇다고 팩토리 패턴에 아예 효과를 보지 않았다는 소리는 아니다. read, process, write 에 대한 객체를 하나의 framework 역활을 한 것은 나이스했다고 생각한다.\n\n\n### 그래서 언제 사용하면 좋을까?\n객체를 인스턴스하는 코드가 클라이언트에서 많이 이용되고 자주 변화가 이루어진다면 팩토리 패턴을 사용하기 적합하다고 생각한다.\n\n\n### 다른 유용한 패턴을 적용해 볼게 있다면?\n배치 객체안에 reader, processor, writer 를 담당하는 각 객체가 있는데 그 step들이 끝날때 마다 결과 데이터를 갱신해주는 결과 객체를 반환하고 싶은데 이것을 옵저버 패턴을 이용하면 좋을 것 같다는 생각이 들었다.  \n그래서 다음 포스팅은 옵저버 패턴을 활용한 포스팅을 올리도록 하겠다.","slug":"Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편","published":1,"updated":"2019-07-10T14:42:50.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids0k000tk0otx36sh04z","content":"<h3><span id=\"왜-팩토리-패턴을-적용했는가\">왜 팩토리 패턴을 적용했는가?</span></h3>\n<p>스케줄링 되는 배치를 개발 중이었다.<br>\n기존 배치(General)가 주기적으로 Source DB에 데이터를 이관하고 있었다. 이후 추가 배치를 개발 해야 되는 상황이 왔다.<br>\n언제나 그랬듯이 항상 수정 및 추가 개발 건이 생긴다.<br>\n추가로 배치를 개발 해야 하는 것은 <strong>데이터 무결성을 체크하는 비교 배치</strong>, <strong>적재 실패된 데이터를 Retry하는 Retry배치</strong> 였다.<br>\n여기서 가장 먼저 든 생각은 아… 코드 중복이 생기겠구나 였다. 각각에 유형이 조금씩 다를 뿐 배치는 어차피 read, process, write 이기 때문이다.</p>\n<p>그래서 디자인 패턴 및 객체지향적으로 코드를 작성해봐야 겠다. 라는 다짐이 리팩토링 및 디자인패턴 적용에 시초가 되었다.<br>\n가장먼저 생각이 드는 부분은 코드 중복을 최소화 하기 위해 공통적인 배치는 추상클래스로 만들어 놓고 각각에 입맛에 맞게 구상 배치 클래스를 두는 구조였다.</p>\n<p>추가적으로 나는 배치 객체를 생성할 때 read, process, write 를 담당하는 각 객체들 또한 framework 화 하여 한꺼번에 객체를 생성하게끔 하여 나 말고 다른 개발자들이 또 새로운 배치를 만들어야 할 때 한가지 팩토리 클래스만 인스턴스하면 해당 배치를 사용 할 수 있게 하고 싶었다.</p>\n<p>그랬다, 그래서 추상 팩토리 패턴을 선택하게 되었다.</p>\n<h3><span id=\"그래서-내가-직접-사용해본-소감은\">그래서 내가 직접 사용해본 소감은?</span></h3>\n<p>추상 팩토리에 장점중에 하나는 클라이언트 코드에서 여기저기서 객체를 생성하는 코드가 퍼져있는 것을 다시 말해 변화되기 쉬운 코드 부분을 객체 생성을 담당하는 클래스(팩토리)를 만들어 놓으므로써 코드 수정을 한곳에서 할 수 있고 인터페이스, 추상클래스로 다형성을 활용하여 유연한 코드를 할 수 있다는것이 장점이라고 생각한다.</p>\n<p>사실, 내가 실무에 적용한 팩토리 패턴에 큰 장점을 가질수 있는 상황은 아니었다.<br>\n배치 객체를 생성하는 코드 부분이 고작 각 배치별로 1개씩 밖에 없고 (배치라는 개발 특성인거 같다.) 한번 배치를 생성하면 다신 생성 할 필요가 없기 때문에 배치 객체를 생성하는 일이 그렇게 많지도 않다.</p>\n<p>하지만 나는 배치와 배치를 생성하는 팩토리 배치 구조로 실무에 적용해봄으로써 디자인패턴을 하나하나 적용하면서 피부로 느껴 머릿속에 장기기억으로 남기고 싶어 적용해 본 것이다.</p>\n<p>그렇다고 팩토리 패턴에 아예 효과를 보지 않았다는 소리는 아니다. read, process, write 에 대한 객체를 하나의 framework 역활을 한 것은 나이스했다고 생각한다.</p>\n<h3><span id=\"그래서-언제-사용하면-좋을까\">그래서 언제 사용하면 좋을까?</span></h3>\n<p>객체를 인스턴스하는 코드가 클라이언트에서 많이 이용되고 자주 변화가 이루어진다면 팩토리 패턴을 사용하기 적합하다고 생각한다.</p>\n<h3><span id=\"다른-유용한-패턴을-적용해-볼게-있다면\">다른 유용한 패턴을 적용해 볼게 있다면?</span></h3>\n<p>배치 객체안에 reader, processor, writer 를 담당하는 각 객체가 있는데 그 step들이 끝날때 마다 결과 데이터를 갱신해주는 결과 객체를 반환하고 싶은데 이것을 옵저버 패턴을 이용하면 좋을 것 같다는 생각이 들었다.<br>\n그래서 다음 포스팅은 옵저버 패턴을 활용한 포스팅을 올리도록 하겠다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>왜 팩토리 패턴을 적용했는가?</h3>\n<p>스케줄링 되는 배치를 개발 중이었다.<br>\n기존 배치(General)가 주기적으로 Source DB에 데이터를 이관하고 있었다. 이후 추가 배치를 개발 해야 되는 상황이 왔다.<br>\n언제나 그랬듯이 항상 수정 및 추가 개발 건이 생긴다.<br>\n추가로 배치를 개발 해야 하는 것은 <strong>데이터 무결성을 체크하는 비교 배치</strong>, <strong>적재 실패된 데이터를 Retry하는 Retry배치</strong> 였다.<br>\n여기서 가장 먼저 든 생각은 아… 코드 중복이 생기겠구나 였다. 각각에 유형이 조금씩 다를 뿐 배치는 어차피 read, process, write 이기 때문이다.</p>\n<p>그래서 디자인 패턴 및 객체지향적으로 코드를 작성해봐야 겠다. 라는 다짐이 리팩토링 및 디자인패턴 적용에 시초가 되었다.<br>\n가장먼저 생각이 드는 부분은 코드 중복을 최소화 하기 위해 공통적인 배치는 추상클래스로 만들어 놓고 각각에 입맛에 맞게 구상 배치 클래스를 두는 구조였다.</p>\n<p>추가적으로 나는 배치 객체를 생성할 때 read, process, write 를 담당하는 각 객체들 또한 framework 화 하여 한꺼번에 객체를 생성하게끔 하여 나 말고 다른 개발자들이 또 새로운 배치를 만들어야 할 때 한가지 팩토리 클래스만 인스턴스하면 해당 배치를 사용 할 수 있게 하고 싶었다.</p>\n<p>그랬다, 그래서 추상 팩토리 패턴을 선택하게 되었다.</p>\n<h3>그래서 내가 직접 사용해본 소감은?</h3>\n<p>추상 팩토리에 장점중에 하나는 클라이언트 코드에서 여기저기서 객체를 생성하는 코드가 퍼져있는 것을 다시 말해 변화되기 쉬운 코드 부분을 객체 생성을 담당하는 클래스(팩토리)를 만들어 놓으므로써 코드 수정을 한곳에서 할 수 있고 인터페이스, 추상클래스로 다형성을 활용하여 유연한 코드를 할 수 있다는것이 장점이라고 생각한다.</p>\n<p>사실, 내가 실무에 적용한 팩토리 패턴에 큰 장점을 가질수 있는 상황은 아니었다.<br>\n배치 객체를 생성하는 코드 부분이 고작 각 배치별로 1개씩 밖에 없고 (배치라는 개발 특성인거 같다.) 한번 배치를 생성하면 다신 생성 할 필요가 없기 때문에 배치 객체를 생성하는 일이 그렇게 많지도 않다.</p>\n<p>하지만 나는 배치와 배치를 생성하는 팩토리 배치 구조로 실무에 적용해봄으로써 디자인패턴을 하나하나 적용하면서 피부로 느껴 머릿속에 장기기억으로 남기고 싶어 적용해 본 것이다.</p>\n<p>그렇다고 팩토리 패턴에 아예 효과를 보지 않았다는 소리는 아니다. read, process, write 에 대한 객체를 하나의 framework 역활을 한 것은 나이스했다고 생각한다.</p>\n<h3>그래서 언제 사용하면 좋을까?</h3>\n<p>객체를 인스턴스하는 코드가 클라이언트에서 많이 이용되고 자주 변화가 이루어진다면 팩토리 패턴을 사용하기 적합하다고 생각한다.</p>\n<h3>다른 유용한 패턴을 적용해 볼게 있다면?</h3>\n<p>배치 객체안에 reader, processor, writer 를 담당하는 각 객체가 있는데 그 step들이 끝날때 마다 결과 데이터를 갱신해주는 결과 객체를 반환하고 싶은데 이것을 옵저버 패턴을 이용하면 좋을 것 같다는 생각이 들었다.<br>\n그래서 다음 포스팅은 옵저버 패턴을 활용한 포스팅을 올리도록 하겠다.</p>\n"},{"title":"N+1 문제 해결 방법","catalog":true,"date":"2019-07-10T14:55:15.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["JPA"],"_content":"\n# 예제 Repository \n[류윤광 Github](https://github.com/biggwang/learnning-subjects/tree/master/spring-jpa-n-plus-one)\n\n# 학습목표\n- N+1 문제가 무엇인지 안다.\n- 그것을 해결하기 위한 방법이 어떤것이 있으면 각 방법에 장단점을 안다.\n- 실무에 정확히 적용 할 줄 안다.\n\n\n# 우선 junit에 테스트 한다면 아래 사항을 주의 하자\n- junit은 기본적으로 테스트가 끝나면 rollback 되므로 그 영향으로 JPA에 영속성 컨텍스트에서 실행해야 할 쿼리를 날리지 않을 수 있다 어차피 롤백 될것이기 때문에 @Rollback(false)를 활용 하자\n- 하나의 테스트 메소드 내에서 save하고 select하면 pxoy initialize session 에러를 접할 수 있는데 그때는 @Transactional 를 사용하자\n\n\n# N + 1 문제\n- 영속성 컨텍스트에 **지연로딩(Lazy Loading)** 때문에 발생하는 현상이다.\n- A와 B테이블이 서로 1 to n 으로 연관관계가 있다고 하자.  \n쿼리로 따지면 조인하여 한번에 가져오고 싶은데 실제 사용 할 때마다 연관된 B테이블에 계속 쿼리를 날리는 것이다.\n- B테이블에 100개의 row가 있다면 100번을 날리는 것이다.\n- 아래를 보자\n\n{% asset_img \"jpa_n_plus_one.jpg\" %}  \n\n총 11개의 쿼리가 날라갔다.   \n- A 테이블 select 1개  \n- B 테이블 select 10개\n\nA 테이블만 조회 \n~~~ java\nList<Teacher> teacherList = teacherRepository.findAll();  \n~~~\n\n하지만 B테이블에 정보를 원한건 아니었고 @OneToMany는 FetchType이 기본적으로 Lazy이므로 B테이블 데이터는 쿼리를 날리지 않는다. 대신 프로직시 객체를 가지고 있다.  \n\n이제 실제 B테이블을 사용 하려고 한다.  \n\n~~~ java\n List<String> nameList = teacherList.stream()\n    .map(teacher -> teacher.getStudents().get(0).getName())\n    .collect(Collectors.toList());\n~~~\n\n여기서 teacherList에 갯수가 만큰 select 쿼리가 발생하는 것이다.  \n이 부분에서 n+1 문제가 발생했다고 하는 것이다.  \n그렇다면 어떤 방법으로 해결 할 수 있을까?\n\n\n\n\n## 해결방법 1 fetch join\n\n~~~ java\npublic interface TeacherRepository extends JpaRepository<Teacher, Long> {\n    @Query(\"select t from Teacher t join fetch t.students\")\n    List<Teacher> findAllJoinFetch();\n}\n~~~\n\n{% asset_img \"jpa_fetch_join.jpg\" %}  \n\n한번에 가져오기 위해 JPA가 쿼리를 만들어서 가져오게 한다. 이후에 말하겠지만 fetch join 은 inner join을 사용한다.\n\n> TODO QueryDSL로도 fetch join 해보기\n\n### fetch join에 문제점 - 불필요한 쿼리를 발생시킨다.\n\n> TODO fetch join에 한계를 보여 줄 수 있는 코드 작성\n\n\n## 해결방법 2 @EntityGraph\n\n내가 Eager로 가져오고 싶은것만 가져 올 수 있다.  \n\n~~~ java\npublic interface TeacherRepository extends JpaRepository<Teacher, Long> {\n    @EntityGraph(attributePaths = \"students\")\n    @Query(\"select t from Teacher t\")\n    List<Teacher> findAllEntityGraph();\n}  \n~~~\n\n\n{% asset_img \"jpa_entity_graph.jpg\" %}  \n \n### @EntityGraph 사용 주의사항 - OuterJoin 그리고 중복\n@EntityGraph는 OuterJoin을 사용하기 때문에 중복 데이터가 들어 올수 있는데 그것은 아래와 같이 Set을 통해 중복을 제거 할 수 있다.\n\n~~~ java\n@Entity\n@Getter\n@NoArgsConstructor\n@Table(name = \"teacher\")\npublic class Teacher {\n\n...\n\n    @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)\n    @JoinColumn(name=\"teacher_id\")\n    private Set<Student> students = new ArrayList<>();   \n}\n~~~\n\n\n#### 하지만 어쨌든 불필요한 쿼리\n해당 방법은 Java에서 중복을 제거한거고 DB에 불필요한 쿼리를 날린건 똑같다.  \n애초에 OuterJoin을 안쓰도록 노력하는게 좋을것 같다.\n\n\n\n# 지연로딩과 즉시로딩 개념\n\n\n## 즉시로딩 (EAGER)\n- @ManyToOne 에서 기본값\n- 연관된 엔티티에 모든 데이터를 DB 콜하여 한꺼번에 가져온다.\n\n## 지연로딩 (LAZY)\n- A 엔티티에 연관된 B 엔티티 정보가 있을때 A 엔티티 정보만 조회 하면 비효율적이므로 로딩을 지연하여 실제 사용할 때 데이터를 조회 한다.\n- 실제 사용 할때는 B 엔티티 정보를 사용하고자 할 때 실제 쿼리가 DB에 날리게 된다.\n- A 엔티티에서 연관된 B 엔티티 정보는 Proxy 형태로 (디버그로 보면 jvst 문자가 포함됨) 가지고 있다가 실제로 B 엔티티를 사용 할 때 쿼리를 날린다.\n\n\n## 연관 관계의 엔티티를 어떻게 가져올 것인가 \n\n- @OneToMany 기본값 Lazy\n- @ManyToMany 기본값 Eager\n\nPost, Comment 테이블 관계에서 Post에서 Comments데이터를 기본적으로 가져오지 않는다.  \n왜냐하면 Comment에 Row가 얼마나 있을지 모르기 때문이다. 그래서 OneToMany 기본값은 Lazy 이다.  \n\n즉, Post에 있는 데이터만 가져오겠다는 뜻이다.\n\n## 프록시\n\n-  엔티티를 조회할 때 영속성 컨텍스트에 존재하지 않으면 DB콜을 하게 되는데 그런 I/O 발생없이 실제 사용하는 시점까지 미루고 싶을때 사용한다.\n-  즉, 지연로딩을 사용하기 위해 프록시 객체가 필요함\n\n> Memeber member = entityManager.getReference(Member.class, \"member1\");\n\n\n## 참고\n- https://yellowh.tistory.com/125\n- https://jojoldu.tistory.com/165\n","source":"_posts/JPA/JPA N+1 문제 해결 방법.md","raw":"---\ntitle: N+1 문제 해결 방법\ncatalog: true\ndate: 2019-07-10 23:55:15\nsubtitle: \nheader-img: \"bg_computer.jpg\"\ntags: \n- Learnning\ncatagories:\n- JPA\n---\n\n# 예제 Repository \n[류윤광 Github](https://github.com/biggwang/learnning-subjects/tree/master/spring-jpa-n-plus-one)\n\n# 학습목표\n- N+1 문제가 무엇인지 안다.\n- 그것을 해결하기 위한 방법이 어떤것이 있으면 각 방법에 장단점을 안다.\n- 실무에 정확히 적용 할 줄 안다.\n\n\n# 우선 junit에 테스트 한다면 아래 사항을 주의 하자\n- junit은 기본적으로 테스트가 끝나면 rollback 되므로 그 영향으로 JPA에 영속성 컨텍스트에서 실행해야 할 쿼리를 날리지 않을 수 있다 어차피 롤백 될것이기 때문에 @Rollback(false)를 활용 하자\n- 하나의 테스트 메소드 내에서 save하고 select하면 pxoy initialize session 에러를 접할 수 있는데 그때는 @Transactional 를 사용하자\n\n\n# N + 1 문제\n- 영속성 컨텍스트에 **지연로딩(Lazy Loading)** 때문에 발생하는 현상이다.\n- A와 B테이블이 서로 1 to n 으로 연관관계가 있다고 하자.  \n쿼리로 따지면 조인하여 한번에 가져오고 싶은데 실제 사용 할 때마다 연관된 B테이블에 계속 쿼리를 날리는 것이다.\n- B테이블에 100개의 row가 있다면 100번을 날리는 것이다.\n- 아래를 보자\n\n{% asset_img \"jpa_n_plus_one.jpg\" %}  \n\n총 11개의 쿼리가 날라갔다.   \n- A 테이블 select 1개  \n- B 테이블 select 10개\n\nA 테이블만 조회 \n~~~ java\nList<Teacher> teacherList = teacherRepository.findAll();  \n~~~\n\n하지만 B테이블에 정보를 원한건 아니었고 @OneToMany는 FetchType이 기본적으로 Lazy이므로 B테이블 데이터는 쿼리를 날리지 않는다. 대신 프로직시 객체를 가지고 있다.  \n\n이제 실제 B테이블을 사용 하려고 한다.  \n\n~~~ java\n List<String> nameList = teacherList.stream()\n    .map(teacher -> teacher.getStudents().get(0).getName())\n    .collect(Collectors.toList());\n~~~\n\n여기서 teacherList에 갯수가 만큰 select 쿼리가 발생하는 것이다.  \n이 부분에서 n+1 문제가 발생했다고 하는 것이다.  \n그렇다면 어떤 방법으로 해결 할 수 있을까?\n\n\n\n\n## 해결방법 1 fetch join\n\n~~~ java\npublic interface TeacherRepository extends JpaRepository<Teacher, Long> {\n    @Query(\"select t from Teacher t join fetch t.students\")\n    List<Teacher> findAllJoinFetch();\n}\n~~~\n\n{% asset_img \"jpa_fetch_join.jpg\" %}  \n\n한번에 가져오기 위해 JPA가 쿼리를 만들어서 가져오게 한다. 이후에 말하겠지만 fetch join 은 inner join을 사용한다.\n\n> TODO QueryDSL로도 fetch join 해보기\n\n### fetch join에 문제점 - 불필요한 쿼리를 발생시킨다.\n\n> TODO fetch join에 한계를 보여 줄 수 있는 코드 작성\n\n\n## 해결방법 2 @EntityGraph\n\n내가 Eager로 가져오고 싶은것만 가져 올 수 있다.  \n\n~~~ java\npublic interface TeacherRepository extends JpaRepository<Teacher, Long> {\n    @EntityGraph(attributePaths = \"students\")\n    @Query(\"select t from Teacher t\")\n    List<Teacher> findAllEntityGraph();\n}  \n~~~\n\n\n{% asset_img \"jpa_entity_graph.jpg\" %}  \n \n### @EntityGraph 사용 주의사항 - OuterJoin 그리고 중복\n@EntityGraph는 OuterJoin을 사용하기 때문에 중복 데이터가 들어 올수 있는데 그것은 아래와 같이 Set을 통해 중복을 제거 할 수 있다.\n\n~~~ java\n@Entity\n@Getter\n@NoArgsConstructor\n@Table(name = \"teacher\")\npublic class Teacher {\n\n...\n\n    @OneToMany(fetch = FetchType.EAGER, cascade = CascadeType.ALL)\n    @JoinColumn(name=\"teacher_id\")\n    private Set<Student> students = new ArrayList<>();   \n}\n~~~\n\n\n#### 하지만 어쨌든 불필요한 쿼리\n해당 방법은 Java에서 중복을 제거한거고 DB에 불필요한 쿼리를 날린건 똑같다.  \n애초에 OuterJoin을 안쓰도록 노력하는게 좋을것 같다.\n\n\n\n# 지연로딩과 즉시로딩 개념\n\n\n## 즉시로딩 (EAGER)\n- @ManyToOne 에서 기본값\n- 연관된 엔티티에 모든 데이터를 DB 콜하여 한꺼번에 가져온다.\n\n## 지연로딩 (LAZY)\n- A 엔티티에 연관된 B 엔티티 정보가 있을때 A 엔티티 정보만 조회 하면 비효율적이므로 로딩을 지연하여 실제 사용할 때 데이터를 조회 한다.\n- 실제 사용 할때는 B 엔티티 정보를 사용하고자 할 때 실제 쿼리가 DB에 날리게 된다.\n- A 엔티티에서 연관된 B 엔티티 정보는 Proxy 형태로 (디버그로 보면 jvst 문자가 포함됨) 가지고 있다가 실제로 B 엔티티를 사용 할 때 쿼리를 날린다.\n\n\n## 연관 관계의 엔티티를 어떻게 가져올 것인가 \n\n- @OneToMany 기본값 Lazy\n- @ManyToMany 기본값 Eager\n\nPost, Comment 테이블 관계에서 Post에서 Comments데이터를 기본적으로 가져오지 않는다.  \n왜냐하면 Comment에 Row가 얼마나 있을지 모르기 때문이다. 그래서 OneToMany 기본값은 Lazy 이다.  \n\n즉, Post에 있는 데이터만 가져오겠다는 뜻이다.\n\n## 프록시\n\n-  엔티티를 조회할 때 영속성 컨텍스트에 존재하지 않으면 DB콜을 하게 되는데 그런 I/O 발생없이 실제 사용하는 시점까지 미루고 싶을때 사용한다.\n-  즉, 지연로딩을 사용하기 위해 프록시 객체가 필요함\n\n> Memeber member = entityManager.getReference(Member.class, \"member1\");\n\n\n## 참고\n- https://yellowh.tistory.com/125\n- https://jojoldu.tistory.com/165\n","slug":"JPA/JPA N+1 문제 해결 방법","published":1,"updated":"2019-07-25T12:03:31.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids0o000wk0ot1auok7fr","content":"<h1><span id=\"예제-repository\">예제 Repository</span></h1>\n<p><a href=\"https://github.com/biggwang/learnning-subjects/tree/master/spring-jpa-n-plus-one\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">류윤광 Github</a></p>\n<h1><span id=\"학습목표\">학습목표</span></h1>\n<ul>\n<li>N+1 문제가 무엇인지 안다.</li>\n<li>그것을 해결하기 위한 방법이 어떤것이 있으면 각 방법에 장단점을 안다.</li>\n<li>실무에 정확히 적용 할 줄 안다.</li>\n</ul>\n<h1><span id=\"우선-junit에-테스트-한다면-아래-사항을-주의-하자\">우선 junit에 테스트 한다면 아래 사항을 주의 하자</span></h1>\n<ul>\n<li>junit은 기본적으로 테스트가 끝나면 rollback 되므로 그 영향으로 JPA에 영속성 컨텍스트에서 실행해야 할 쿼리를 날리지 않을 수 있다 어차피 롤백 될것이기 때문에 @Rollback(false)를 활용 하자</li>\n<li>하나의 테스트 메소드 내에서 save하고 select하면 pxoy initialize session 에러를 접할 수 있는데 그때는 @Transactional 를 사용하자</li>\n</ul>\n<h1><span id=\"n-1-문제\">N + 1 문제</span></h1>\n<ul>\n<li>영속성 컨텍스트에 <strong>지연로딩(Lazy Loading)</strong> 때문에 발생하는 현상이다.</li>\n<li>A와 B테이블이 서로 1 to n 으로 연관관계가 있다고 하자.<br>\n쿼리로 따지면 조인하여 한번에 가져오고 싶은데 실제 사용 할 때마다 연관된 B테이블에 계속 쿼리를 날리는 것이다.</li>\n<li>B테이블에 100개의 row가 있다면 100번을 날리는 것이다.</li>\n<li>아래를 보자</li>\n</ul>\n<img src=\"/2019/07/10/JPA/JPA%20N+1%20문제%20해결%20방법/jpa_n_plus_one.jpg\">  \n<p>총 11개의 쿼리가 날라갔다.</p>\n<ul>\n<li>A 테이블 select 1개</li>\n<li>B 테이블 select 10개</li>\n</ul>\n<p>A 테이블만 조회</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Teacher&gt; teacherList = teacherRepository.findAll();</span><br></pre></td></tr></table></figure>\n<p>하지만 B테이블에 정보를 원한건 아니었고 @OneToMany는 FetchType이 기본적으로 Lazy이므로 B테이블 데이터는 쿼리를 날리지 않는다. 대신 프로직시 객체를 가지고 있다.</p>\n<p>이제 실제 B테이블을 사용 하려고 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; nameList = teacherList.stream()</span><br><span class=\"line\">   .map(teacher -&gt; teacher.getStudents().get(<span class=\"number\">0</span>).getName())</span><br><span class=\"line\">   .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p>여기서 teacherList에 갯수가 만큰 select 쿼리가 발생하는 것이다.<br>\n이 부분에서 n+1 문제가 발생했다고 하는 것이다.<br>\n그렇다면 어떤 방법으로 해결 할 수 있을까?</p>\n<h2><span id=\"해결방법-1-fetch-join\">해결방법 1 fetch join</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TeacherRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">Teacher</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Query</span>(<span class=\"string\">\"select t from Teacher t join fetch t.students\"</span>)</span><br><span class=\"line\">    <span class=\"function\">List&lt;Teacher&gt; <span class=\"title\">findAllJoinFetch</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/10/JPA/JPA%20N+1%20문제%20해결%20방법/jpa_fetch_join.jpg\">  \n<p>한번에 가져오기 위해 JPA가 쿼리를 만들어서 가져오게 한다. 이후에 말하겠지만 fetch join 은 inner join을 사용한다.</p>\n<blockquote>\n<p>TODO QueryDSL로도 fetch join 해보기</p>\n</blockquote>\n<h3><span id=\"fetch-join에-문제점-불필요한-쿼리를-발생시킨다\">fetch join에 문제점 - 불필요한 쿼리를 발생시킨다.</span></h3>\n<blockquote>\n<p>TODO fetch join에 한계를 보여 줄 수 있는 코드 작성</p>\n</blockquote>\n<h2><span id=\"해결방법-2-entitygraph\">해결방법 2 @EntityGraph</span></h2>\n<p>내가 Eager로 가져오고 싶은것만 가져 올 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TeacherRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">Teacher</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@EntityGraph</span>(attributePaths = <span class=\"string\">\"students\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Query</span>(<span class=\"string\">\"select t from Teacher t\"</span>)</span><br><span class=\"line\">    <span class=\"function\">List&lt;Teacher&gt; <span class=\"title\">findAllEntityGraph</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/10/JPA/JPA%20N+1%20문제%20해결%20방법/jpa_entity_graph.jpg\">  \n<h3><span id=\"entitygraph-사용-주의사항-outerjoin-그리고-중복\">@EntityGraph 사용 주의사항 - OuterJoin 그리고 중복</span></h3>\n<p>@EntityGraph는 OuterJoin을 사용하기 때문에 중복 데이터가 들어 올수 있는데 그것은 아래와 같이 Set을 통해 중복을 제거 할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"teacher\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Teacher</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OneToMany</span>(fetch = FetchType.EAGER, cascade = CascadeType.ALL)</span><br><span class=\"line\">    <span class=\"meta\">@JoinColumn</span>(name=<span class=\"string\">\"teacher_id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;Student&gt; students = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4><span id=\"하지만-어쨌든-불필요한-쿼리\">하지만 어쨌든 불필요한 쿼리</span></h4>\n<p>해당 방법은 Java에서 중복을 제거한거고 DB에 불필요한 쿼리를 날린건 똑같다.<br>\n애초에 OuterJoin을 안쓰도록 노력하는게 좋을것 같다.</p>\n<h1><span id=\"지연로딩과-즉시로딩-개념\">지연로딩과 즉시로딩 개념</span></h1>\n<h2><span id=\"즉시로딩-eager\">즉시로딩 (EAGER)</span></h2>\n<ul>\n<li>@ManyToOne 에서 기본값</li>\n<li>연관된 엔티티에 모든 데이터를 DB 콜하여 한꺼번에 가져온다.</li>\n</ul>\n<h2><span id=\"지연로딩-lazy\">지연로딩 (LAZY)</span></h2>\n<ul>\n<li>A 엔티티에 연관된 B 엔티티 정보가 있을때 A 엔티티 정보만 조회 하면 비효율적이므로 로딩을 지연하여 실제 사용할 때 데이터를 조회 한다.</li>\n<li>실제 사용 할때는 B 엔티티 정보를 사용하고자 할 때 실제 쿼리가 DB에 날리게 된다.</li>\n<li>A 엔티티에서 연관된 B 엔티티 정보는 Proxy 형태로 (디버그로 보면 jvst 문자가 포함됨) 가지고 있다가 실제로 B 엔티티를 사용 할 때 쿼리를 날린다.</li>\n</ul>\n<h2><span id=\"연관-관계의-엔티티를-어떻게-가져올-것인가\">연관 관계의 엔티티를 어떻게 가져올 것인가</span></h2>\n<ul>\n<li>@OneToMany 기본값 Lazy</li>\n<li>@ManyToMany 기본값 Eager</li>\n</ul>\n<p>Post, Comment 테이블 관계에서 Post에서 Comments데이터를 기본적으로 가져오지 않는다.<br>\n왜냐하면 Comment에 Row가 얼마나 있을지 모르기 때문이다. 그래서 OneToMany 기본값은 Lazy 이다.</p>\n<p>즉, Post에 있는 데이터만 가져오겠다는 뜻이다.</p>\n<h2><span id=\"프록시\">프록시</span></h2>\n<ul>\n<li>엔티티를 조회할 때 영속성 컨텍스트에 존재하지 않으면 DB콜을 하게 되는데 그런 I/O 발생없이 실제 사용하는 시점까지 미루고 싶을때 사용한다.</li>\n<li>즉, 지연로딩을 사용하기 위해 프록시 객체가 필요함</li>\n</ul>\n<blockquote>\n<p>Memeber member = entityManager.getReference(Member.class, “member1”);</p>\n</blockquote>\n<h2><span id=\"참고\">참고</span></h2>\n<ul>\n<li><a href=\"https://yellowh.tistory.com/125\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://yellowh.tistory.com/125</a></li>\n<li><a href=\"https://jojoldu.tistory.com/165\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://jojoldu.tistory.com/165</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>예제 Repository</h1>\n<p><a href=\"https://github.com/biggwang/learnning-subjects/tree/master/spring-jpa-n-plus-one\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">류윤광 Github</a></p>\n<h1>학습목표</h1>\n<ul>\n<li>N+1 문제가 무엇인지 안다.</li>\n<li>그것을 해결하기 위한 방법이 어떤것이 있으면 각 방법에 장단점을 안다.</li>\n<li>실무에 정확히 적용 할 줄 안다.</li>\n</ul>\n<h1>우선 junit에 테스트 한다면 아래 사항을 주의 하자</h1>\n<ul>\n<li>junit은 기본적으로 테스트가 끝나면 rollback 되므로 그 영향으로 JPA에 영속성 컨텍스트에서 실행해야 할 쿼리를 날리지 않을 수 있다 어차피 롤백 될것이기 때문에 @Rollback(false)를 활용 하자</li>\n<li>하나의 테스트 메소드 내에서 save하고 select하면 pxoy initialize session 에러를 접할 수 있는데 그때는 @Transactional 를 사용하자</li>\n</ul>\n<h1>N + 1 문제</h1>\n<ul>\n<li>영속성 컨텍스트에 <strong>지연로딩(Lazy Loading)</strong> 때문에 발생하는 현상이다.</li>\n<li>A와 B테이블이 서로 1 to n 으로 연관관계가 있다고 하자.<br>\n쿼리로 따지면 조인하여 한번에 가져오고 싶은데 실제 사용 할 때마다 연관된 B테이블에 계속 쿼리를 날리는 것이다.</li>\n<li>B테이블에 100개의 row가 있다면 100번을 날리는 것이다.</li>\n<li>아래를 보자</li>\n</ul>\n<img src=\"/2019/07/10/JPA/JPA%20N+1%20문제%20해결%20방법/jpa_n_plus_one.jpg\">  \n<p>총 11개의 쿼리가 날라갔다.</p>\n<ul>\n<li>A 테이블 select 1개</li>\n<li>B 테이블 select 10개</li>\n</ul>\n<p>A 테이블만 조회</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;Teacher&gt; teacherList = teacherRepository.findAll();</span><br></pre></td></tr></table></figure>\n<p>하지만 B테이블에 정보를 원한건 아니었고 @OneToMany는 FetchType이 기본적으로 Lazy이므로 B테이블 데이터는 쿼리를 날리지 않는다. 대신 프로직시 객체를 가지고 있다.</p>\n<p>이제 실제 B테이블을 사용 하려고 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; nameList = teacherList.stream()</span><br><span class=\"line\">   .map(teacher -&gt; teacher.getStudents().get(<span class=\"number\">0</span>).getName())</span><br><span class=\"line\">   .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>\n<p>여기서 teacherList에 갯수가 만큰 select 쿼리가 발생하는 것이다.<br>\n이 부분에서 n+1 문제가 발생했다고 하는 것이다.<br>\n그렇다면 어떤 방법으로 해결 할 수 있을까?</p>\n<h2>해결방법 1 fetch join</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TeacherRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">Teacher</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Query</span>(<span class=\"string\">\"select t from Teacher t join fetch t.students\"</span>)</span><br><span class=\"line\">    <span class=\"function\">List&lt;Teacher&gt; <span class=\"title\">findAllJoinFetch</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/10/JPA/JPA%20N+1%20문제%20해결%20방법/jpa_fetch_join.jpg\">  \n<p>한번에 가져오기 위해 JPA가 쿼리를 만들어서 가져오게 한다. 이후에 말하겠지만 fetch join 은 inner join을 사용한다.</p>\n<blockquote>\n<p>TODO QueryDSL로도 fetch join 해보기</p>\n</blockquote>\n<h3>fetch join에 문제점 - 불필요한 쿼리를 발생시킨다.</h3>\n<blockquote>\n<p>TODO fetch join에 한계를 보여 줄 수 있는 코드 작성</p>\n</blockquote>\n<h2>해결방법 2 @EntityGraph</h2>\n<p>내가 Eager로 가져오고 싶은것만 가져 올 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">TeacherRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">Teacher</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@EntityGraph</span>(attributePaths = <span class=\"string\">\"students\"</span>)</span><br><span class=\"line\">    <span class=\"meta\">@Query</span>(<span class=\"string\">\"select t from Teacher t\"</span>)</span><br><span class=\"line\">    <span class=\"function\">List&lt;Teacher&gt; <span class=\"title\">findAllEntityGraph</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/10/JPA/JPA%20N+1%20문제%20해결%20방법/jpa_entity_graph.jpg\">  \n<h3>@EntityGraph 사용 주의사항 - OuterJoin 그리고 중복</h3>\n<p>@EntityGraph는 OuterJoin을 사용하기 때문에 중복 데이터가 들어 올수 있는데 그것은 아래와 같이 Set을 통해 중복을 제거 할 수 있다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Entity</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@NoArgsConstructor</span></span><br><span class=\"line\"><span class=\"meta\">@Table</span>(name = <span class=\"string\">\"teacher\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Teacher</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@OneToMany</span>(fetch = FetchType.EAGER, cascade = CascadeType.ALL)</span><br><span class=\"line\">    <span class=\"meta\">@JoinColumn</span>(name=<span class=\"string\">\"teacher_id\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Set&lt;Student&gt; students = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4>하지만 어쨌든 불필요한 쿼리</h4>\n<p>해당 방법은 Java에서 중복을 제거한거고 DB에 불필요한 쿼리를 날린건 똑같다.<br>\n애초에 OuterJoin을 안쓰도록 노력하는게 좋을것 같다.</p>\n<h1>지연로딩과 즉시로딩 개념</h1>\n<h2>즉시로딩 (EAGER)</h2>\n<ul>\n<li>@ManyToOne 에서 기본값</li>\n<li>연관된 엔티티에 모든 데이터를 DB 콜하여 한꺼번에 가져온다.</li>\n</ul>\n<h2>지연로딩 (LAZY)</h2>\n<ul>\n<li>A 엔티티에 연관된 B 엔티티 정보가 있을때 A 엔티티 정보만 조회 하면 비효율적이므로 로딩을 지연하여 실제 사용할 때 데이터를 조회 한다.</li>\n<li>실제 사용 할때는 B 엔티티 정보를 사용하고자 할 때 실제 쿼리가 DB에 날리게 된다.</li>\n<li>A 엔티티에서 연관된 B 엔티티 정보는 Proxy 형태로 (디버그로 보면 jvst 문자가 포함됨) 가지고 있다가 실제로 B 엔티티를 사용 할 때 쿼리를 날린다.</li>\n</ul>\n<h2>연관 관계의 엔티티를 어떻게 가져올 것인가</h2>\n<ul>\n<li>@OneToMany 기본값 Lazy</li>\n<li>@ManyToMany 기본값 Eager</li>\n</ul>\n<p>Post, Comment 테이블 관계에서 Post에서 Comments데이터를 기본적으로 가져오지 않는다.<br>\n왜냐하면 Comment에 Row가 얼마나 있을지 모르기 때문이다. 그래서 OneToMany 기본값은 Lazy 이다.</p>\n<p>즉, Post에 있는 데이터만 가져오겠다는 뜻이다.</p>\n<h2>프록시</h2>\n<ul>\n<li>엔티티를 조회할 때 영속성 컨텍스트에 존재하지 않으면 DB콜을 하게 되는데 그런 I/O 발생없이 실제 사용하는 시점까지 미루고 싶을때 사용한다.</li>\n<li>즉, 지연로딩을 사용하기 위해 프록시 객체가 필요함</li>\n</ul>\n<blockquote>\n<p>Memeber member = entityManager.getReference(Member.class, “member1”);</p>\n</blockquote>\n<h2>참고</h2>\n<ul>\n<li><a href=\"https://yellowh.tistory.com/125\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://yellowh.tistory.com/125</a></li>\n<li><a href=\"https://jojoldu.tistory.com/165\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">https://jojoldu.tistory.com/165</a></li>\n</ul>\n"},{"title":"JPA 영속성 컨텍스트 엔티티 관리 방법","catalog":true,"date":"2019-07-27T08:35:55.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["JPA"],"_content":"\n# 학습목표\n- 영속성 컨텍스트가 엔티티를 생성,수정,삭제 하는 동작을 파악하여 실무 개발할때 삽질을 줄이고 불필요한 쿼리를 발생시키지 않게 한다.\n- JPA를 활용하여 성능향상을 시킨다.\n\n# 들어가며\n관련 샘플 코드는 [Github](https://github.com/biggwang/learnning-subjects/tree/master/jpa-persistcontext)에 있습니다.  \n영속성 컨텍스트에 대한 엔티티 관리를 다양한 예제를 만들어보고 피드백을 받아 앞으로 계속 업데이트를 하도록 하겠습니다.\n \n\n# 1차 캐시\n~~~ java\nMember member = new Member();\nmember.setId(\"member1\");\nmember.setUserName(\"회원1\");\n\n// 1차 캐쉬 저장, 영속성 컨텍스트에 저장 됨\nEntityManager em = emf.createEntityManager();\nem.getTransaction().begin();\nem.persist(member);\n\n// 1차 캐쉬 조회\nMember findMember = em.find(Member.class), \"member1\");\n\nem.getTransaction().end();\n~~~\n \nDB로 가기전에 먼저 영속성 컨텍스트에 \"member1\"에 해당하는 데이터가 있으면 우선 조회 한다.  \n단, 한 트랜잭션내에서만 1차 캐쉬가 보관되어 지는 것이다. 또 동시에 100명에 접속자가 있다면 100개에 영속성 컨텍스트가 생기는 것이며 서로 공유 되지 않는다. \n \n그러면 1차 캐쉬에 없는 데이터는 어떻게 될까??  \n그때는 DB에서 조회하고 가져온 데이터를 1차 캐쉬에 저장하고 그리고 그 값을 반환한다.\n\n# 동일성 보장\n\n~~~ java\nMember a = em.find(Member.class), \"member1\");\nMember b = em.find(Member.class), \"member1\");\n\na == b 하면 true 즉, heap 같은 주소를 가지고 있는 객체라는 뜻인데 1차 캐쉬에 보관 된 데이터를 반환하였기 때문에 같은 주소를 가진 데이터 인것이다.\n\n~~~\n\n# 쓰기 지연\n\nDB 트랜잭션 개념이다. \n엔티티매니저에 의해서 관리되고 있는 엔티에서 쿼리를 막날려도 DB에 날라가지 않는다. 왜냐면 트랜잭션 상태에서 아직 커밋되지 않았기 때문이다.  \nflush를 하거나 트랜잭션이 끝나면 그때 DB에 반영된다. 정확히 말하면 트랜잭션이 끝나기전에 JPA가 flush를 하여 영속성 컨텍스트 관리되는 엔티티와 DB와 비교후 변경된것이 있다면 쿼리를 생성하여 쓰기지연 SQL 저장소에 보관하고 그 쿼리를 DB에 반영하고 트랜잭션이 끝나면 커밋이 되어 최종 반영 되는 것이다.\n\n~~~ java\n@Test\npublic void 쓰기지연_INSERT_동작_테스트() {\n    EntityManager em = emf.createEntityManager();\n    EntityTransaction transaction = em.getTransaction();\n\n    transaction.begin();\n\n    Teacher teacher1 = Teacher.builder().classGroupName(\"2학년 1반\").build();\n    em.persist(teacher1);\n    System.out.println(\"teacher1 저장?\");\n    \n    Teacher teacher2 = Teacher.builder().classGroupName(\"2학년 2반\").build();\n    em.persist(teacher2);\n    System.out.println(\"teacher2 저장?\");\n    \n    Teacher teacher3 = Teacher.builder().classGroupName(\"2학년 3반\").build();\n    em.persist(teacher3);\n    System.out.println(\"teacher3 저장?\");\n\n    System.out.println(\"여기서 실제 쿼리 날리지롱~! commit 전\");\n    transaction.commit();\n    System.out.println(\"여기서 실제 쿼리 날리지롱~! commit 후\");\n}\n~~~\n\n{% asset_img \"write-lazy.png\" %}\n\n\n## 객체지향 쿼리(JPQL, Criteria, QueryDSL) 사용시에는 flush가 발생\n밑에 코드에서 query.getResultList() 를 하는 순간 영속화(perist) 3번 하였던 것이 우선 insert를 3번 날리어 DB에 반영하게 됩니다.  \n왜냐면 그다음 코드에서 select 구문을 날리는데 아무리 쓰기지연이라 하지만 이전에 3개 insert 하는것이 반영이 안되어 select 하는게 의미가 있을까요?? 그래서 JPA에서는 객체지향 쿼리를 사용하게 되면 바로 DB에 반영이 됩니다.\n\n~~~ java\n@Test\npublic void JPQL_사용시_자동_Flush_수행_동작_테스트() {\n    EntityManager em = emf.createEntityManager();\n    EntityTransaction transaction = em.getTransaction();\n\n    transaction.begin();\n\n    Teacher teacher1 = Teacher.builder().name(\"홍길동\").age(32).classGroupName(\"1학년 1반\").build();\n    em.persist(teacher1);\n    System.out.println(\"홍길동 선생님이 등록되었습니다.\");\n\n    Teacher teacher2 = Teacher.builder().name(\"임꺽정\").age(15).classGroupName(\"2학년 7반\").build();\n    em.persist(teacher2);\n    System.out.println(\"임꺽정 선생님이 등록되었습니다.\");\n\n    Teacher teacher3 = Teacher.builder().name(\"성춘향\").age(27).classGroupName(\"3학년 5반\").build();\n    em.persist(teacher3);\n    System.out.println(\"성춘향 선생님이 등록되었습니다.\");\n\n    Query query = em.createQuery(\"select t from Teacher t\", Teacher.class);\n\n    System.out.println(\"객체지향 쿼리를 사용하여 flush를 수행합니다. 1\");\n    List<Teacher> teacherList = query.getResultList();\n\n    transaction.commit();\n}\n~~~\n{% asset_img \"jpql-flush.png\" %}\n\n\n# 변경 감지(Dirty Checking)\n**영속성 컨텍스트에서 관리되는 엔티티인 경우에 엔티티 정보가 변경 되었을때 변경 감지**가 되어 업데이트 쿼리가 만들어집니다. 만들어 지는 과정은 이렇습니다.\n\n- 1차 캐쉬에 존재하는 엔티티와 변경 여부 확인\n- 값이 다르다면 UPDATE 구문을 만들고 쓰기 지연 SQL 저장소에 보관\n- flush 하여 DB 쿼리 날림\n- commit 되면 최종 반영 \n\n\n## UPDATE 구문은 기본적으로 모든 컬럼을 UPDATE 한다.\n\n예를 들어 컬럼이 30개 라면 컬럼 30개에 대한 모든 컬럼을 업데이트 한다.  \n\n~~~ java\n@Test\npublic void 변경감지_동작_테스트() {\n    EntityManager em = emf.createEntityManager();\n    EntityTransaction transaction = em.getTransaction();\n\n    transaction.begin();\n\n    em.persist(Teacher.builder().classGroupName(\"2학년 1반\").build());\n    Teacher teacher1 = em.find(Teacher.class, 1L);\n\n    System.out.println(\"원래 맡은 반: \" + teacher1.getClassGroupName());\n\n    teacher1.setClassGroupName(\"3학년 1반\");\n    System.out.println(\"새롭게 맡은 반: \" + teacher1.getClassGroupName());\n\n    transaction.commit();\n}\n~~~\n\n{% asset_img \"dynamic-update2.png\" %}\n\n모든 컬럼을 업데이트 치는 것이 불필요하다 생각 할 수 있으나 아래와 같은 이점이 있다고 한다.\n- 모든 컬럼을 업데이트 하기 때문에 쿼리가 항상 같아서 DB에 동일한 쿼리를 보낼테고 이는 DB가 쿼리를 캐슁하여 캐슁한 쿼리를 계속 사용 할 수 있다.  \n\n컬럼이 30개이상 되는 엔티티라면 기본값인 모든 컬럼을 업데이트 치는 것보다 @DynamincUpdate 을 사용하여 변경된 컬럼만 업데이트 치는것이 낫다고 한다.\n\n\n## 일부만 UPDATE 하고 싶다면?\n위에서 언급하였지만 @DynamincUpdate 이용해 @Entity 선언한 부분에 넣어주면 되고 위 코드에서 teacher1.setClassGroupName(\"3학년 1반\"); 하게 되면 \"classGroupName\" 컬럼만 업데이트 하게 된다.\n\n{% asset_img \"dynamic-update1.png\" %}\n\n\n\n# [문제] DB에 날리는 쿼리는 몇 번 호출 되었을까?\n~~~ java\n\nAccount account = new Account();\naccount.setUsername(\"ryu\");\naccount.setPassword(\"1111\");\n\nStudy study = new Study();\nstudy.setName(\"Spring Data JPA\");\n\naccount.addStudy(study);\n\nSession session = entityManager.unwrap(Session.class);\nsession.save(account);\nsession.save(study);\n\nAccount yungwang = session.load(Account.class, account.getId());\nyungwang.setUsername(\"gwang\");\nyungwang.setUsername(\"boriswinter\");\nyungwang.setUsername(\"ryu\");\n\n~~~\n\n\n답은 insert 2번이다.  \n\nsession.save(account);\nsession.save(study);  \n\n이부분이 2번 insert 쿼리가 DB로 날라간것이다. 그럼 setUserName 메소드 3번 호출한건 왜 Update가 되지 않지??\n\n바로 이 부분이 Psersist Context에 성능 이점이다.  \n코드를 보면 ryu -> gwang -> boriswinter -> ryu 결국 name은 변하지 않았기 때문에 JPA가 알아서 쿼리를 날리지 않았던 것이다.  \n이부분이 Dirty Checking 했다는 것이고 DB에 쿼리 날리는 것을 최소화 한다는 개념 Write Behind 개념이다.\n\n\n# TODO\n- \n\n\n","source":"_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법.md","raw":"---\ntitle: JPA 영속성 컨텍스트 엔티티 관리 방법\ncatalog: true\ndate: 2019-07-27 17:35:55\nsubtitle: \nheader-img: \"bg_computer.jpg\"\ntags: \n- Learnning\ncatagories:\n- JPA\n---\n\n# 학습목표\n- 영속성 컨텍스트가 엔티티를 생성,수정,삭제 하는 동작을 파악하여 실무 개발할때 삽질을 줄이고 불필요한 쿼리를 발생시키지 않게 한다.\n- JPA를 활용하여 성능향상을 시킨다.\n\n# 들어가며\n관련 샘플 코드는 [Github](https://github.com/biggwang/learnning-subjects/tree/master/jpa-persistcontext)에 있습니다.  \n영속성 컨텍스트에 대한 엔티티 관리를 다양한 예제를 만들어보고 피드백을 받아 앞으로 계속 업데이트를 하도록 하겠습니다.\n \n\n# 1차 캐시\n~~~ java\nMember member = new Member();\nmember.setId(\"member1\");\nmember.setUserName(\"회원1\");\n\n// 1차 캐쉬 저장, 영속성 컨텍스트에 저장 됨\nEntityManager em = emf.createEntityManager();\nem.getTransaction().begin();\nem.persist(member);\n\n// 1차 캐쉬 조회\nMember findMember = em.find(Member.class), \"member1\");\n\nem.getTransaction().end();\n~~~\n \nDB로 가기전에 먼저 영속성 컨텍스트에 \"member1\"에 해당하는 데이터가 있으면 우선 조회 한다.  \n단, 한 트랜잭션내에서만 1차 캐쉬가 보관되어 지는 것이다. 또 동시에 100명에 접속자가 있다면 100개에 영속성 컨텍스트가 생기는 것이며 서로 공유 되지 않는다. \n \n그러면 1차 캐쉬에 없는 데이터는 어떻게 될까??  \n그때는 DB에서 조회하고 가져온 데이터를 1차 캐쉬에 저장하고 그리고 그 값을 반환한다.\n\n# 동일성 보장\n\n~~~ java\nMember a = em.find(Member.class), \"member1\");\nMember b = em.find(Member.class), \"member1\");\n\na == b 하면 true 즉, heap 같은 주소를 가지고 있는 객체라는 뜻인데 1차 캐쉬에 보관 된 데이터를 반환하였기 때문에 같은 주소를 가진 데이터 인것이다.\n\n~~~\n\n# 쓰기 지연\n\nDB 트랜잭션 개념이다. \n엔티티매니저에 의해서 관리되고 있는 엔티에서 쿼리를 막날려도 DB에 날라가지 않는다. 왜냐면 트랜잭션 상태에서 아직 커밋되지 않았기 때문이다.  \nflush를 하거나 트랜잭션이 끝나면 그때 DB에 반영된다. 정확히 말하면 트랜잭션이 끝나기전에 JPA가 flush를 하여 영속성 컨텍스트 관리되는 엔티티와 DB와 비교후 변경된것이 있다면 쿼리를 생성하여 쓰기지연 SQL 저장소에 보관하고 그 쿼리를 DB에 반영하고 트랜잭션이 끝나면 커밋이 되어 최종 반영 되는 것이다.\n\n~~~ java\n@Test\npublic void 쓰기지연_INSERT_동작_테스트() {\n    EntityManager em = emf.createEntityManager();\n    EntityTransaction transaction = em.getTransaction();\n\n    transaction.begin();\n\n    Teacher teacher1 = Teacher.builder().classGroupName(\"2학년 1반\").build();\n    em.persist(teacher1);\n    System.out.println(\"teacher1 저장?\");\n    \n    Teacher teacher2 = Teacher.builder().classGroupName(\"2학년 2반\").build();\n    em.persist(teacher2);\n    System.out.println(\"teacher2 저장?\");\n    \n    Teacher teacher3 = Teacher.builder().classGroupName(\"2학년 3반\").build();\n    em.persist(teacher3);\n    System.out.println(\"teacher3 저장?\");\n\n    System.out.println(\"여기서 실제 쿼리 날리지롱~! commit 전\");\n    transaction.commit();\n    System.out.println(\"여기서 실제 쿼리 날리지롱~! commit 후\");\n}\n~~~\n\n{% asset_img \"write-lazy.png\" %}\n\n\n## 객체지향 쿼리(JPQL, Criteria, QueryDSL) 사용시에는 flush가 발생\n밑에 코드에서 query.getResultList() 를 하는 순간 영속화(perist) 3번 하였던 것이 우선 insert를 3번 날리어 DB에 반영하게 됩니다.  \n왜냐면 그다음 코드에서 select 구문을 날리는데 아무리 쓰기지연이라 하지만 이전에 3개 insert 하는것이 반영이 안되어 select 하는게 의미가 있을까요?? 그래서 JPA에서는 객체지향 쿼리를 사용하게 되면 바로 DB에 반영이 됩니다.\n\n~~~ java\n@Test\npublic void JPQL_사용시_자동_Flush_수행_동작_테스트() {\n    EntityManager em = emf.createEntityManager();\n    EntityTransaction transaction = em.getTransaction();\n\n    transaction.begin();\n\n    Teacher teacher1 = Teacher.builder().name(\"홍길동\").age(32).classGroupName(\"1학년 1반\").build();\n    em.persist(teacher1);\n    System.out.println(\"홍길동 선생님이 등록되었습니다.\");\n\n    Teacher teacher2 = Teacher.builder().name(\"임꺽정\").age(15).classGroupName(\"2학년 7반\").build();\n    em.persist(teacher2);\n    System.out.println(\"임꺽정 선생님이 등록되었습니다.\");\n\n    Teacher teacher3 = Teacher.builder().name(\"성춘향\").age(27).classGroupName(\"3학년 5반\").build();\n    em.persist(teacher3);\n    System.out.println(\"성춘향 선생님이 등록되었습니다.\");\n\n    Query query = em.createQuery(\"select t from Teacher t\", Teacher.class);\n\n    System.out.println(\"객체지향 쿼리를 사용하여 flush를 수행합니다. 1\");\n    List<Teacher> teacherList = query.getResultList();\n\n    transaction.commit();\n}\n~~~\n{% asset_img \"jpql-flush.png\" %}\n\n\n# 변경 감지(Dirty Checking)\n**영속성 컨텍스트에서 관리되는 엔티티인 경우에 엔티티 정보가 변경 되었을때 변경 감지**가 되어 업데이트 쿼리가 만들어집니다. 만들어 지는 과정은 이렇습니다.\n\n- 1차 캐쉬에 존재하는 엔티티와 변경 여부 확인\n- 값이 다르다면 UPDATE 구문을 만들고 쓰기 지연 SQL 저장소에 보관\n- flush 하여 DB 쿼리 날림\n- commit 되면 최종 반영 \n\n\n## UPDATE 구문은 기본적으로 모든 컬럼을 UPDATE 한다.\n\n예를 들어 컬럼이 30개 라면 컬럼 30개에 대한 모든 컬럼을 업데이트 한다.  \n\n~~~ java\n@Test\npublic void 변경감지_동작_테스트() {\n    EntityManager em = emf.createEntityManager();\n    EntityTransaction transaction = em.getTransaction();\n\n    transaction.begin();\n\n    em.persist(Teacher.builder().classGroupName(\"2학년 1반\").build());\n    Teacher teacher1 = em.find(Teacher.class, 1L);\n\n    System.out.println(\"원래 맡은 반: \" + teacher1.getClassGroupName());\n\n    teacher1.setClassGroupName(\"3학년 1반\");\n    System.out.println(\"새롭게 맡은 반: \" + teacher1.getClassGroupName());\n\n    transaction.commit();\n}\n~~~\n\n{% asset_img \"dynamic-update2.png\" %}\n\n모든 컬럼을 업데이트 치는 것이 불필요하다 생각 할 수 있으나 아래와 같은 이점이 있다고 한다.\n- 모든 컬럼을 업데이트 하기 때문에 쿼리가 항상 같아서 DB에 동일한 쿼리를 보낼테고 이는 DB가 쿼리를 캐슁하여 캐슁한 쿼리를 계속 사용 할 수 있다.  \n\n컬럼이 30개이상 되는 엔티티라면 기본값인 모든 컬럼을 업데이트 치는 것보다 @DynamincUpdate 을 사용하여 변경된 컬럼만 업데이트 치는것이 낫다고 한다.\n\n\n## 일부만 UPDATE 하고 싶다면?\n위에서 언급하였지만 @DynamincUpdate 이용해 @Entity 선언한 부분에 넣어주면 되고 위 코드에서 teacher1.setClassGroupName(\"3학년 1반\"); 하게 되면 \"classGroupName\" 컬럼만 업데이트 하게 된다.\n\n{% asset_img \"dynamic-update1.png\" %}\n\n\n\n# [문제] DB에 날리는 쿼리는 몇 번 호출 되었을까?\n~~~ java\n\nAccount account = new Account();\naccount.setUsername(\"ryu\");\naccount.setPassword(\"1111\");\n\nStudy study = new Study();\nstudy.setName(\"Spring Data JPA\");\n\naccount.addStudy(study);\n\nSession session = entityManager.unwrap(Session.class);\nsession.save(account);\nsession.save(study);\n\nAccount yungwang = session.load(Account.class, account.getId());\nyungwang.setUsername(\"gwang\");\nyungwang.setUsername(\"boriswinter\");\nyungwang.setUsername(\"ryu\");\n\n~~~\n\n\n답은 insert 2번이다.  \n\nsession.save(account);\nsession.save(study);  \n\n이부분이 2번 insert 쿼리가 DB로 날라간것이다. 그럼 setUserName 메소드 3번 호출한건 왜 Update가 되지 않지??\n\n바로 이 부분이 Psersist Context에 성능 이점이다.  \n코드를 보면 ryu -> gwang -> boriswinter -> ryu 결국 name은 변하지 않았기 때문에 JPA가 알아서 쿼리를 날리지 않았던 것이다.  \n이부분이 Dirty Checking 했다는 것이고 DB에 쿼리 날리는 것을 최소화 한다는 개념 Write Behind 개념이다.\n\n\n# TODO\n- \n\n\n","slug":"JPA/JPA 영속성 컨텍스트 엔티티 관리 방법","published":1,"updated":"2019-07-27T13:26:34.907Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids0q000yk0ot7jlol0cv","content":"<h1><span id=\"학습목표\">학습목표</span></h1>\n<ul>\n<li>영속성 컨텍스트가 엔티티를 생성,수정,삭제 하는 동작을 파악하여 실무 개발할때 삽질을 줄이고 불필요한 쿼리를 발생시키지 않게 한다.</li>\n<li>JPA를 활용하여 성능향상을 시킨다.</li>\n</ul>\n<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>관련 샘플 코드는 <a href=\"https://github.com/biggwang/learnning-subjects/tree/master/jpa-persistcontext\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Github</a>에 있습니다.<br>\n영속성 컨텍스트에 대한 엔티티 관리를 다양한 예제를 만들어보고 피드백을 받아 앞으로 계속 업데이트를 하도록 하겠습니다.</p>\n<h1><span id=\"1차-캐시\">1차 캐시</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Member member = <span class=\"keyword\">new</span> Member();</span><br><span class=\"line\">member.setId(<span class=\"string\">\"member1\"</span>);</span><br><span class=\"line\">member.setUserName(<span class=\"string\">\"회원1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1차 캐쉬 저장, 영속성 컨텍스트에 저장 됨</span></span><br><span class=\"line\">EntityManager em = emf.createEntityManager();</span><br><span class=\"line\">em.getTransaction().begin();</span><br><span class=\"line\">em.persist(member);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1차 캐쉬 조회</span></span><br><span class=\"line\">Member findMember = em.find(Member.class), <span class=\"string\">\"member1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">em.getTransaction().end();</span><br></pre></td></tr></table></figure>\n<p>DB로 가기전에 먼저 영속성 컨텍스트에 &quot;member1&quot;에 해당하는 데이터가 있으면 우선 조회 한다.<br>\n단, 한 트랜잭션내에서만 1차 캐쉬가 보관되어 지는 것이다. 또 동시에 100명에 접속자가 있다면 100개에 영속성 컨텍스트가 생기는 것이며 서로 공유 되지 않는다.</p>\n<p>그러면 1차 캐쉬에 없는 데이터는 어떻게 될까??<br>\n그때는 DB에서 조회하고 가져온 데이터를 1차 캐쉬에 저장하고 그리고 그 값을 반환한다.</p>\n<h1><span id=\"동일성-보장\">동일성 보장</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Member a = em.find(Member.class), <span class=\"string\">\"member1\"</span>);</span><br><span class=\"line\">Member b = em.find(Member.class), <span class=\"string\">\"member1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">a == b 하면 <span class=\"keyword\">true</span> 즉, heap 같은 주소를 가지고 있는 객체라는 뜻인데 <span class=\"number\">1</span>차 캐쉬에 보관 된 데이터를 반환하였기 때문에 같은 주소를 가진 데이터 인것이다.</span><br></pre></td></tr></table></figure>\n<h1><span id=\"쓰기-지연\">쓰기 지연</span></h1>\n<p>DB 트랜잭션 개념이다.<br>\n엔티티매니저에 의해서 관리되고 있는 엔티에서 쿼리를 막날려도 DB에 날라가지 않는다. 왜냐면 트랜잭션 상태에서 아직 커밋되지 않았기 때문이다.<br>\nflush를 하거나 트랜잭션이 끝나면 그때 DB에 반영된다. 정확히 말하면 트랜잭션이 끝나기전에 JPA가 flush를 하여 영속성 컨텍스트 관리되는 엔티티와 DB와 비교후 변경된것이 있다면 쿼리를 생성하여 쓰기지연 SQL 저장소에 보관하고 그 쿼리를 DB에 반영하고 트랜잭션이 끝나면 커밋이 되어 최종 반영 되는 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 쓰기지연_INSERT_동작_테스트() &#123;</span><br><span class=\"line\">    EntityManager em = emf.createEntityManager();</span><br><span class=\"line\">    EntityTransaction transaction = em.getTransaction();</span><br><span class=\"line\"></span><br><span class=\"line\">    transaction.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    Teacher teacher1 = Teacher.builder().classGroupName(<span class=\"string\">\"2학년 1반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"teacher1 저장?\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Teacher teacher2 = Teacher.builder().classGroupName(<span class=\"string\">\"2학년 2반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher2);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"teacher2 저장?\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Teacher teacher3 = Teacher.builder().classGroupName(<span class=\"string\">\"2학년 3반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher3);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"teacher3 저장?\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"여기서 실제 쿼리 날리지롱~! commit 전\"</span>);</span><br><span class=\"line\">    transaction.commit();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"여기서 실제 쿼리 날리지롱~! commit 후\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/27/JPA/JPA%20영속성%20컨텍스트%20엔티티%20관리%20방법/write-lazy.png\">\n<h2><span id=\"객체지향-쿼리jpql-criteria-querydsl-사용시에는-flush가-발생\">객체지향 쿼리(JPQL, Criteria, QueryDSL) 사용시에는 flush가 발생</span></h2>\n<p>밑에 코드에서 query.getResultList() 를 하는 순간 영속화(perist) 3번 하였던 것이 우선 insert를 3번 날리어 DB에 반영하게 됩니다.<br>\n왜냐면 그다음 코드에서 select 구문을 날리는데 아무리 쓰기지연이라 하지만 이전에 3개 insert 하는것이 반영이 안되어 select 하는게 의미가 있을까요?? 그래서 JPA에서는 객체지향 쿼리를 사용하게 되면 바로 DB에 반영이 됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> JPQL_사용시_자동_Flush_수행_동작_테스트() &#123;</span><br><span class=\"line\">    EntityManager em = emf.createEntityManager();</span><br><span class=\"line\">    EntityTransaction transaction = em.getTransaction();</span><br><span class=\"line\"></span><br><span class=\"line\">    transaction.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    Teacher teacher1 = Teacher.builder().name(<span class=\"string\">\"홍길동\"</span>).age(<span class=\"number\">32</span>).classGroupName(<span class=\"string\">\"1학년 1반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"홍길동 선생님이 등록되었습니다.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Teacher teacher2 = Teacher.builder().name(<span class=\"string\">\"임꺽정\"</span>).age(<span class=\"number\">15</span>).classGroupName(<span class=\"string\">\"2학년 7반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher2);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"임꺽정 선생님이 등록되었습니다.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Teacher teacher3 = Teacher.builder().name(<span class=\"string\">\"성춘향\"</span>).age(<span class=\"number\">27</span>).classGroupName(<span class=\"string\">\"3학년 5반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher3);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"성춘향 선생님이 등록되었습니다.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Query query = em.createQuery(<span class=\"string\">\"select t from Teacher t\"</span>, Teacher.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"객체지향 쿼리를 사용하여 flush를 수행합니다. 1\"</span>);</span><br><span class=\"line\">    List&lt;Teacher&gt; teacherList = query.getResultList();</span><br><span class=\"line\"></span><br><span class=\"line\">    transaction.commit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/27/JPA/JPA%20영속성%20컨텍스트%20엔티티%20관리%20방법/jpql-flush.png\">\n<h1><span id=\"변경-감지dirty-checking\">변경 감지(Dirty Checking)</span></h1>\n<p><strong>영속성 컨텍스트에서 관리되는 엔티티인 경우에 엔티티 정보가 변경 되었을때 변경 감지</strong>가 되어 업데이트 쿼리가 만들어집니다. 만들어 지는 과정은 이렇습니다.</p>\n<ul>\n<li>1차 캐쉬에 존재하는 엔티티와 변경 여부 확인</li>\n<li>값이 다르다면 UPDATE 구문을 만들고 쓰기 지연 SQL 저장소에 보관</li>\n<li>flush 하여 DB 쿼리 날림</li>\n<li>commit 되면 최종 반영</li>\n</ul>\n<h2><span id=\"update-구문은-기본적으로-모든-컬럼을-update-한다\">UPDATE 구문은 기본적으로 모든 컬럼을 UPDATE 한다.</span></h2>\n<p>예를 들어 컬럼이 30개 라면 컬럼 30개에 대한 모든 컬럼을 업데이트 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 변경감지_동작_테스트() &#123;</span><br><span class=\"line\">    EntityManager em = emf.createEntityManager();</span><br><span class=\"line\">    EntityTransaction transaction = em.getTransaction();</span><br><span class=\"line\"></span><br><span class=\"line\">    transaction.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    em.persist(Teacher.builder().classGroupName(<span class=\"string\">\"2학년 1반\"</span>).build());</span><br><span class=\"line\">    Teacher teacher1 = em.find(Teacher.class, <span class=\"number\">1L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"원래 맡은 반: \"</span> + teacher1.getClassGroupName());</span><br><span class=\"line\"></span><br><span class=\"line\">    teacher1.setClassGroupName(<span class=\"string\">\"3학년 1반\"</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"새롭게 맡은 반: \"</span> + teacher1.getClassGroupName());</span><br><span class=\"line\"></span><br><span class=\"line\">    transaction.commit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/27/JPA/JPA%20영속성%20컨텍스트%20엔티티%20관리%20방법/dynamic-update2.png\">\n<p>모든 컬럼을 업데이트 치는 것이 불필요하다 생각 할 수 있으나 아래와 같은 이점이 있다고 한다.</p>\n<ul>\n<li>모든 컬럼을 업데이트 하기 때문에 쿼리가 항상 같아서 DB에 동일한 쿼리를 보낼테고 이는 DB가 쿼리를 캐슁하여 캐슁한 쿼리를 계속 사용 할 수 있다.</li>\n</ul>\n<p>컬럼이 30개이상 되는 엔티티라면 기본값인 모든 컬럼을 업데이트 치는 것보다 @DynamincUpdate 을 사용하여 변경된 컬럼만 업데이트 치는것이 낫다고 한다.</p>\n<h2><span id=\"일부만-update-하고-싶다면\">일부만 UPDATE 하고 싶다면?</span></h2>\n<p>위에서 언급하였지만 @DynamincUpdate 이용해 @Entity 선언한 부분에 넣어주면 되고 위 코드에서 teacher1.setClassGroupName(“3학년 1반”); 하게 되면 “classGroupName” 컬럼만 업데이트 하게 된다.</p>\n<img src=\"/2019/07/27/JPA/JPA%20영속성%20컨텍스트%20엔티티%20관리%20방법/dynamic-update1.png\">\n<h1><span id=\"문제-db에-날리는-쿼리는-몇-번-호출-되었을까\">[문제] DB에 날리는 쿼리는 몇 번 호출 되었을까?</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Account account = <span class=\"keyword\">new</span> Account();</span><br><span class=\"line\">account.setUsername(<span class=\"string\">\"ryu\"</span>);</span><br><span class=\"line\">account.setPassword(<span class=\"string\">\"1111\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Study study = <span class=\"keyword\">new</span> Study();</span><br><span class=\"line\">study.setName(<span class=\"string\">\"Spring Data JPA\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">account.addStudy(study);</span><br><span class=\"line\"></span><br><span class=\"line\">Session session = entityManager.unwrap(Session.class);</span><br><span class=\"line\">session.save(account);</span><br><span class=\"line\">session.save(study);</span><br><span class=\"line\"></span><br><span class=\"line\">Account yungwang = session.load(Account.class, account.getId());</span><br><span class=\"line\">yungwang.setUsername(<span class=\"string\">\"gwang\"</span>);</span><br><span class=\"line\">yungwang.setUsername(<span class=\"string\">\"boriswinter\"</span>);</span><br><span class=\"line\">yungwang.setUsername(<span class=\"string\">\"ryu\"</span>);</span><br></pre></td></tr></table></figure>\n<p>답은 insert 2번이다.</p>\n<p>session.save(account);<br>\nsession.save(study);</p>\n<p>이부분이 2번 insert 쿼리가 DB로 날라간것이다. 그럼 setUserName 메소드 3번 호출한건 왜 Update가 되지 않지??</p>\n<p>바로 이 부분이 Psersist Context에 성능 이점이다.<br>\n코드를 보면 ryu -&gt; gwang -&gt; boriswinter -&gt; ryu 결국 name은 변하지 않았기 때문에 JPA가 알아서 쿼리를 날리지 않았던 것이다.<br>\n이부분이 Dirty Checking 했다는 것이고 DB에 쿼리 날리는 것을 최소화 한다는 개념 Write Behind 개념이다.</p>\n<h1><span id=\"todo\">TODO</span></h1>\n<ul>\n<li></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1>학습목표</h1>\n<ul>\n<li>영속성 컨텍스트가 엔티티를 생성,수정,삭제 하는 동작을 파악하여 실무 개발할때 삽질을 줄이고 불필요한 쿼리를 발생시키지 않게 한다.</li>\n<li>JPA를 활용하여 성능향상을 시킨다.</li>\n</ul>\n<h1>들어가며</h1>\n<p>관련 샘플 코드는 <a href=\"https://github.com/biggwang/learnning-subjects/tree/master/jpa-persistcontext\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Github</a>에 있습니다.<br>\n영속성 컨텍스트에 대한 엔티티 관리를 다양한 예제를 만들어보고 피드백을 받아 앞으로 계속 업데이트를 하도록 하겠습니다.</p>\n<h1>1차 캐시</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Member member = <span class=\"keyword\">new</span> Member();</span><br><span class=\"line\">member.setId(<span class=\"string\">\"member1\"</span>);</span><br><span class=\"line\">member.setUserName(<span class=\"string\">\"회원1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1차 캐쉬 저장, 영속성 컨텍스트에 저장 됨</span></span><br><span class=\"line\">EntityManager em = emf.createEntityManager();</span><br><span class=\"line\">em.getTransaction().begin();</span><br><span class=\"line\">em.persist(member);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1차 캐쉬 조회</span></span><br><span class=\"line\">Member findMember = em.find(Member.class), <span class=\"string\">\"member1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">em.getTransaction().end();</span><br></pre></td></tr></table></figure>\n<p>DB로 가기전에 먼저 영속성 컨텍스트에 &quot;member1&quot;에 해당하는 데이터가 있으면 우선 조회 한다.<br>\n단, 한 트랜잭션내에서만 1차 캐쉬가 보관되어 지는 것이다. 또 동시에 100명에 접속자가 있다면 100개에 영속성 컨텍스트가 생기는 것이며 서로 공유 되지 않는다.</p>\n<p>그러면 1차 캐쉬에 없는 데이터는 어떻게 될까??<br>\n그때는 DB에서 조회하고 가져온 데이터를 1차 캐쉬에 저장하고 그리고 그 값을 반환한다.</p>\n<h1>동일성 보장</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Member a = em.find(Member.class), <span class=\"string\">\"member1\"</span>);</span><br><span class=\"line\">Member b = em.find(Member.class), <span class=\"string\">\"member1\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">a == b 하면 <span class=\"keyword\">true</span> 즉, heap 같은 주소를 가지고 있는 객체라는 뜻인데 <span class=\"number\">1</span>차 캐쉬에 보관 된 데이터를 반환하였기 때문에 같은 주소를 가진 데이터 인것이다.</span><br></pre></td></tr></table></figure>\n<h1>쓰기 지연</h1>\n<p>DB 트랜잭션 개념이다.<br>\n엔티티매니저에 의해서 관리되고 있는 엔티에서 쿼리를 막날려도 DB에 날라가지 않는다. 왜냐면 트랜잭션 상태에서 아직 커밋되지 않았기 때문이다.<br>\nflush를 하거나 트랜잭션이 끝나면 그때 DB에 반영된다. 정확히 말하면 트랜잭션이 끝나기전에 JPA가 flush를 하여 영속성 컨텍스트 관리되는 엔티티와 DB와 비교후 변경된것이 있다면 쿼리를 생성하여 쓰기지연 SQL 저장소에 보관하고 그 쿼리를 DB에 반영하고 트랜잭션이 끝나면 커밋이 되어 최종 반영 되는 것이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 쓰기지연_INSERT_동작_테스트() &#123;</span><br><span class=\"line\">    EntityManager em = emf.createEntityManager();</span><br><span class=\"line\">    EntityTransaction transaction = em.getTransaction();</span><br><span class=\"line\"></span><br><span class=\"line\">    transaction.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    Teacher teacher1 = Teacher.builder().classGroupName(<span class=\"string\">\"2학년 1반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"teacher1 저장?\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Teacher teacher2 = Teacher.builder().classGroupName(<span class=\"string\">\"2학년 2반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher2);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"teacher2 저장?\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    Teacher teacher3 = Teacher.builder().classGroupName(<span class=\"string\">\"2학년 3반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher3);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"teacher3 저장?\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"여기서 실제 쿼리 날리지롱~! commit 전\"</span>);</span><br><span class=\"line\">    transaction.commit();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"여기서 실제 쿼리 날리지롱~! commit 후\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/27/JPA/JPA%20영속성%20컨텍스트%20엔티티%20관리%20방법/write-lazy.png\">\n<h2>객체지향 쿼리(JPQL, Criteria, QueryDSL) 사용시에는 flush가 발생</h2>\n<p>밑에 코드에서 query.getResultList() 를 하는 순간 영속화(perist) 3번 하였던 것이 우선 insert를 3번 날리어 DB에 반영하게 됩니다.<br>\n왜냐면 그다음 코드에서 select 구문을 날리는데 아무리 쓰기지연이라 하지만 이전에 3개 insert 하는것이 반영이 안되어 select 하는게 의미가 있을까요?? 그래서 JPA에서는 객체지향 쿼리를 사용하게 되면 바로 DB에 반영이 됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> JPQL_사용시_자동_Flush_수행_동작_테스트() &#123;</span><br><span class=\"line\">    EntityManager em = emf.createEntityManager();</span><br><span class=\"line\">    EntityTransaction transaction = em.getTransaction();</span><br><span class=\"line\"></span><br><span class=\"line\">    transaction.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    Teacher teacher1 = Teacher.builder().name(<span class=\"string\">\"홍길동\"</span>).age(<span class=\"number\">32</span>).classGroupName(<span class=\"string\">\"1학년 1반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher1);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"홍길동 선생님이 등록되었습니다.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Teacher teacher2 = Teacher.builder().name(<span class=\"string\">\"임꺽정\"</span>).age(<span class=\"number\">15</span>).classGroupName(<span class=\"string\">\"2학년 7반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher2);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"임꺽정 선생님이 등록되었습니다.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Teacher teacher3 = Teacher.builder().name(<span class=\"string\">\"성춘향\"</span>).age(<span class=\"number\">27</span>).classGroupName(<span class=\"string\">\"3학년 5반\"</span>).build();</span><br><span class=\"line\">    em.persist(teacher3);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"성춘향 선생님이 등록되었습니다.\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    Query query = em.createQuery(<span class=\"string\">\"select t from Teacher t\"</span>, Teacher.class);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"객체지향 쿼리를 사용하여 flush를 수행합니다. 1\"</span>);</span><br><span class=\"line\">    List&lt;Teacher&gt; teacherList = query.getResultList();</span><br><span class=\"line\"></span><br><span class=\"line\">    transaction.commit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/27/JPA/JPA%20영속성%20컨텍스트%20엔티티%20관리%20방법/jpql-flush.png\">\n<h1>변경 감지(Dirty Checking)</h1>\n<p><strong>영속성 컨텍스트에서 관리되는 엔티티인 경우에 엔티티 정보가 변경 되었을때 변경 감지</strong>가 되어 업데이트 쿼리가 만들어집니다. 만들어 지는 과정은 이렇습니다.</p>\n<ul>\n<li>1차 캐쉬에 존재하는 엔티티와 변경 여부 확인</li>\n<li>값이 다르다면 UPDATE 구문을 만들고 쓰기 지연 SQL 저장소에 보관</li>\n<li>flush 하여 DB 쿼리 날림</li>\n<li>commit 되면 최종 반영</li>\n</ul>\n<h2>UPDATE 구문은 기본적으로 모든 컬럼을 UPDATE 한다.</h2>\n<p>예를 들어 컬럼이 30개 라면 컬럼 30개에 대한 모든 컬럼을 업데이트 한다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> 변경감지_동작_테스트() &#123;</span><br><span class=\"line\">    EntityManager em = emf.createEntityManager();</span><br><span class=\"line\">    EntityTransaction transaction = em.getTransaction();</span><br><span class=\"line\"></span><br><span class=\"line\">    transaction.begin();</span><br><span class=\"line\"></span><br><span class=\"line\">    em.persist(Teacher.builder().classGroupName(<span class=\"string\">\"2학년 1반\"</span>).build());</span><br><span class=\"line\">    Teacher teacher1 = em.find(Teacher.class, <span class=\"number\">1L</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"원래 맡은 반: \"</span> + teacher1.getClassGroupName());</span><br><span class=\"line\"></span><br><span class=\"line\">    teacher1.setClassGroupName(<span class=\"string\">\"3학년 1반\"</span>);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"새롭게 맡은 반: \"</span> + teacher1.getClassGroupName());</span><br><span class=\"line\"></span><br><span class=\"line\">    transaction.commit();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/27/JPA/JPA%20영속성%20컨텍스트%20엔티티%20관리%20방법/dynamic-update2.png\">\n<p>모든 컬럼을 업데이트 치는 것이 불필요하다 생각 할 수 있으나 아래와 같은 이점이 있다고 한다.</p>\n<ul>\n<li>모든 컬럼을 업데이트 하기 때문에 쿼리가 항상 같아서 DB에 동일한 쿼리를 보낼테고 이는 DB가 쿼리를 캐슁하여 캐슁한 쿼리를 계속 사용 할 수 있다.</li>\n</ul>\n<p>컬럼이 30개이상 되는 엔티티라면 기본값인 모든 컬럼을 업데이트 치는 것보다 @DynamincUpdate 을 사용하여 변경된 컬럼만 업데이트 치는것이 낫다고 한다.</p>\n<h2>일부만 UPDATE 하고 싶다면?</h2>\n<p>위에서 언급하였지만 @DynamincUpdate 이용해 @Entity 선언한 부분에 넣어주면 되고 위 코드에서 teacher1.setClassGroupName(“3학년 1반”); 하게 되면 “classGroupName” 컬럼만 업데이트 하게 된다.</p>\n<img src=\"/2019/07/27/JPA/JPA%20영속성%20컨텍스트%20엔티티%20관리%20방법/dynamic-update1.png\">\n<h1>[문제] DB에 날리는 쿼리는 몇 번 호출 되었을까?</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">Account account = <span class=\"keyword\">new</span> Account();</span><br><span class=\"line\">account.setUsername(<span class=\"string\">\"ryu\"</span>);</span><br><span class=\"line\">account.setPassword(<span class=\"string\">\"1111\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">Study study = <span class=\"keyword\">new</span> Study();</span><br><span class=\"line\">study.setName(<span class=\"string\">\"Spring Data JPA\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">account.addStudy(study);</span><br><span class=\"line\"></span><br><span class=\"line\">Session session = entityManager.unwrap(Session.class);</span><br><span class=\"line\">session.save(account);</span><br><span class=\"line\">session.save(study);</span><br><span class=\"line\"></span><br><span class=\"line\">Account yungwang = session.load(Account.class, account.getId());</span><br><span class=\"line\">yungwang.setUsername(<span class=\"string\">\"gwang\"</span>);</span><br><span class=\"line\">yungwang.setUsername(<span class=\"string\">\"boriswinter\"</span>);</span><br><span class=\"line\">yungwang.setUsername(<span class=\"string\">\"ryu\"</span>);</span><br></pre></td></tr></table></figure>\n<p>답은 insert 2번이다.</p>\n<p>session.save(account);<br>\nsession.save(study);</p>\n<p>이부분이 2번 insert 쿼리가 DB로 날라간것이다. 그럼 setUserName 메소드 3번 호출한건 왜 Update가 되지 않지??</p>\n<p>바로 이 부분이 Psersist Context에 성능 이점이다.<br>\n코드를 보면 ryu -&gt; gwang -&gt; boriswinter -&gt; ryu 결국 name은 변하지 않았기 때문에 JPA가 알아서 쿼리를 날리지 않았던 것이다.<br>\n이부분이 Dirty Checking 했다는 것이고 DB에 쿼리 날리는 것을 최소화 한다는 개념 Write Behind 개념이다.</p>\n<h1>TODO</h1>\n<ul>\n<li></li>\n</ul>\n"},{"title":"JPA 커스텀 리파지토리 만드는 방법","catalog":true,"date":"2019-07-25T11:29:24.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["JPA"],"_content":"\n# 학습목표\n- JPA 커스텀 리파지토리 만드는 방법을 알고 실무에 적절한 상황에 적용하여 생산성과 유지보수 향상을 도모한다.\n\n# 들어가며\n해당 설명에 대한 코드는 [Github](https://github.com/biggwang/learnning-subjects/tree/master/spring-jpa-n-plus-one) 에 있습니다.  \n내용은 차근 차근 업데이트 하고 살을 붙여 나가도록 하겠습니다.\n\n# 커스텀 리파지토리를 왜 만드는가?\n\nHibernate, Spring Data 제공하는 기능 외 내가 필요한 기능을 추가하거나 기존에 있는 기능을 오버라이딩하여 데이터를 영속화 시키고 싶을때 사용합니다. 말로는 한계가 있으니 우선 코드부터 보시죠   \n\n\n# 커스텀 리파지토리 만드는 방법 1\n\n~~~ java\n/**\n * Spring JPA에서 제공하는 것 외에 내가 필요한 기능을 직접 정의한다.\n */\npublic interface StudentCustomRepository<T> {\n\n    // Spring JPA에 없는 기능을 추가\n    List<Student> findStudent();\n\n    // Spring JPA에서 제공하는 기능을 재정의\n    void delete(T entity);\n}\n~~~\n이렇게 내가 리파지토리 레이어에서 사용하고 싶은 기능들을 인터페이스로 정의합니다.  \n\n 그 다음은 정의한 인터페이스를 implement 합니다.\n~~~ java\n/**\n * 마치 DAO 랑 비슷한 패턴이다.\n */\n@Slf4j\n@Repository\n@Transactional\npublic class StudentCustomRepositoryImpl implements StudentCustomRepository {\n\n    @Autowired\n    EntityManager entityManager;\n\n    @Override\n    public List<Student> findStudent() {\n        log.info(\"custom findStudent\");\n        return entityManager.createQuery(\"SELECT s FROM Student AS s\", Student.class)\n            .getResultList();\n    }\n\n    @Override\n    public void delete(Object entity) {\n        log.info(\"custom delete\");\n        entityManager.remove(entity);\n    }\n}\n~~~\n\nMybatis 사용 경험 있으신분은 DAO 패턴이랑 비슷하게 생각하시면 됩니다.  여기에 객체지향 쿼리를 작성하면됩니다.  위 코드에서는 JPQL을 사용하였지만 Criteria Query DSL을 사용하면 더 객체지향 쿼리를 개발 할 수 있습니다.   \n\n마지막으로 실제 사용할 리파지토리만 만들어 주면 됩니다.  \n\n~~~ java\npublic interface StudentRepository extends JpaRepository<Student, Long>, StudentCustomRepository<Student> {\n\n}\n~~~\n\n확인은 \n\n~~~ java \n@RunWith(SpringRunner.class)\n@DataJpaTest\npublic class StudentRepositoryTest {\n\n    @Autowired\n    private StudentRepository studentRepository;\n\n    /**\n     * @DataJpaTest 에서는 @Transaction 이 선언되어 있기 떄문에 기본적으로 Rollback이 된다.\n     */\n    @Test\n    public void crud() {\n        studentRepository.findStudent();\n\n        Student student = Student.builder().name(\"홍길동\").build();\n        studentRepository.save(student);\n\n        // Rollback이 수행 되기 때문에 반영이 안된다. delete를 반영하기 위해 flush를 씀\n        studentRepository.delete(student);\n        studentRepository.flush();\n    }\n}\n~~~\n\n\n\n\n# 커스텀 리파지토리 만드는 방법 2\n\n이번엔 상황을 예를 들어 보겠습니다. 위 방법데로 커스텀하게 만들어서 잘쓰고 있었는데 A리파지토리 B리파지토리 ... 공통적으로 사용되는 기능들이 있는겁니다.  \n위 방법은 하나의 Entity에 한해서 리파지를 커스텀하게 만든것이고 이번에는 모든 리파지토리에 공통기능을 커스텀 리파지토리를 만들고 싶은 것입니다.  \n\n코드를 보죠  \n\n~~~ java\n/**\n * Repository 공통 기능 정의\n *\n * @param <T> Entity\n * @param <ID> Key\n */\n@NoRepositoryBean   // 중간자 repository\npublic interface MyRepository<T, ID extends Serializable> extends JpaRepository<T, ID> {\n\n    boolean contains(T entity);\n}\n~~~\n\n모든 리파지토리에 공통 기능을 적용시키고 싶을 리파지토리를 정의합니다.  \n\n**TODO: @NoRepositoryBean에 대해서 설명하기**\n\n\n이제 위 정의한 구현체를 만듭니다.  \n보시면 SimpleJpaRepository를 상속 받았는데요 SimpleJpaRepository 는 JPA에서 클래스 상속구조에서 제일 밑단에 있는 구현 리파지토리 구현체입니다. 모든 공통기능을 가진 리파지토리를 만들고 있는 중이므로 기능이 많은 놈을 상속 받는게 낫겠죠??  \n\n그리고 아까 내가 공통으로 넣고 싶은 커스텀 리파지토리 또한 같이 넣어 줍니다.\n\n~~~ java\npublic class SimpleMyRepository<T, ID extends Serializable> extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {\n\n    private EntityManager entityManager;\n\n    public SimpleMyRepository(JpaEntityInformation<T, ?> entityInformation,\n        EntityManager entityManager) {\n        super(entityInformation, entityManager);\n        this.entityManager = entityManager;\n    }\n\n    @Override\n    public boolean contains(Object entity) {\n        return entityManager.contains(entity);\n    }\n\n}\n~~~\n\n\n그 다음 Spring Boot에게 커스텀하게 만든 리파지토리가 있다는 것을 알려주기만 하면 됩니다.\n~~~ java\n/**\n * @EnableJpaRepositories(repositoryImplementationPostfix = \"Default\") 커스터 리파지토리 Postfix \"impl\" 이 맘에\n * 안 들때\n */\n@SpringBootApplication\n@EnableJpaRepositories(repositoryBaseClass = SimpleJpaRepository.class)\npublic class SpringJpaDemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringJpaDemoApplication.class, args);\n    }\n\n}\n~~~\n\n\n실제 리파지토리에서 사용만 하면 끝~!\n\n~~~ java\npublic interface SubjectRepository extends MyRepository<Subject, Long> {\n\n}\n~~~\n\n","source":"_posts/JPA/JPA 커스텀 리파지토리 만드는 방법.md","raw":"---\ntitle: JPA 커스텀 리파지토리 만드는 방법\ncatalog: true\ndate: 2019-07-25 20:29:24\nsubtitle: \nheader-img: \"bg_computer.jpg\"\ntags: \n- Learnning\ncatagories:\n- JPA\n---\n\n# 학습목표\n- JPA 커스텀 리파지토리 만드는 방법을 알고 실무에 적절한 상황에 적용하여 생산성과 유지보수 향상을 도모한다.\n\n# 들어가며\n해당 설명에 대한 코드는 [Github](https://github.com/biggwang/learnning-subjects/tree/master/spring-jpa-n-plus-one) 에 있습니다.  \n내용은 차근 차근 업데이트 하고 살을 붙여 나가도록 하겠습니다.\n\n# 커스텀 리파지토리를 왜 만드는가?\n\nHibernate, Spring Data 제공하는 기능 외 내가 필요한 기능을 추가하거나 기존에 있는 기능을 오버라이딩하여 데이터를 영속화 시키고 싶을때 사용합니다. 말로는 한계가 있으니 우선 코드부터 보시죠   \n\n\n# 커스텀 리파지토리 만드는 방법 1\n\n~~~ java\n/**\n * Spring JPA에서 제공하는 것 외에 내가 필요한 기능을 직접 정의한다.\n */\npublic interface StudentCustomRepository<T> {\n\n    // Spring JPA에 없는 기능을 추가\n    List<Student> findStudent();\n\n    // Spring JPA에서 제공하는 기능을 재정의\n    void delete(T entity);\n}\n~~~\n이렇게 내가 리파지토리 레이어에서 사용하고 싶은 기능들을 인터페이스로 정의합니다.  \n\n 그 다음은 정의한 인터페이스를 implement 합니다.\n~~~ java\n/**\n * 마치 DAO 랑 비슷한 패턴이다.\n */\n@Slf4j\n@Repository\n@Transactional\npublic class StudentCustomRepositoryImpl implements StudentCustomRepository {\n\n    @Autowired\n    EntityManager entityManager;\n\n    @Override\n    public List<Student> findStudent() {\n        log.info(\"custom findStudent\");\n        return entityManager.createQuery(\"SELECT s FROM Student AS s\", Student.class)\n            .getResultList();\n    }\n\n    @Override\n    public void delete(Object entity) {\n        log.info(\"custom delete\");\n        entityManager.remove(entity);\n    }\n}\n~~~\n\nMybatis 사용 경험 있으신분은 DAO 패턴이랑 비슷하게 생각하시면 됩니다.  여기에 객체지향 쿼리를 작성하면됩니다.  위 코드에서는 JPQL을 사용하였지만 Criteria Query DSL을 사용하면 더 객체지향 쿼리를 개발 할 수 있습니다.   \n\n마지막으로 실제 사용할 리파지토리만 만들어 주면 됩니다.  \n\n~~~ java\npublic interface StudentRepository extends JpaRepository<Student, Long>, StudentCustomRepository<Student> {\n\n}\n~~~\n\n확인은 \n\n~~~ java \n@RunWith(SpringRunner.class)\n@DataJpaTest\npublic class StudentRepositoryTest {\n\n    @Autowired\n    private StudentRepository studentRepository;\n\n    /**\n     * @DataJpaTest 에서는 @Transaction 이 선언되어 있기 떄문에 기본적으로 Rollback이 된다.\n     */\n    @Test\n    public void crud() {\n        studentRepository.findStudent();\n\n        Student student = Student.builder().name(\"홍길동\").build();\n        studentRepository.save(student);\n\n        // Rollback이 수행 되기 때문에 반영이 안된다. delete를 반영하기 위해 flush를 씀\n        studentRepository.delete(student);\n        studentRepository.flush();\n    }\n}\n~~~\n\n\n\n\n# 커스텀 리파지토리 만드는 방법 2\n\n이번엔 상황을 예를 들어 보겠습니다. 위 방법데로 커스텀하게 만들어서 잘쓰고 있었는데 A리파지토리 B리파지토리 ... 공통적으로 사용되는 기능들이 있는겁니다.  \n위 방법은 하나의 Entity에 한해서 리파지를 커스텀하게 만든것이고 이번에는 모든 리파지토리에 공통기능을 커스텀 리파지토리를 만들고 싶은 것입니다.  \n\n코드를 보죠  \n\n~~~ java\n/**\n * Repository 공통 기능 정의\n *\n * @param <T> Entity\n * @param <ID> Key\n */\n@NoRepositoryBean   // 중간자 repository\npublic interface MyRepository<T, ID extends Serializable> extends JpaRepository<T, ID> {\n\n    boolean contains(T entity);\n}\n~~~\n\n모든 리파지토리에 공통 기능을 적용시키고 싶을 리파지토리를 정의합니다.  \n\n**TODO: @NoRepositoryBean에 대해서 설명하기**\n\n\n이제 위 정의한 구현체를 만듭니다.  \n보시면 SimpleJpaRepository를 상속 받았는데요 SimpleJpaRepository 는 JPA에서 클래스 상속구조에서 제일 밑단에 있는 구현 리파지토리 구현체입니다. 모든 공통기능을 가진 리파지토리를 만들고 있는 중이므로 기능이 많은 놈을 상속 받는게 낫겠죠??  \n\n그리고 아까 내가 공통으로 넣고 싶은 커스텀 리파지토리 또한 같이 넣어 줍니다.\n\n~~~ java\npublic class SimpleMyRepository<T, ID extends Serializable> extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> {\n\n    private EntityManager entityManager;\n\n    public SimpleMyRepository(JpaEntityInformation<T, ?> entityInformation,\n        EntityManager entityManager) {\n        super(entityInformation, entityManager);\n        this.entityManager = entityManager;\n    }\n\n    @Override\n    public boolean contains(Object entity) {\n        return entityManager.contains(entity);\n    }\n\n}\n~~~\n\n\n그 다음 Spring Boot에게 커스텀하게 만든 리파지토리가 있다는 것을 알려주기만 하면 됩니다.\n~~~ java\n/**\n * @EnableJpaRepositories(repositoryImplementationPostfix = \"Default\") 커스터 리파지토리 Postfix \"impl\" 이 맘에\n * 안 들때\n */\n@SpringBootApplication\n@EnableJpaRepositories(repositoryBaseClass = SimpleJpaRepository.class)\npublic class SpringJpaDemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringJpaDemoApplication.class, args);\n    }\n\n}\n~~~\n\n\n실제 리파지토리에서 사용만 하면 끝~!\n\n~~~ java\npublic interface SubjectRepository extends MyRepository<Subject, Long> {\n\n}\n~~~\n\n","slug":"JPA/JPA 커스텀 리파지토리 만드는 방법","published":1,"updated":"2019-07-30T14:10:15.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids0s0012k0otmhtw8a9g","content":"<h1><span id=\"학습목표\">학습목표</span></h1>\n<ul>\n<li>JPA 커스텀 리파지토리 만드는 방법을 알고 실무에 적절한 상황에 적용하여 생산성과 유지보수 향상을 도모한다.</li>\n</ul>\n<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>해당 설명에 대한 코드는 <a href=\"https://github.com/biggwang/learnning-subjects/tree/master/spring-jpa-n-plus-one\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Github</a> 에 있습니다.<br>\n내용은 차근 차근 업데이트 하고 살을 붙여 나가도록 하겠습니다.</p>\n<h1><span id=\"커스텀-리파지토리를-왜-만드는가\">커스텀 리파지토리를 왜 만드는가?</span></h1>\n<p>Hibernate, Spring Data 제공하는 기능 외 내가 필요한 기능을 추가하거나 기존에 있는 기능을 오버라이딩하여 데이터를 영속화 시키고 싶을때 사용합니다. 말로는 한계가 있으니 우선 코드부터 보시죠</p>\n<h1><span id=\"커스텀-리파지토리-만드는-방법-1\">커스텀 리파지토리 만드는 방법 1</span></h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Spring JPA에서 제공하는 것 외에 내가 필요한 기능을 직접 정의한다.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">StudentCustomRepository</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Spring JPA에 없는 기능을 추가</span></span><br><span class=\"line\">    <span class=\"function\">List&lt;Student&gt; <span class=\"title\">findStudent</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Spring JPA에서 제공하는 기능을 재정의</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(T entity)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 내가 리파지토리 레이어에서 사용하고 싶은 기능들을 인터페이스로 정의합니다.</p>\n<p>그 다음은 정의한 인터페이스를 implement 합니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 마치 DAO 랑 비슷한 패턴이다.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudentCustomRepositoryImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">StudentCustomRepository</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    EntityManager entityManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Student&gt; <span class=\"title\">findStudent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"custom findStudent\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> entityManager.createQuery(<span class=\"string\">\"SELECT s FROM Student AS s\"</span>, Student.class)</span><br><span class=\"line\">            .getResultList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Object entity)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"custom delete\"</span>);</span><br><span class=\"line\">        entityManager.remove(entity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Mybatis 사용 경험 있으신분은 DAO 패턴이랑 비슷하게 생각하시면 됩니다.  여기에 객체지향 쿼리를 작성하면됩니다.  위 코드에서는 JPQL을 사용하였지만 Criteria Query DSL을 사용하면 더 객체지향 쿼리를 개발 할 수 있습니다.</p>\n<p>마지막으로 실제 사용할 리파지토리만 만들어 주면 됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">StudentRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">Student</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">StudentCustomRepository</span>&lt;<span class=\"title\">Student</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>확인은</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@DataJpaTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudentRepositoryTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StudentRepository studentRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@DataJpaTest</span> 에서는 <span class=\"doctag\">@Transaction</span> 이 선언되어 있기 떄문에 기본적으로 Rollback이 된다.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">crud</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        studentRepository.findStudent();</span><br><span class=\"line\"></span><br><span class=\"line\">        Student student = Student.builder().name(<span class=\"string\">\"홍길동\"</span>).build();</span><br><span class=\"line\">        studentRepository.save(student);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Rollback이 수행 되기 때문에 반영이 안된다. delete를 반영하기 위해 flush를 씀</span></span><br><span class=\"line\">        studentRepository.delete(student);</span><br><span class=\"line\">        studentRepository.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"커스텀-리파지토리-만드는-방법-2\">커스텀 리파지토리 만드는 방법 2</span></h1>\n<p>이번엔 상황을 예를 들어 보겠습니다. 위 방법데로 커스텀하게 만들어서 잘쓰고 있었는데 A리파지토리 B리파지토리 … 공통적으로 사용되는 기능들이 있는겁니다.<br>\n위 방법은 하나의 Entity에 한해서 리파지를 커스텀하게 만든것이고 이번에는 모든 리파지토리에 공통기능을 커스텀 리파지토리를 만들고 싶은 것입니다.</p>\n<p>코드를 보죠</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Repository 공통 기능 정의</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; Entity</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;ID&gt; Key</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@NoRepositoryBean</span>   <span class=\"comment\">// 중간자 repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(T entity)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>모든 리파지토리에 공통 기능을 적용시키고 싶을 리파지토리를 정의합니다.</p>\n<p><strong>TODO: @NoRepositoryBean에 대해서 설명하기</strong></p>\n<p>이제 위 정의한 구현체를 만듭니다.<br>\n보시면 SimpleJpaRepository를 상속 받았는데요 SimpleJpaRepository 는 JPA에서 클래스 상속구조에서 제일 밑단에 있는 구현 리파지토리 구현체입니다. 모든 공통기능을 가진 리파지토리를 만들고 있는 중이므로 기능이 많은 놈을 상속 받는게 낫겠죠??</p>\n<p>그리고 아까 내가 공통으로 넣고 싶은 커스텀 리파지토리 또한 같이 넣어 줍니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleMyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">SimpleJpaRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EntityManager entityManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleMyRepository</span><span class=\"params\">(JpaEntityInformation&lt;T, ?&gt; entityInformation,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        EntityManager entityManager)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(entityInformation, entityManager);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.entityManager = entityManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object entity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> entityManager.contains(entity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그 다음 Spring Boot에게 커스텀하게 만든 리파지토리가 있다는 것을 알려주기만 하면 됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@EnableJpaRepositories</span>(repositoryImplementationPostfix = \"Default\") 커스터 리파지토리 Postfix \"impl\" 이 맘에</span></span><br><span class=\"line\"><span class=\"comment\"> * 안 들때</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(repositoryBaseClass = SimpleJpaRepository.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringJpaDemoApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(SpringJpaDemoApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>실제 리파지토리에서 사용만 하면 끝~!</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">SubjectRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">Subject</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1>학습목표</h1>\n<ul>\n<li>JPA 커스텀 리파지토리 만드는 방법을 알고 실무에 적절한 상황에 적용하여 생산성과 유지보수 향상을 도모한다.</li>\n</ul>\n<h1>들어가며</h1>\n<p>해당 설명에 대한 코드는 <a href=\"https://github.com/biggwang/learnning-subjects/tree/master/spring-jpa-n-plus-one\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Github</a> 에 있습니다.<br>\n내용은 차근 차근 업데이트 하고 살을 붙여 나가도록 하겠습니다.</p>\n<h1>커스텀 리파지토리를 왜 만드는가?</h1>\n<p>Hibernate, Spring Data 제공하는 기능 외 내가 필요한 기능을 추가하거나 기존에 있는 기능을 오버라이딩하여 데이터를 영속화 시키고 싶을때 사용합니다. 말로는 한계가 있으니 우선 코드부터 보시죠</p>\n<h1>커스텀 리파지토리 만드는 방법 1</h1>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Spring JPA에서 제공하는 것 외에 내가 필요한 기능을 직접 정의한다.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">StudentCustomRepository</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Spring JPA에 없는 기능을 추가</span></span><br><span class=\"line\">    <span class=\"function\">List&lt;Student&gt; <span class=\"title\">findStudent</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Spring JPA에서 제공하는 기능을 재정의</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(T entity)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 내가 리파지토리 레이어에서 사용하고 싶은 기능들을 인터페이스로 정의합니다.</p>\n<p>그 다음은 정의한 인터페이스를 implement 합니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 마치 DAO 랑 비슷한 패턴이다.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"meta\">@Repository</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudentCustomRepositoryImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">StudentCustomRepository</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    EntityManager entityManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Student&gt; <span class=\"title\">findStudent</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"custom findStudent\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> entityManager.createQuery(<span class=\"string\">\"SELECT s FROM Student AS s\"</span>, Student.class)</span><br><span class=\"line\">            .getResultList();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Object entity)</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"custom delete\"</span>);</span><br><span class=\"line\">        entityManager.remove(entity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Mybatis 사용 경험 있으신분은 DAO 패턴이랑 비슷하게 생각하시면 됩니다.  여기에 객체지향 쿼리를 작성하면됩니다.  위 코드에서는 JPQL을 사용하였지만 Criteria Query DSL을 사용하면 더 객체지향 쿼리를 개발 할 수 있습니다.</p>\n<p>마지막으로 실제 사용할 리파지토리만 만들어 주면 됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">StudentRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">Student</span>, <span class=\"title\">Long</span>&gt;, <span class=\"title\">StudentCustomRepository</span>&lt;<span class=\"title\">Student</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>확인은</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RunWith</span>(SpringRunner.class)</span><br><span class=\"line\"><span class=\"meta\">@DataJpaTest</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StudentRepositoryTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StudentRepository studentRepository;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@DataJpaTest</span> 에서는 <span class=\"doctag\">@Transaction</span> 이 선언되어 있기 떄문에 기본적으로 Rollback이 된다.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">crud</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        studentRepository.findStudent();</span><br><span class=\"line\"></span><br><span class=\"line\">        Student student = Student.builder().name(<span class=\"string\">\"홍길동\"</span>).build();</span><br><span class=\"line\">        studentRepository.save(student);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Rollback이 수행 되기 때문에 반영이 안된다. delete를 반영하기 위해 flush를 씀</span></span><br><span class=\"line\">        studentRepository.delete(student);</span><br><span class=\"line\">        studentRepository.flush();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>커스텀 리파지토리 만드는 방법 2</h1>\n<p>이번엔 상황을 예를 들어 보겠습니다. 위 방법데로 커스텀하게 만들어서 잘쓰고 있었는데 A리파지토리 B리파지토리 … 공통적으로 사용되는 기능들이 있는겁니다.<br>\n위 방법은 하나의 Entity에 한해서 리파지를 커스텀하게 만든것이고 이번에는 모든 리파지토리에 공통기능을 커스텀 리파지토리를 만들고 싶은 것입니다.</p>\n<p>코드를 보죠</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Repository 공통 기능 정의</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;T&gt; Entity</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> &lt;ID&gt; Key</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@NoRepositoryBean</span>   <span class=\"comment\">// 중간자 repository</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">JpaRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(T entity)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>모든 리파지토리에 공통 기능을 적용시키고 싶을 리파지토리를 정의합니다.</p>\n<p><strong>TODO: @NoRepositoryBean에 대해서 설명하기</strong></p>\n<p>이제 위 정의한 구현체를 만듭니다.<br>\n보시면 SimpleJpaRepository를 상속 받았는데요 SimpleJpaRepository 는 JPA에서 클래스 상속구조에서 제일 밑단에 있는 구현 리파지토리 구현체입니다. 모든 공통기능을 가진 리파지토리를 만들고 있는 중이므로 기능이 많은 놈을 상속 받는게 낫겠죠??</p>\n<p>그리고 아까 내가 공통으로 넣고 싶은 커스텀 리파지토리 또한 같이 넣어 줍니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleMyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span> <span class=\"keyword\">extends</span> <span class=\"title\">Serializable</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">SimpleJpaRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">ID</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> EntityManager entityManager;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleMyRepository</span><span class=\"params\">(JpaEntityInformation&lt;T, ?&gt; entityInformation,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">        EntityManager entityManager)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(entityInformation, entityManager);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.entityManager = entityManager;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object entity)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> entityManager.contains(entity);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>그 다음 Spring Boot에게 커스텀하게 만든 리파지토리가 있다는 것을 알려주기만 하면 됩니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@EnableJpaRepositories</span>(repositoryImplementationPostfix = \"Default\") 커스터 리파지토리 Postfix \"impl\" 이 맘에</span></span><br><span class=\"line\"><span class=\"comment\"> * 안 들때</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableJpaRepositories</span>(repositoryBaseClass = SimpleJpaRepository.class)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringJpaDemoApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(SpringJpaDemoApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>실제 리파지토리에서 사용만 하면 끝~!</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">SubjectRepository</span> <span class=\"keyword\">extends</span> <span class=\"title\">MyRepository</span>&lt;<span class=\"title\">Subject</span>, <span class=\"title\">Long</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"내가 작성한 코드가 메모리에서 어떻게 실행 될까","catalog":true,"date":"2019-01-03T14:45:00.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["OS"],"_content":"\n## 들어가며\n패스트캠퍼스 OS 파트 이준희 강사님 강의를 듣고 이해한 내용을 Java로 대입하여 **코드가 실제 메모리 영역에서 어떻게 동작** 하는지 적용해보겠다.  \n자바는 인터프리터로 해석하기도 하고 한꺼번에 컴파일해서 실행하기도 하지만 핵심은 코드가 메모리에서 어떻게 동작하는지 정리해본다.  또한 초안 단계라 지속적으로 내용을 다듬고 정리하여 정확하고 완성도 있게 만들어 보자\n\n\n## 포스팅 목표\nJava 코드가 OS에게 할당받은 JVM위 메모리 영역에서 어떻게 움직이는지 확실하게 다른 사람을 이해시켜보자\n\n우선, 아래와 같은 코드가 있다고 하자\n\n{% asset_img \"OS_process_code.png\" %}\n\n이 상태에서 JVM이 실행되면 어떻게 될까? \n\n### JVM이 OS에게 메모리에 할당 요청을 한다.\n자바는 JVM 가상머신 위에서 동작하므로 JVM이 동작 하려면 메모리를 OS에게 할당 받아야 한다.\n\n### 자바 컴파일러가 .java 파일을 .class 파일(byte code)로 변환한다.\nRuntime 시점에서 ClassLoader가 자바 문법이 맞는지 등등.. 해석 및 최적화 과정을 거치고 ClassLoader가 JVM내 메모리 Runtime Data Area 영역인 Method Aread(Code) 영역으로 옮긴다.\n\n{% asset_img \"OS_process.png\" %}  \n\n위와 같이 Runtime Data Area 영역에 각 역활이 정해지면 Execution Engine이 Method Area에 있는 바이트 코드를 네이티브 코드로 변환 하면서 프로그램을 실행 하게 된다.\n\n> 자바는 코드 한줄 씩 인터프리터로 해석하기도 하였다가 호출 빈도가 높고나 특정 조건이 맞으면 한꺼번에 컴파일을 하여 프로그램을 실행하기도 한다고 하였지만 여기서는 전체 코드가 컴파일 되었다고 가정하자 [참고](https://goo.gl/D9ucvB)\n\n\n### 동작\n제일먼저 main 함수가 시작 되지만 그 전에 PC REGISTER에 Stack Pointer에 StackFrame에 최댓 값인 1000H가 먼저 초기화 되고 함수가 return 될 주소 0011H가 입력되게 된다.  그래야 함수가 종료되고 다음 위치로 이동하여 계속 코드를 실행하기 때문이다.  \n\n> 소스코드가 동작하면서 함수가 호출되면 Stack 영역에 동적으로 메모리를 할당(객체 생성)하게 되면 Heap영역에 전역 변수에 대한 공간은 Data 영역에 각 용도에 맞게 값이 저장되면서 동시에 PC Register도 코드에 대한 Context를 알아야 하기 때문에 같이 값이 바뀌고 있는것을 인지해야 한다.  \n\nStack에 쌓일때 이용되는 레지스터는 아래와 같다.\n{% asset_img \"OS_register.png\" %}  \n\n\n#### Program Counter\n이때 CODE영역에서는 코드가 한줄 실행 될때마다 해당 코드에 메모리 주소값이 Program Counter Register에 계속 값이 바뀐다.\n\n메소드가 실행되면 return address값이 stack에 입력되면 그다음 파라미터 값들이 차례데로 입력된다. 또한 메소드내 선언 된 지역변수 또한 다음 stack에 쌓이게 된다.\n\n#### Stack Pointer\n이때 stack에 쌓이면 Program Counter와 같이 Stack Pointer 라는게 존재하는데 마찬가지로 Stack 채워질때 마다 해당 주소가 계속 바뀐다고 생각하면된다.  \n\ncode영역에 보이는 바와 같이 함수안에 함수가 선언되면 마찬가지로 제일 먼저 return address가 stack에 입력되고 코드데로 처리가 된다.\n\n#### EBP\n이때 EBP라는 Register가 있는데 하는 역활은 함수내 함수 호출이 계속 이루어지다가 만약 오류가 발생 했을 때 어디서 오류가 발생했는지 빠르게 함수를 트래킹 하기 위해 존재하는 레지스터 이다.  Stack Pointer에 바로 다음 주소 값을 가리킨다고 생각하면 된다.\n\n#### EAX \n함수에 대한 return 값을 보관하고 있는 레지스터 이다. return total 하면 total값은 3이기 때문에 3이 EAX 레지스터에 들어가게 된다.\n\nreturn이 되고 나면 함수를 빠져 나온것이기 때문에 0FFAH부터 차근차근 위로 올라가 Stack이 비워지게 되며 main함수까지 다 끝나면 stack frame은 비워지게 된다.\n\n\n## 마치며\n강의를 여러번 듣고 겨우 큰 그림은 이해한거 같다.  \n로우레벨단위를 단시간 안에 내것으로 만들긴 힘들겠지만 지속적으로 기반지식이 쌓여 이해한 내용을 여기에 계속 업데이트하여 확실한 지식을 만들어 놓자","source":"_posts/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까.md","raw":"---\ntitle: 내가 작성한 코드가 메모리에서 어떻게 실행 될까\ncatalog: true\ndate: 2019-01-03 23:45:00\nsubtitle:\nheader-img: \"bg_computer.jpg\"\ntags:\n- OS\ncatagories:\n- OS\n---\n\n## 들어가며\n패스트캠퍼스 OS 파트 이준희 강사님 강의를 듣고 이해한 내용을 Java로 대입하여 **코드가 실제 메모리 영역에서 어떻게 동작** 하는지 적용해보겠다.  \n자바는 인터프리터로 해석하기도 하고 한꺼번에 컴파일해서 실행하기도 하지만 핵심은 코드가 메모리에서 어떻게 동작하는지 정리해본다.  또한 초안 단계라 지속적으로 내용을 다듬고 정리하여 정확하고 완성도 있게 만들어 보자\n\n\n## 포스팅 목표\nJava 코드가 OS에게 할당받은 JVM위 메모리 영역에서 어떻게 움직이는지 확실하게 다른 사람을 이해시켜보자\n\n우선, 아래와 같은 코드가 있다고 하자\n\n{% asset_img \"OS_process_code.png\" %}\n\n이 상태에서 JVM이 실행되면 어떻게 될까? \n\n### JVM이 OS에게 메모리에 할당 요청을 한다.\n자바는 JVM 가상머신 위에서 동작하므로 JVM이 동작 하려면 메모리를 OS에게 할당 받아야 한다.\n\n### 자바 컴파일러가 .java 파일을 .class 파일(byte code)로 변환한다.\nRuntime 시점에서 ClassLoader가 자바 문법이 맞는지 등등.. 해석 및 최적화 과정을 거치고 ClassLoader가 JVM내 메모리 Runtime Data Area 영역인 Method Aread(Code) 영역으로 옮긴다.\n\n{% asset_img \"OS_process.png\" %}  \n\n위와 같이 Runtime Data Area 영역에 각 역활이 정해지면 Execution Engine이 Method Area에 있는 바이트 코드를 네이티브 코드로 변환 하면서 프로그램을 실행 하게 된다.\n\n> 자바는 코드 한줄 씩 인터프리터로 해석하기도 하였다가 호출 빈도가 높고나 특정 조건이 맞으면 한꺼번에 컴파일을 하여 프로그램을 실행하기도 한다고 하였지만 여기서는 전체 코드가 컴파일 되었다고 가정하자 [참고](https://goo.gl/D9ucvB)\n\n\n### 동작\n제일먼저 main 함수가 시작 되지만 그 전에 PC REGISTER에 Stack Pointer에 StackFrame에 최댓 값인 1000H가 먼저 초기화 되고 함수가 return 될 주소 0011H가 입력되게 된다.  그래야 함수가 종료되고 다음 위치로 이동하여 계속 코드를 실행하기 때문이다.  \n\n> 소스코드가 동작하면서 함수가 호출되면 Stack 영역에 동적으로 메모리를 할당(객체 생성)하게 되면 Heap영역에 전역 변수에 대한 공간은 Data 영역에 각 용도에 맞게 값이 저장되면서 동시에 PC Register도 코드에 대한 Context를 알아야 하기 때문에 같이 값이 바뀌고 있는것을 인지해야 한다.  \n\nStack에 쌓일때 이용되는 레지스터는 아래와 같다.\n{% asset_img \"OS_register.png\" %}  \n\n\n#### Program Counter\n이때 CODE영역에서는 코드가 한줄 실행 될때마다 해당 코드에 메모리 주소값이 Program Counter Register에 계속 값이 바뀐다.\n\n메소드가 실행되면 return address값이 stack에 입력되면 그다음 파라미터 값들이 차례데로 입력된다. 또한 메소드내 선언 된 지역변수 또한 다음 stack에 쌓이게 된다.\n\n#### Stack Pointer\n이때 stack에 쌓이면 Program Counter와 같이 Stack Pointer 라는게 존재하는데 마찬가지로 Stack 채워질때 마다 해당 주소가 계속 바뀐다고 생각하면된다.  \n\ncode영역에 보이는 바와 같이 함수안에 함수가 선언되면 마찬가지로 제일 먼저 return address가 stack에 입력되고 코드데로 처리가 된다.\n\n#### EBP\n이때 EBP라는 Register가 있는데 하는 역활은 함수내 함수 호출이 계속 이루어지다가 만약 오류가 발생 했을 때 어디서 오류가 발생했는지 빠르게 함수를 트래킹 하기 위해 존재하는 레지스터 이다.  Stack Pointer에 바로 다음 주소 값을 가리킨다고 생각하면 된다.\n\n#### EAX \n함수에 대한 return 값을 보관하고 있는 레지스터 이다. return total 하면 total값은 3이기 때문에 3이 EAX 레지스터에 들어가게 된다.\n\nreturn이 되고 나면 함수를 빠져 나온것이기 때문에 0FFAH부터 차근차근 위로 올라가 Stack이 비워지게 되며 main함수까지 다 끝나면 stack frame은 비워지게 된다.\n\n\n## 마치며\n강의를 여러번 듣고 겨우 큰 그림은 이해한거 같다.  \n로우레벨단위를 단시간 안에 내것으로 만들긴 힘들겠지만 지속적으로 기반지식이 쌓여 이해한 내용을 여기에 계속 업데이트하여 확실한 지식을 만들어 놓자","slug":"OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까","published":1,"updated":"2019-07-10T14:44:29.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids0u0015k0otqltg3xu3","content":"<h2><span id=\"들어가며\">들어가며</span></h2>\n<p>패스트캠퍼스 OS 파트 이준희 강사님 강의를 듣고 이해한 내용을 Java로 대입하여 <strong>코드가 실제 메모리 영역에서 어떻게 동작</strong> 하는지 적용해보겠다.<br>\n자바는 인터프리터로 해석하기도 하고 한꺼번에 컴파일해서 실행하기도 하지만 핵심은 코드가 메모리에서 어떻게 동작하는지 정리해본다.  또한 초안 단계라 지속적으로 내용을 다듬고 정리하여 정확하고 완성도 있게 만들어 보자</p>\n<h2><span id=\"포스팅-목표\">포스팅 목표</span></h2>\n<p>Java 코드가 OS에게 할당받은 JVM위 메모리 영역에서 어떻게 움직이는지 확실하게 다른 사람을 이해시켜보자</p>\n<p>우선, 아래와 같은 코드가 있다고 하자</p>\n<img src=\"/2019/01/03/OS/[OS]%20내가%20작성한%20코드가%20메모리에서%20어떻게%20실행%20될까/OS_process_code.png\">\n<p>이 상태에서 JVM이 실행되면 어떻게 될까?</p>\n<h3><span id=\"jvm이-os에게-메모리에-할당-요청을-한다\">JVM이 OS에게 메모리에 할당 요청을 한다.</span></h3>\n<p>자바는 JVM 가상머신 위에서 동작하므로 JVM이 동작 하려면 메모리를 OS에게 할당 받아야 한다.</p>\n<h3><span id=\"자바-컴파일러가-java-파일을-class-파일byte-code로-변환한다\">자바 컴파일러가 .java 파일을 .class 파일(byte code)로 변환한다.</span></h3>\n<p>Runtime 시점에서 ClassLoader가 자바 문법이 맞는지 등등… 해석 및 최적화 과정을 거치고 ClassLoader가 JVM내 메모리 Runtime Data Area 영역인 Method Aread(Code) 영역으로 옮긴다.</p>\n<img src=\"/2019/01/03/OS/[OS]%20내가%20작성한%20코드가%20메모리에서%20어떻게%20실행%20될까/OS_process.png\">  \n<p>위와 같이 Runtime Data Area 영역에 각 역활이 정해지면 Execution Engine이 Method Area에 있는 바이트 코드를 네이티브 코드로 변환 하면서 프로그램을 실행 하게 된다.</p>\n<blockquote>\n<p>자바는 코드 한줄 씩 인터프리터로 해석하기도 하였다가 호출 빈도가 높고나 특정 조건이 맞으면 한꺼번에 컴파일을 하여 프로그램을 실행하기도 한다고 하였지만 여기서는 전체 코드가 컴파일 되었다고 가정하자 <a href=\"https://goo.gl/D9ucvB\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">참고</a></p>\n</blockquote>\n<h3><span id=\"동작\">동작</span></h3>\n<p>제일먼저 main 함수가 시작 되지만 그 전에 PC REGISTER에 Stack Pointer에 StackFrame에 최댓 값인 1000H가 먼저 초기화 되고 함수가 return 될 주소 0011H가 입력되게 된다.  그래야 함수가 종료되고 다음 위치로 이동하여 계속 코드를 실행하기 때문이다.</p>\n<blockquote>\n<p>소스코드가 동작하면서 함수가 호출되면 Stack 영역에 동적으로 메모리를 할당(객체 생성)하게 되면 Heap영역에 전역 변수에 대한 공간은 Data 영역에 각 용도에 맞게 값이 저장되면서 동시에 PC Register도 코드에 대한 Context를 알아야 하기 때문에 같이 값이 바뀌고 있는것을 인지해야 한다.</p>\n</blockquote>\n<p>Stack에 쌓일때 이용되는 레지스터는 아래와 같다.</p>\n<img src=\"/2019/01/03/OS/[OS]%20내가%20작성한%20코드가%20메모리에서%20어떻게%20실행%20될까/OS_register.png\">  \n<h4><span id=\"program-counter\">Program Counter</span></h4>\n<p>이때 CODE영역에서는 코드가 한줄 실행 될때마다 해당 코드에 메모리 주소값이 Program Counter Register에 계속 값이 바뀐다.</p>\n<p>메소드가 실행되면 return address값이 stack에 입력되면 그다음 파라미터 값들이 차례데로 입력된다. 또한 메소드내 선언 된 지역변수 또한 다음 stack에 쌓이게 된다.</p>\n<h4><span id=\"stack-pointer\">Stack Pointer</span></h4>\n<p>이때 stack에 쌓이면 Program Counter와 같이 Stack Pointer 라는게 존재하는데 마찬가지로 Stack 채워질때 마다 해당 주소가 계속 바뀐다고 생각하면된다.</p>\n<p>code영역에 보이는 바와 같이 함수안에 함수가 선언되면 마찬가지로 제일 먼저 return address가 stack에 입력되고 코드데로 처리가 된다.</p>\n<h4><span id=\"ebp\">EBP</span></h4>\n<p>이때 EBP라는 Register가 있는데 하는 역활은 함수내 함수 호출이 계속 이루어지다가 만약 오류가 발생 했을 때 어디서 오류가 발생했는지 빠르게 함수를 트래킹 하기 위해 존재하는 레지스터 이다.  Stack Pointer에 바로 다음 주소 값을 가리킨다고 생각하면 된다.</p>\n<h4><span id=\"eax\">EAX</span></h4>\n<p>함수에 대한 return 값을 보관하고 있는 레지스터 이다. return total 하면 total값은 3이기 때문에 3이 EAX 레지스터에 들어가게 된다.</p>\n<p>return이 되고 나면 함수를 빠져 나온것이기 때문에 0FFAH부터 차근차근 위로 올라가 Stack이 비워지게 되며 main함수까지 다 끝나면 stack frame은 비워지게 된다.</p>\n<h2><span id=\"마치며\">마치며</span></h2>\n<p>강의를 여러번 듣고 겨우 큰 그림은 이해한거 같다.<br>\n로우레벨단위를 단시간 안에 내것으로 만들긴 힘들겠지만 지속적으로 기반지식이 쌓여 이해한 내용을 여기에 계속 업데이트하여 확실한 지식을 만들어 놓자</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>들어가며</h2>\n<p>패스트캠퍼스 OS 파트 이준희 강사님 강의를 듣고 이해한 내용을 Java로 대입하여 <strong>코드가 실제 메모리 영역에서 어떻게 동작</strong> 하는지 적용해보겠다.<br>\n자바는 인터프리터로 해석하기도 하고 한꺼번에 컴파일해서 실행하기도 하지만 핵심은 코드가 메모리에서 어떻게 동작하는지 정리해본다.  또한 초안 단계라 지속적으로 내용을 다듬고 정리하여 정확하고 완성도 있게 만들어 보자</p>\n<h2>포스팅 목표</h2>\n<p>Java 코드가 OS에게 할당받은 JVM위 메모리 영역에서 어떻게 움직이는지 확실하게 다른 사람을 이해시켜보자</p>\n<p>우선, 아래와 같은 코드가 있다고 하자</p>\n<img src=\"/2019/01/03/OS/[OS]%20내가%20작성한%20코드가%20메모리에서%20어떻게%20실행%20될까/OS_process_code.png\">\n<p>이 상태에서 JVM이 실행되면 어떻게 될까?</p>\n<h3>JVM이 OS에게 메모리에 할당 요청을 한다.</h3>\n<p>자바는 JVM 가상머신 위에서 동작하므로 JVM이 동작 하려면 메모리를 OS에게 할당 받아야 한다.</p>\n<h3>자바 컴파일러가 .java 파일을 .class 파일(byte code)로 변환한다.</h3>\n<p>Runtime 시점에서 ClassLoader가 자바 문법이 맞는지 등등… 해석 및 최적화 과정을 거치고 ClassLoader가 JVM내 메모리 Runtime Data Area 영역인 Method Aread(Code) 영역으로 옮긴다.</p>\n<img src=\"/2019/01/03/OS/[OS]%20내가%20작성한%20코드가%20메모리에서%20어떻게%20실행%20될까/OS_process.png\">  \n<p>위와 같이 Runtime Data Area 영역에 각 역활이 정해지면 Execution Engine이 Method Area에 있는 바이트 코드를 네이티브 코드로 변환 하면서 프로그램을 실행 하게 된다.</p>\n<blockquote>\n<p>자바는 코드 한줄 씩 인터프리터로 해석하기도 하였다가 호출 빈도가 높고나 특정 조건이 맞으면 한꺼번에 컴파일을 하여 프로그램을 실행하기도 한다고 하였지만 여기서는 전체 코드가 컴파일 되었다고 가정하자 <a href=\"https://goo.gl/D9ucvB\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">참고</a></p>\n</blockquote>\n<h3>동작</h3>\n<p>제일먼저 main 함수가 시작 되지만 그 전에 PC REGISTER에 Stack Pointer에 StackFrame에 최댓 값인 1000H가 먼저 초기화 되고 함수가 return 될 주소 0011H가 입력되게 된다.  그래야 함수가 종료되고 다음 위치로 이동하여 계속 코드를 실행하기 때문이다.</p>\n<blockquote>\n<p>소스코드가 동작하면서 함수가 호출되면 Stack 영역에 동적으로 메모리를 할당(객체 생성)하게 되면 Heap영역에 전역 변수에 대한 공간은 Data 영역에 각 용도에 맞게 값이 저장되면서 동시에 PC Register도 코드에 대한 Context를 알아야 하기 때문에 같이 값이 바뀌고 있는것을 인지해야 한다.</p>\n</blockquote>\n<p>Stack에 쌓일때 이용되는 레지스터는 아래와 같다.</p>\n<img src=\"/2019/01/03/OS/[OS]%20내가%20작성한%20코드가%20메모리에서%20어떻게%20실행%20될까/OS_register.png\">  \n<h4>Program Counter</h4>\n<p>이때 CODE영역에서는 코드가 한줄 실행 될때마다 해당 코드에 메모리 주소값이 Program Counter Register에 계속 값이 바뀐다.</p>\n<p>메소드가 실행되면 return address값이 stack에 입력되면 그다음 파라미터 값들이 차례데로 입력된다. 또한 메소드내 선언 된 지역변수 또한 다음 stack에 쌓이게 된다.</p>\n<h4>Stack Pointer</h4>\n<p>이때 stack에 쌓이면 Program Counter와 같이 Stack Pointer 라는게 존재하는데 마찬가지로 Stack 채워질때 마다 해당 주소가 계속 바뀐다고 생각하면된다.</p>\n<p>code영역에 보이는 바와 같이 함수안에 함수가 선언되면 마찬가지로 제일 먼저 return address가 stack에 입력되고 코드데로 처리가 된다.</p>\n<h4>EBP</h4>\n<p>이때 EBP라는 Register가 있는데 하는 역활은 함수내 함수 호출이 계속 이루어지다가 만약 오류가 발생 했을 때 어디서 오류가 발생했는지 빠르게 함수를 트래킹 하기 위해 존재하는 레지스터 이다.  Stack Pointer에 바로 다음 주소 값을 가리킨다고 생각하면 된다.</p>\n<h4>EAX</h4>\n<p>함수에 대한 return 값을 보관하고 있는 레지스터 이다. return total 하면 total값은 3이기 때문에 3이 EAX 레지스터에 들어가게 된다.</p>\n<p>return이 되고 나면 함수를 빠져 나온것이기 때문에 0FFAH부터 차근차근 위로 올라가 Stack이 비워지게 되며 main함수까지 다 끝나면 stack frame은 비워지게 된다.</p>\n<h2>마치며</h2>\n<p>강의를 여러번 듣고 겨우 큰 그림은 이해한거 같다.<br>\n로우레벨단위를 단시간 안에 내것으로 만들긴 힘들겠지만 지속적으로 기반지식이 쌓여 이해한 내용을 여기에 계속 업데이트하여 확실한 지식을 만들어 놓자</p>\n"},{"title":"JPA 쿼리에 대해서","catalog":true,"date":"2019-07-23T01:05:15.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["JPA"],"_content":"\n# 학습목표\n- JPA 쿼리를 왜 사용하는지 이해한다.\n- JPA 쿼리 종류가 어떤것이 있으며 각 장/단점을 각 상황에 따라 실무에 적용 할 줄 안다.\n\n\n# JPA 쿼리!?!? 쿼리를 안써도 되는 줄 알았는데??\n\nJPA를 공부하면서 가장 큰 착각 중에 하나였다.  \n아직도 의문점이 드는게 있고 완벽하진 않지만 하나하나 궁금증을 해결해 가면서 지식을 내것으로 만들어 보겠다.  \n\n## 패러다임 불일치 해결\n\nJPA를 입문할 때 가장 많이 들었던 용어중 하나 였다.  \n의미는 객체지향과 관계지향에 성격이 다른 것을 ORM을 통해 그 불일치를 해결해 준다는 것이다. 나같은 경우는 JAVA 와 RDBMS 였다.  \n\n## 그럼 왜 패러다임 불일치를 해결 할까?\n\n사실 내가 여태껏 웹 개발을 경험하면서 대부분에 비지니스 로직에 초점은 결국 쿼리를 어떻게 작성하느냐고 그 쿼리에 맞춰 DAO, Service, Controller 순으로 개발 하였다.  \nJPA 를 쓰기전에는 Mybatis를 사용하였고 각 기능마다 CRUD 쿼리를 작성해주어야 했다.  \n내가 말하고 싶은 포인트는 자바 OOP로 개발해야 소프트웨어가 변경에 flexible하고 쉬운 유지보수를 할 수 있는데 쿼리 중심으로 맞춰 개발 하다 보니 객체지향 프로그래밍에 장점을 살리지 못하고 있는 것이다.\n\n어쨋든 프로그래밍을 하면서 데이터는 RDB에 넣긴 해야 한다.  넣어야 하는데 그것을 테이블간에 관계도를 생각하면서 쿼리를 작성하는데 초점을 두는것이 아니라 객체간에 관계 참조를 쉽게 코드로 표현 하고 그 표현을 해석하는 ORM, Hibernate, JPA, 영속성 컨텍스트가 감지하여 쿼리를 만들어 DB에 영속화 시키는 것이다.  \n\n이런 중간 역활을 ORM을 함으로써 개발 할 때, 데이터를 영속화 할 때 객체지향으로 개발할 수 있다는점에서 패러다임 불일치를 해결 한다고 말한다고 생각한다.\n\n\n다시 돌아서 제일 처음 궁금증에 대해서 다시 생각해 보면,  ORM, JPA가 패러다임 불일치를 해결한다고 했으니까 나는 쿼리를 작성안하고 객체지향 프로그래밍을 하면 영속성 컨텍스트에서 알아서 쿼리를 만들고 DB에 쿼리를 날리는 것을 생각 하였다.  \n\n하지만 일부만 맞다고 생각이 든다. 왜냐하면 단순히 저장(persist), 수정(객체 속성값 변경), 조회(findAll), 삭제(delete) 기능이라면 쿼리를 작성 할 필요도 없다.  \nJPA가 제공해주는 정확히 Hibernate 가 제공해주는 API를 사용함으로써 **단순 CRUD에 대한 쿼리 작성은 필요 없는것이다.**  \n\n단순 CRUD라고 하였고 **그럼 복잡한 CRUD는 ??** 그때 바로 필요 한게 JPA에서 사용하고 있는 여러 쿼리 작성이 필요 하다고 생각하고 그래서 존재한다고 생각한다.  \n복잡한 애플리케이션 일수록 복잡한 쿼리를 요구 하게 되므로 위 간단한 API 호출로는 한계가 있다. \n\n쿼리라 말하였지만 정확히 객체지향 쿼리이다.  \n하지만 이부분은 아직 잘 공감되지 않는 부분이기도 한데, 객체지향 쿼리라고 하지만 객체지향 쿼리도 모양은 결국 쿼리다.  하지만 객체지향 쿼리라고 말하는 이유는 쿼리를 만드는데 타켓이 데이터베이스에 있는것이 아닌 바로 객체 Entity를 가지고 쿼리를 만들기 때문이다. \n\n# JPA 쿼리 종류 및 장.단점\n\n가장 중요한것은 JPQL이다.  Criteria 이나 Query DSL은 JPQL을 편리하게 사용 하도록 도와주는 기술일 뿐이다.  \n객체지향 쿼리는 DBMS 종류에 관계없이 추상화된 쿼리이니 DBMS를 신경쓰지 않아도 되는 큰 이점이 있다.  본격적으로 쿼리 종류를 알아보면\n\n## JPQL(HQL)\n\n~~~ java\nString jpql = \"select m from Member as m where m.username = 'ryu'\";\nList<Member> resultList = \n    em.createQuery(jpql, Member.class).getResultList();\n~~~\n\n하지만 문자열로 저렇게 작성하면 오타가 나도 컴파일시점이 아닌 런타임 시점에 알 수 있어 외부 변경에 취약하다.\n\n## Criteria\n\nJPQL을 생성하는 빌더 클래스로 Type Safe하게 사용 할 수 있다. (JPA 2.0 부터 지원)\n\n~~~ java\nCriteriaBuilder cb = em.getCriteriaBuilder();\nCriteriaQuery<Member> query = cb.createQuery(Member.class);\n\nRoot<Member> m = query.from(Member.class);\n\nCriteriaQuery<Member> cq = \n    query.select(m).where(cb.equal(m.get(\"username\"), \"kim\"));\nList<Member> resultList = em.createQuery(cq).getResultList();\n~~~\n\nType Safe 하게 쿼리를 작성하는 것 말고는 코드가 복잡해 지는 단점이 있다.\n\n## Query DSL \n\nCriteria 와 마찬가지로 JPQL 빌더 역활을 하지만 Criteria 보다 간단하고 사용하기 쉽다.\n\n~~~ java\nJPAQuery query = new JPAQuery(em);\nQMember member = QMember.member;\n\nList<Member> members = \n    query.from(member)\n    .where(member.username.eq(\"kim\"))\n    .list(member);\n\n~~~\n\n## Native Query\n\n특정 DB에서 제공하는 기능을 꼭 쓰고 싶을때 사용한다. 예를 들어 ORACLE DB만 제공하는 CONNECT BY 등이다.  \n\n~~~ java\nString sql = \"SELECT ID, NAME FROM MEMBER WHERE NAME = 'kim'\";\nList<Member> resultList = \n    em.createNativeQuery(sql, Member.class).getResultList();\n~~~","source":"_posts/JPA/JPA 쿼리에 대해서.md","raw":"---\ntitle: JPA 쿼리에 대해서\ncatalog: true\ndate: 2019-07-23 10:05:15\nsubtitle: \nheader-img: \"bg_computer.jpg\"\ntags: \n- Learnning\ncatagories:\n- JPA\n---\n\n# 학습목표\n- JPA 쿼리를 왜 사용하는지 이해한다.\n- JPA 쿼리 종류가 어떤것이 있으며 각 장/단점을 각 상황에 따라 실무에 적용 할 줄 안다.\n\n\n# JPA 쿼리!?!? 쿼리를 안써도 되는 줄 알았는데??\n\nJPA를 공부하면서 가장 큰 착각 중에 하나였다.  \n아직도 의문점이 드는게 있고 완벽하진 않지만 하나하나 궁금증을 해결해 가면서 지식을 내것으로 만들어 보겠다.  \n\n## 패러다임 불일치 해결\n\nJPA를 입문할 때 가장 많이 들었던 용어중 하나 였다.  \n의미는 객체지향과 관계지향에 성격이 다른 것을 ORM을 통해 그 불일치를 해결해 준다는 것이다. 나같은 경우는 JAVA 와 RDBMS 였다.  \n\n## 그럼 왜 패러다임 불일치를 해결 할까?\n\n사실 내가 여태껏 웹 개발을 경험하면서 대부분에 비지니스 로직에 초점은 결국 쿼리를 어떻게 작성하느냐고 그 쿼리에 맞춰 DAO, Service, Controller 순으로 개발 하였다.  \nJPA 를 쓰기전에는 Mybatis를 사용하였고 각 기능마다 CRUD 쿼리를 작성해주어야 했다.  \n내가 말하고 싶은 포인트는 자바 OOP로 개발해야 소프트웨어가 변경에 flexible하고 쉬운 유지보수를 할 수 있는데 쿼리 중심으로 맞춰 개발 하다 보니 객체지향 프로그래밍에 장점을 살리지 못하고 있는 것이다.\n\n어쨋든 프로그래밍을 하면서 데이터는 RDB에 넣긴 해야 한다.  넣어야 하는데 그것을 테이블간에 관계도를 생각하면서 쿼리를 작성하는데 초점을 두는것이 아니라 객체간에 관계 참조를 쉽게 코드로 표현 하고 그 표현을 해석하는 ORM, Hibernate, JPA, 영속성 컨텍스트가 감지하여 쿼리를 만들어 DB에 영속화 시키는 것이다.  \n\n이런 중간 역활을 ORM을 함으로써 개발 할 때, 데이터를 영속화 할 때 객체지향으로 개발할 수 있다는점에서 패러다임 불일치를 해결 한다고 말한다고 생각한다.\n\n\n다시 돌아서 제일 처음 궁금증에 대해서 다시 생각해 보면,  ORM, JPA가 패러다임 불일치를 해결한다고 했으니까 나는 쿼리를 작성안하고 객체지향 프로그래밍을 하면 영속성 컨텍스트에서 알아서 쿼리를 만들고 DB에 쿼리를 날리는 것을 생각 하였다.  \n\n하지만 일부만 맞다고 생각이 든다. 왜냐하면 단순히 저장(persist), 수정(객체 속성값 변경), 조회(findAll), 삭제(delete) 기능이라면 쿼리를 작성 할 필요도 없다.  \nJPA가 제공해주는 정확히 Hibernate 가 제공해주는 API를 사용함으로써 **단순 CRUD에 대한 쿼리 작성은 필요 없는것이다.**  \n\n단순 CRUD라고 하였고 **그럼 복잡한 CRUD는 ??** 그때 바로 필요 한게 JPA에서 사용하고 있는 여러 쿼리 작성이 필요 하다고 생각하고 그래서 존재한다고 생각한다.  \n복잡한 애플리케이션 일수록 복잡한 쿼리를 요구 하게 되므로 위 간단한 API 호출로는 한계가 있다. \n\n쿼리라 말하였지만 정확히 객체지향 쿼리이다.  \n하지만 이부분은 아직 잘 공감되지 않는 부분이기도 한데, 객체지향 쿼리라고 하지만 객체지향 쿼리도 모양은 결국 쿼리다.  하지만 객체지향 쿼리라고 말하는 이유는 쿼리를 만드는데 타켓이 데이터베이스에 있는것이 아닌 바로 객체 Entity를 가지고 쿼리를 만들기 때문이다. \n\n# JPA 쿼리 종류 및 장.단점\n\n가장 중요한것은 JPQL이다.  Criteria 이나 Query DSL은 JPQL을 편리하게 사용 하도록 도와주는 기술일 뿐이다.  \n객체지향 쿼리는 DBMS 종류에 관계없이 추상화된 쿼리이니 DBMS를 신경쓰지 않아도 되는 큰 이점이 있다.  본격적으로 쿼리 종류를 알아보면\n\n## JPQL(HQL)\n\n~~~ java\nString jpql = \"select m from Member as m where m.username = 'ryu'\";\nList<Member> resultList = \n    em.createQuery(jpql, Member.class).getResultList();\n~~~\n\n하지만 문자열로 저렇게 작성하면 오타가 나도 컴파일시점이 아닌 런타임 시점에 알 수 있어 외부 변경에 취약하다.\n\n## Criteria\n\nJPQL을 생성하는 빌더 클래스로 Type Safe하게 사용 할 수 있다. (JPA 2.0 부터 지원)\n\n~~~ java\nCriteriaBuilder cb = em.getCriteriaBuilder();\nCriteriaQuery<Member> query = cb.createQuery(Member.class);\n\nRoot<Member> m = query.from(Member.class);\n\nCriteriaQuery<Member> cq = \n    query.select(m).where(cb.equal(m.get(\"username\"), \"kim\"));\nList<Member> resultList = em.createQuery(cq).getResultList();\n~~~\n\nType Safe 하게 쿼리를 작성하는 것 말고는 코드가 복잡해 지는 단점이 있다.\n\n## Query DSL \n\nCriteria 와 마찬가지로 JPQL 빌더 역활을 하지만 Criteria 보다 간단하고 사용하기 쉽다.\n\n~~~ java\nJPAQuery query = new JPAQuery(em);\nQMember member = QMember.member;\n\nList<Member> members = \n    query.from(member)\n    .where(member.username.eq(\"kim\"))\n    .list(member);\n\n~~~\n\n## Native Query\n\n특정 DB에서 제공하는 기능을 꼭 쓰고 싶을때 사용한다. 예를 들어 ORACLE DB만 제공하는 CONNECT BY 등이다.  \n\n~~~ java\nString sql = \"SELECT ID, NAME FROM MEMBER WHERE NAME = 'kim'\";\nList<Member> resultList = \n    em.createNativeQuery(sql, Member.class).getResultList();\n~~~","slug":"JPA/JPA 쿼리에 대해서","published":1,"updated":"2019-07-30T14:11:47.532Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids0v0018k0otzzas3e39","content":"<h1><span id=\"학습목표\">학습목표</span></h1>\n<ul>\n<li>JPA 쿼리를 왜 사용하는지 이해한다.</li>\n<li>JPA 쿼리 종류가 어떤것이 있으며 각 장/단점을 각 상황에 따라 실무에 적용 할 줄 안다.</li>\n</ul>\n<h1><span id=\"jpa-쿼리-쿼리를-안써도-되는-줄-알았는데\">JPA 쿼리!?!? 쿼리를 안써도 되는 줄 알았는데??</span></h1>\n<p>JPA를 공부하면서 가장 큰 착각 중에 하나였다.<br>\n아직도 의문점이 드는게 있고 완벽하진 않지만 하나하나 궁금증을 해결해 가면서 지식을 내것으로 만들어 보겠다.</p>\n<h2><span id=\"패러다임-불일치-해결\">패러다임 불일치 해결</span></h2>\n<p>JPA를 입문할 때 가장 많이 들었던 용어중 하나 였다.<br>\n의미는 객체지향과 관계지향에 성격이 다른 것을 ORM을 통해 그 불일치를 해결해 준다는 것이다. 나같은 경우는 JAVA 와 RDBMS 였다.</p>\n<h2><span id=\"그럼-왜-패러다임-불일치를-해결-할까\">그럼 왜 패러다임 불일치를 해결 할까?</span></h2>\n<p>사실 내가 여태껏 웹 개발을 경험하면서 대부분에 비지니스 로직에 초점은 결국 쿼리를 어떻게 작성하느냐고 그 쿼리에 맞춰 DAO, Service, Controller 순으로 개발 하였다.<br>\nJPA 를 쓰기전에는 Mybatis를 사용하였고 각 기능마다 CRUD 쿼리를 작성해주어야 했다.<br>\n내가 말하고 싶은 포인트는 자바 OOP로 개발해야 소프트웨어가 변경에 flexible하고 쉬운 유지보수를 할 수 있는데 쿼리 중심으로 맞춰 개발 하다 보니 객체지향 프로그래밍에 장점을 살리지 못하고 있는 것이다.</p>\n<p>어쨋든 프로그래밍을 하면서 데이터는 RDB에 넣긴 해야 한다.  넣어야 하는데 그것을 테이블간에 관계도를 생각하면서 쿼리를 작성하는데 초점을 두는것이 아니라 객체간에 관계 참조를 쉽게 코드로 표현 하고 그 표현을 해석하는 ORM, Hibernate, JPA, 영속성 컨텍스트가 감지하여 쿼리를 만들어 DB에 영속화 시키는 것이다.</p>\n<p>이런 중간 역활을 ORM을 함으로써 개발 할 때, 데이터를 영속화 할 때 객체지향으로 개발할 수 있다는점에서 패러다임 불일치를 해결 한다고 말한다고 생각한다.</p>\n<p>다시 돌아서 제일 처음 궁금증에 대해서 다시 생각해 보면,  ORM, JPA가 패러다임 불일치를 해결한다고 했으니까 나는 쿼리를 작성안하고 객체지향 프로그래밍을 하면 영속성 컨텍스트에서 알아서 쿼리를 만들고 DB에 쿼리를 날리는 것을 생각 하였다.</p>\n<p>하지만 일부만 맞다고 생각이 든다. 왜냐하면 단순히 저장(persist), 수정(객체 속성값 변경), 조회(findAll), 삭제(delete) 기능이라면 쿼리를 작성 할 필요도 없다.<br>\nJPA가 제공해주는 정확히 Hibernate 가 제공해주는 API를 사용함으로써 <strong>단순 CRUD에 대한 쿼리 작성은 필요 없는것이다.</strong></p>\n<p>단순 CRUD라고 하였고 <strong>그럼 복잡한 CRUD는 ??</strong> 그때 바로 필요 한게 JPA에서 사용하고 있는 여러 쿼리 작성이 필요 하다고 생각하고 그래서 존재한다고 생각한다.<br>\n복잡한 애플리케이션 일수록 복잡한 쿼리를 요구 하게 되므로 위 간단한 API 호출로는 한계가 있다.</p>\n<p>쿼리라 말하였지만 정확히 객체지향 쿼리이다.<br>\n하지만 이부분은 아직 잘 공감되지 않는 부분이기도 한데, 객체지향 쿼리라고 하지만 객체지향 쿼리도 모양은 결국 쿼리다.  하지만 객체지향 쿼리라고 말하는 이유는 쿼리를 만드는데 타켓이 데이터베이스에 있는것이 아닌 바로 객체 Entity를 가지고 쿼리를 만들기 때문이다.</p>\n<h1><span id=\"jpa-쿼리-종류-및-장단점\">JPA 쿼리 종류 및 장.단점</span></h1>\n<p>가장 중요한것은 JPQL이다.  Criteria 이나 Query DSL은 JPQL을 편리하게 사용 하도록 도와주는 기술일 뿐이다.<br>\n객체지향 쿼리는 DBMS 종류에 관계없이 추상화된 쿼리이니 DBMS를 신경쓰지 않아도 되는 큰 이점이 있다.  본격적으로 쿼리 종류를 알아보면</p>\n<h2><span id=\"jpqlhql\">JPQL(HQL)</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String jpql = <span class=\"string\">\"select m from Member as m where m.username = 'ryu'\"</span>;</span><br><span class=\"line\">List&lt;Member&gt; resultList = </span><br><span class=\"line\">    em.createQuery(jpql, Member.class).getResultList();</span><br></pre></td></tr></table></figure>\n<p>하지만 문자열로 저렇게 작성하면 오타가 나도 컴파일시점이 아닌 런타임 시점에 알 수 있어 외부 변경에 취약하다.</p>\n<h2><span id=\"criteria\">Criteria</span></h2>\n<p>JPQL을 생성하는 빌더 클래스로 Type Safe하게 사용 할 수 있다. (JPA 2.0 부터 지원)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CriteriaBuilder cb = em.getCriteriaBuilder();</span><br><span class=\"line\">CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class);</span><br><span class=\"line\"></span><br><span class=\"line\">Root&lt;Member&gt; m = query.from(Member.class);</span><br><span class=\"line\"></span><br><span class=\"line\">CriteriaQuery&lt;Member&gt; cq = </span><br><span class=\"line\">    query.select(m).where(cb.equal(m.get(<span class=\"string\">\"username\"</span>), <span class=\"string\">\"kim\"</span>));</span><br><span class=\"line\">List&lt;Member&gt; resultList = em.createQuery(cq).getResultList();</span><br></pre></td></tr></table></figure>\n<p>Type Safe 하게 쿼리를 작성하는 것 말고는 코드가 복잡해 지는 단점이 있다.</p>\n<h2><span id=\"query-dsl\">Query DSL</span></h2>\n<p>Criteria 와 마찬가지로 JPQL 빌더 역활을 하지만 Criteria 보다 간단하고 사용하기 쉽다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JPAQuery query = <span class=\"keyword\">new</span> JPAQuery(em);</span><br><span class=\"line\">QMember member = QMember.member;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Member&gt; members = </span><br><span class=\"line\">    query.from(member)</span><br><span class=\"line\">    .where(member.username.eq(<span class=\"string\">\"kim\"</span>))</span><br><span class=\"line\">    .list(member);</span><br></pre></td></tr></table></figure>\n<h2><span id=\"native-query\">Native Query</span></h2>\n<p>특정 DB에서 제공하는 기능을 꼭 쓰고 싶을때 사용한다. 예를 들어 ORACLE DB만 제공하는 CONNECT BY 등이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String sql = <span class=\"string\">\"SELECT ID, NAME FROM MEMBER WHERE NAME = 'kim'\"</span>;</span><br><span class=\"line\">List&lt;Member&gt; resultList = </span><br><span class=\"line\">    em.createNativeQuery(sql, Member.class).getResultList();</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1>학습목표</h1>\n<ul>\n<li>JPA 쿼리를 왜 사용하는지 이해한다.</li>\n<li>JPA 쿼리 종류가 어떤것이 있으며 각 장/단점을 각 상황에 따라 실무에 적용 할 줄 안다.</li>\n</ul>\n<h1>JPA 쿼리!?!? 쿼리를 안써도 되는 줄 알았는데??</h1>\n<p>JPA를 공부하면서 가장 큰 착각 중에 하나였다.<br>\n아직도 의문점이 드는게 있고 완벽하진 않지만 하나하나 궁금증을 해결해 가면서 지식을 내것으로 만들어 보겠다.</p>\n<h2>패러다임 불일치 해결</h2>\n<p>JPA를 입문할 때 가장 많이 들었던 용어중 하나 였다.<br>\n의미는 객체지향과 관계지향에 성격이 다른 것을 ORM을 통해 그 불일치를 해결해 준다는 것이다. 나같은 경우는 JAVA 와 RDBMS 였다.</p>\n<h2>그럼 왜 패러다임 불일치를 해결 할까?</h2>\n<p>사실 내가 여태껏 웹 개발을 경험하면서 대부분에 비지니스 로직에 초점은 결국 쿼리를 어떻게 작성하느냐고 그 쿼리에 맞춰 DAO, Service, Controller 순으로 개발 하였다.<br>\nJPA 를 쓰기전에는 Mybatis를 사용하였고 각 기능마다 CRUD 쿼리를 작성해주어야 했다.<br>\n내가 말하고 싶은 포인트는 자바 OOP로 개발해야 소프트웨어가 변경에 flexible하고 쉬운 유지보수를 할 수 있는데 쿼리 중심으로 맞춰 개발 하다 보니 객체지향 프로그래밍에 장점을 살리지 못하고 있는 것이다.</p>\n<p>어쨋든 프로그래밍을 하면서 데이터는 RDB에 넣긴 해야 한다.  넣어야 하는데 그것을 테이블간에 관계도를 생각하면서 쿼리를 작성하는데 초점을 두는것이 아니라 객체간에 관계 참조를 쉽게 코드로 표현 하고 그 표현을 해석하는 ORM, Hibernate, JPA, 영속성 컨텍스트가 감지하여 쿼리를 만들어 DB에 영속화 시키는 것이다.</p>\n<p>이런 중간 역활을 ORM을 함으로써 개발 할 때, 데이터를 영속화 할 때 객체지향으로 개발할 수 있다는점에서 패러다임 불일치를 해결 한다고 말한다고 생각한다.</p>\n<p>다시 돌아서 제일 처음 궁금증에 대해서 다시 생각해 보면,  ORM, JPA가 패러다임 불일치를 해결한다고 했으니까 나는 쿼리를 작성안하고 객체지향 프로그래밍을 하면 영속성 컨텍스트에서 알아서 쿼리를 만들고 DB에 쿼리를 날리는 것을 생각 하였다.</p>\n<p>하지만 일부만 맞다고 생각이 든다. 왜냐하면 단순히 저장(persist), 수정(객체 속성값 변경), 조회(findAll), 삭제(delete) 기능이라면 쿼리를 작성 할 필요도 없다.<br>\nJPA가 제공해주는 정확히 Hibernate 가 제공해주는 API를 사용함으로써 <strong>단순 CRUD에 대한 쿼리 작성은 필요 없는것이다.</strong></p>\n<p>단순 CRUD라고 하였고 <strong>그럼 복잡한 CRUD는 ??</strong> 그때 바로 필요 한게 JPA에서 사용하고 있는 여러 쿼리 작성이 필요 하다고 생각하고 그래서 존재한다고 생각한다.<br>\n복잡한 애플리케이션 일수록 복잡한 쿼리를 요구 하게 되므로 위 간단한 API 호출로는 한계가 있다.</p>\n<p>쿼리라 말하였지만 정확히 객체지향 쿼리이다.<br>\n하지만 이부분은 아직 잘 공감되지 않는 부분이기도 한데, 객체지향 쿼리라고 하지만 객체지향 쿼리도 모양은 결국 쿼리다.  하지만 객체지향 쿼리라고 말하는 이유는 쿼리를 만드는데 타켓이 데이터베이스에 있는것이 아닌 바로 객체 Entity를 가지고 쿼리를 만들기 때문이다.</p>\n<h1>JPA 쿼리 종류 및 장.단점</h1>\n<p>가장 중요한것은 JPQL이다.  Criteria 이나 Query DSL은 JPQL을 편리하게 사용 하도록 도와주는 기술일 뿐이다.<br>\n객체지향 쿼리는 DBMS 종류에 관계없이 추상화된 쿼리이니 DBMS를 신경쓰지 않아도 되는 큰 이점이 있다.  본격적으로 쿼리 종류를 알아보면</p>\n<h2>JPQL(HQL)</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String jpql = <span class=\"string\">\"select m from Member as m where m.username = 'ryu'\"</span>;</span><br><span class=\"line\">List&lt;Member&gt; resultList = </span><br><span class=\"line\">    em.createQuery(jpql, Member.class).getResultList();</span><br></pre></td></tr></table></figure>\n<p>하지만 문자열로 저렇게 작성하면 오타가 나도 컴파일시점이 아닌 런타임 시점에 알 수 있어 외부 변경에 취약하다.</p>\n<h2>Criteria</h2>\n<p>JPQL을 생성하는 빌더 클래스로 Type Safe하게 사용 할 수 있다. (JPA 2.0 부터 지원)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CriteriaBuilder cb = em.getCriteriaBuilder();</span><br><span class=\"line\">CriteriaQuery&lt;Member&gt; query = cb.createQuery(Member.class);</span><br><span class=\"line\"></span><br><span class=\"line\">Root&lt;Member&gt; m = query.from(Member.class);</span><br><span class=\"line\"></span><br><span class=\"line\">CriteriaQuery&lt;Member&gt; cq = </span><br><span class=\"line\">    query.select(m).where(cb.equal(m.get(<span class=\"string\">\"username\"</span>), <span class=\"string\">\"kim\"</span>));</span><br><span class=\"line\">List&lt;Member&gt; resultList = em.createQuery(cq).getResultList();</span><br></pre></td></tr></table></figure>\n<p>Type Safe 하게 쿼리를 작성하는 것 말고는 코드가 복잡해 지는 단점이 있다.</p>\n<h2>Query DSL</h2>\n<p>Criteria 와 마찬가지로 JPQL 빌더 역활을 하지만 Criteria 보다 간단하고 사용하기 쉽다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JPAQuery query = <span class=\"keyword\">new</span> JPAQuery(em);</span><br><span class=\"line\">QMember member = QMember.member;</span><br><span class=\"line\"></span><br><span class=\"line\">List&lt;Member&gt; members = </span><br><span class=\"line\">    query.from(member)</span><br><span class=\"line\">    .where(member.username.eq(<span class=\"string\">\"kim\"</span>))</span><br><span class=\"line\">    .list(member);</span><br></pre></td></tr></table></figure>\n<h2>Native Query</h2>\n<p>특정 DB에서 제공하는 기능을 꼭 쓰고 싶을때 사용한다. 예를 들어 ORACLE DB만 제공하는 CONNECT BY 등이다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String sql = <span class=\"string\">\"SELECT ID, NAME FROM MEMBER WHERE NAME = 'kim'\"</span>;</span><br><span class=\"line\">List&lt;Member&gt; resultList = </span><br><span class=\"line\">    em.createNativeQuery(sql, Member.class).getResultList();</span><br></pre></td></tr></table></figure>"},{"title":"01. 객체,설계","catalog":true,"date":"2019-07-10T14:55:15.000Z","subtitle":"오브젝트 - 코드로 이해하는 객체지향 설계를 읽고","header-img":"","_content":"\n### 티켓 판매 애플리케이션 기능 설명\n---\n- 이벤트 당첨된 사람은 당첨 여부 확인 후 입장 시킨다.\n- 아닌 사람은 티켓을 구매하여 입장 시킨다.\n- 도메인은 관람객, 가방, 초대권, 티켓, 소극장 이다.\n\n\n### 무엇이 문제인가\n---\n- 관람객, 판매원이 스스로 해동해야 하는 것들 (예, 관람객이 자기 가방에서 티켓을 꺼내는 행동)을 소극장이 하고 있다.\n\n- 소극장이 한다는 것은 접근을 허용했다는 것이고 이는 불필요한 접근으로 불필요한 코드를 만들어 낸다. 결국 코드 변경이 이루어 졌을 때 의존성이 생겨 이곳 저곳 수정해야 하는 일이 발생한다.\n\n- \n\n### 문제 분석\n---\n\n#### 예상을 빗나가는 코드\n- 관람객, 판매원이 스스로 해야 할 일을 소극장이 접근한다. 상식에 맞지 않음\n- 상식에 벗어나는 코드는 이해하기가 어렵고 개발자끼리 서로 소통하기도 어렵다.\n\n\n#### 캡슐화가 제대로 되지 않았다.\n- 캡슐화가 제대로 안되면 외부에서 코드 접근이 쉽다는 말이다.\n- 그러면 쉽게 외부와 연결이 이루어져 의존성을 강하게 결합시키는 꼴이 된다.\n- 결국 변경에 취약하게 된다.\n\n#### 변경에 취약한 코드\n- 객체지향으로 설계하고 구현하는 이유는 빈번하게 바뀔 요구사항을 쉽게 코드를 변경/수정 할 수 있게 하기 위함이다.\n- 의존성이 강하게 결합되면 변경에 취약하다.\n\n\n### 설계 개선하기\n---\n\n#### 자율성을 높이자\n- 객체에 역활과 책임에 맞게 최대한 내부적으로 수행한다.\n- 외부로는 인터페이스(호출 함수, 수퍼클래스 등)를 제공한다.\n- 외부에서는 인터페이스만 바라 보면 되므로 캡슐화한 객체가 변경되더라도 외부에는 영향을 미치지 않는다.\n\n\n### 핵심 내용\n---\n- 객체 내부는 자율성을 가지고 최소한에 접근으로 의존성을 최소화 한다.\n- 그러면 변경에 자유롭다. 왜냐면 외부에서 접근하여 코드를 망치지 않으므로\n- 진정한 객체지향 설계로 나아가는 것은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에는 용이한 설계를 만드는 것","source":"_posts/OOP/01 객체,설계.md","raw":"---\ntitle: 01. 객체,설계\ncatalog: true\ndate: 2019-07-10 23:55:15\nsubtitle: 오브젝트 - 코드로 이해하는 객체지향 설계를 읽고\nheader-img: \"\"\ncategories:\n- 객체지향프로그래밍\ntags: \n- Book\n---\n\n### 티켓 판매 애플리케이션 기능 설명\n---\n- 이벤트 당첨된 사람은 당첨 여부 확인 후 입장 시킨다.\n- 아닌 사람은 티켓을 구매하여 입장 시킨다.\n- 도메인은 관람객, 가방, 초대권, 티켓, 소극장 이다.\n\n\n### 무엇이 문제인가\n---\n- 관람객, 판매원이 스스로 해동해야 하는 것들 (예, 관람객이 자기 가방에서 티켓을 꺼내는 행동)을 소극장이 하고 있다.\n\n- 소극장이 한다는 것은 접근을 허용했다는 것이고 이는 불필요한 접근으로 불필요한 코드를 만들어 낸다. 결국 코드 변경이 이루어 졌을 때 의존성이 생겨 이곳 저곳 수정해야 하는 일이 발생한다.\n\n- \n\n### 문제 분석\n---\n\n#### 예상을 빗나가는 코드\n- 관람객, 판매원이 스스로 해야 할 일을 소극장이 접근한다. 상식에 맞지 않음\n- 상식에 벗어나는 코드는 이해하기가 어렵고 개발자끼리 서로 소통하기도 어렵다.\n\n\n#### 캡슐화가 제대로 되지 않았다.\n- 캡슐화가 제대로 안되면 외부에서 코드 접근이 쉽다는 말이다.\n- 그러면 쉽게 외부와 연결이 이루어져 의존성을 강하게 결합시키는 꼴이 된다.\n- 결국 변경에 취약하게 된다.\n\n#### 변경에 취약한 코드\n- 객체지향으로 설계하고 구현하는 이유는 빈번하게 바뀔 요구사항을 쉽게 코드를 변경/수정 할 수 있게 하기 위함이다.\n- 의존성이 강하게 결합되면 변경에 취약하다.\n\n\n### 설계 개선하기\n---\n\n#### 자율성을 높이자\n- 객체에 역활과 책임에 맞게 최대한 내부적으로 수행한다.\n- 외부로는 인터페이스(호출 함수, 수퍼클래스 등)를 제공한다.\n- 외부에서는 인터페이스만 바라 보면 되므로 캡슐화한 객체가 변경되더라도 외부에는 영향을 미치지 않는다.\n\n\n### 핵심 내용\n---\n- 객체 내부는 자율성을 가지고 최소한에 접근으로 의존성을 최소화 한다.\n- 그러면 변경에 자유롭다. 왜냐면 외부에서 접근하여 코드를 망치지 않으므로\n- 진정한 객체지향 설계로 나아가는 것은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에는 용이한 설계를 만드는 것","slug":"OOP/01 객체,설계","published":1,"updated":"2019-08-18T06:25:25.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids0x001ak0otxs44og5a","content":"<h3><span id=\"티켓-판매-애플리케이션-기능-설명\">티켓 판매 애플리케이션 기능 설명</span></h3>\n<hr>\n<ul>\n<li>이벤트 당첨된 사람은 당첨 여부 확인 후 입장 시킨다.</li>\n<li>아닌 사람은 티켓을 구매하여 입장 시킨다.</li>\n<li>도메인은 관람객, 가방, 초대권, 티켓, 소극장 이다.</li>\n</ul>\n<h3><span id=\"무엇이-문제인가\">무엇이 문제인가</span></h3>\n<hr>\n<ul>\n<li>\n<p>관람객, 판매원이 스스로 해동해야 하는 것들 (예, 관람객이 자기 가방에서 티켓을 꺼내는 행동)을 소극장이 하고 있다.</p>\n</li>\n<li>\n<p>소극장이 한다는 것은 접근을 허용했다는 것이고 이는 불필요한 접근으로 불필요한 코드를 만들어 낸다. 결국 코드 변경이 이루어 졌을 때 의존성이 생겨 이곳 저곳 수정해야 하는 일이 발생한다.</p>\n</li>\n<li></li>\n</ul>\n<h3><span id=\"문제-분석\">문제 분석</span></h3>\n<hr>\n<h4><span id=\"예상을-빗나가는-코드\">예상을 빗나가는 코드</span></h4>\n<ul>\n<li>관람객, 판매원이 스스로 해야 할 일을 소극장이 접근한다. 상식에 맞지 않음</li>\n<li>상식에 벗어나는 코드는 이해하기가 어렵고 개발자끼리 서로 소통하기도 어렵다.</li>\n</ul>\n<h4><span id=\"캡슐화가-제대로-되지-않았다\">캡슐화가 제대로 되지 않았다.</span></h4>\n<ul>\n<li>캡슐화가 제대로 안되면 외부에서 코드 접근이 쉽다는 말이다.</li>\n<li>그러면 쉽게 외부와 연결이 이루어져 의존성을 강하게 결합시키는 꼴이 된다.</li>\n<li>결국 변경에 취약하게 된다.</li>\n</ul>\n<h4><span id=\"변경에-취약한-코드\">변경에 취약한 코드</span></h4>\n<ul>\n<li>객체지향으로 설계하고 구현하는 이유는 빈번하게 바뀔 요구사항을 쉽게 코드를 변경/수정 할 수 있게 하기 위함이다.</li>\n<li>의존성이 강하게 결합되면 변경에 취약하다.</li>\n</ul>\n<h3><span id=\"설계-개선하기\">설계 개선하기</span></h3>\n<hr>\n<h4><span id=\"자율성을-높이자\">자율성을 높이자</span></h4>\n<ul>\n<li>객체에 역활과 책임에 맞게 최대한 내부적으로 수행한다.</li>\n<li>외부로는 인터페이스(호출 함수, 수퍼클래스 등)를 제공한다.</li>\n<li>외부에서는 인터페이스만 바라 보면 되므로 캡슐화한 객체가 변경되더라도 외부에는 영향을 미치지 않는다.</li>\n</ul>\n<h3><span id=\"핵심-내용\">핵심 내용</span></h3>\n<hr>\n<ul>\n<li>객체 내부는 자율성을 가지고 최소한에 접근으로 의존성을 최소화 한다.</li>\n<li>그러면 변경에 자유롭다. 왜냐면 외부에서 접근하여 코드를 망치지 않으므로</li>\n<li>진정한 객체지향 설계로 나아가는 것은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에는 용이한 설계를 만드는 것</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3>티켓 판매 애플리케이션 기능 설명</h3>\n<hr>\n<ul>\n<li>이벤트 당첨된 사람은 당첨 여부 확인 후 입장 시킨다.</li>\n<li>아닌 사람은 티켓을 구매하여 입장 시킨다.</li>\n<li>도메인은 관람객, 가방, 초대권, 티켓, 소극장 이다.</li>\n</ul>\n<h3>무엇이 문제인가</h3>\n<hr>\n<ul>\n<li>\n<p>관람객, 판매원이 스스로 해동해야 하는 것들 (예, 관람객이 자기 가방에서 티켓을 꺼내는 행동)을 소극장이 하고 있다.</p>\n</li>\n<li>\n<p>소극장이 한다는 것은 접근을 허용했다는 것이고 이는 불필요한 접근으로 불필요한 코드를 만들어 낸다. 결국 코드 변경이 이루어 졌을 때 의존성이 생겨 이곳 저곳 수정해야 하는 일이 발생한다.</p>\n</li>\n<li></li>\n</ul>\n<h3>문제 분석</h3>\n<hr>\n<h4>예상을 빗나가는 코드</h4>\n<ul>\n<li>관람객, 판매원이 스스로 해야 할 일을 소극장이 접근한다. 상식에 맞지 않음</li>\n<li>상식에 벗어나는 코드는 이해하기가 어렵고 개발자끼리 서로 소통하기도 어렵다.</li>\n</ul>\n<h4>캡슐화가 제대로 되지 않았다.</h4>\n<ul>\n<li>캡슐화가 제대로 안되면 외부에서 코드 접근이 쉽다는 말이다.</li>\n<li>그러면 쉽게 외부와 연결이 이루어져 의존성을 강하게 결합시키는 꼴이 된다.</li>\n<li>결국 변경에 취약하게 된다.</li>\n</ul>\n<h4>변경에 취약한 코드</h4>\n<ul>\n<li>객체지향으로 설계하고 구현하는 이유는 빈번하게 바뀔 요구사항을 쉽게 코드를 변경/수정 할 수 있게 하기 위함이다.</li>\n<li>의존성이 강하게 결합되면 변경에 취약하다.</li>\n</ul>\n<h3>설계 개선하기</h3>\n<hr>\n<h4>자율성을 높이자</h4>\n<ul>\n<li>객체에 역활과 책임에 맞게 최대한 내부적으로 수행한다.</li>\n<li>외부로는 인터페이스(호출 함수, 수퍼클래스 등)를 제공한다.</li>\n<li>외부에서는 인터페이스만 바라 보면 되므로 캡슐화한 객체가 변경되더라도 외부에는 영향을 미치지 않는다.</li>\n</ul>\n<h3>핵심 내용</h3>\n<hr>\n<ul>\n<li>객체 내부는 자율성을 가지고 최소한에 접근으로 의존성을 최소화 한다.</li>\n<li>그러면 변경에 자유롭다. 왜냐면 외부에서 접근하여 코드를 망치지 않으므로</li>\n<li>진정한 객체지향 설계로 나아가는 것은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에는 용이한 설계를 만드는 것</li>\n</ul>\n"},{"title":"02. 객체 지향 프로그래밍","catalog":true,"date":"2019-07-11T14:55:15.000Z","subtitle":"오브젝트 - 코드로 이해하는 객체지향 설계를 읽고","header-img":"","_content":"\n### 객체지향 프로그래밍 이란\n\n- 객체(도메인)가 중심이 되어서 객체와 객체간 메세지를 주고 받으면서 역활과 책임을 다하며 설계와 구현을 유연하게 하여 변경에 자유롭게 하기 위한 프로그래밍 기법\n\n\n### 객체지향 프로그래밍 할 때 중요한 점\n\n- 먼저 객체간 주고 받을 메세지 협력에 대해서 정의한 후에 각 각체에 적절한 역활과 책임을 부여한다.\n- 클래스로 코드를 어떻게 구현 할지를 생각하는게 아니라 객체 관점에서 서로 어떻게 역활과 책임을 정의하고 그것을 구현하는 메커니즘 중에 하나인 클래스로 구현하는 것이다.\n\n\n### 상속보다는 집합을 사용하라\n\n- 캡슐화 위배 된다.\n- 상속을 받고 구현하려면 부모 클래스에 추상 메소드들 알아야 한다. \n- 부모 클래스에 구현이 자식에게 노출 되므로 그것은 곧 부모 코드를 사용하여 의존하는 코드를 낳음\n- 결과적으로 부모 코드를 변경할 때 자식 코드도 변경할 확률이 높아지고 변경에 취약한 결과를 낳는다.\n\n### 상속을 사용하는 이유는 코드 재사용이 아니다.\n\n- 더 중요한 이유는 자식 타입이 부모 타입을 사용 할 수 있어 다형성을 통해 설계 및 코드가 유연해 지기 때문이다.\n\n\n### 상속은 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.\n\n해당 내용 조사 필요 이해 잘 안감..\n\n### 다형성\n\n- 동일한 메세지를 수신했을 때, 각 다른 객체 타입에 응답이 각각 다르게 할 수 있다.\n- 클라이언트 코드에서 보낸 메세지에 응답하는 시점은 컴파일 시점이 아니라 실행 시점이다. 그래서 객체지향 프로그래밍이 유연하다고 하는 것이다. 이를 지연 바인딩, 동적 바인딩이라 함\n","source":"_posts/OOP/02 객체 지향 프로그래밍.md","raw":"---\ntitle: 02. 객체 지향 프로그래밍\ncatalog: true\ndate: 2019-07-11 23:55:15\nsubtitle: 오브젝트 - 코드로 이해하는 객체지향 설계를 읽고\nheader-img: \"\"\ncategories:\n- 객체지향프로그래밍\ntags: \n- Book\n---\n\n### 객체지향 프로그래밍 이란\n\n- 객체(도메인)가 중심이 되어서 객체와 객체간 메세지를 주고 받으면서 역활과 책임을 다하며 설계와 구현을 유연하게 하여 변경에 자유롭게 하기 위한 프로그래밍 기법\n\n\n### 객체지향 프로그래밍 할 때 중요한 점\n\n- 먼저 객체간 주고 받을 메세지 협력에 대해서 정의한 후에 각 각체에 적절한 역활과 책임을 부여한다.\n- 클래스로 코드를 어떻게 구현 할지를 생각하는게 아니라 객체 관점에서 서로 어떻게 역활과 책임을 정의하고 그것을 구현하는 메커니즘 중에 하나인 클래스로 구현하는 것이다.\n\n\n### 상속보다는 집합을 사용하라\n\n- 캡슐화 위배 된다.\n- 상속을 받고 구현하려면 부모 클래스에 추상 메소드들 알아야 한다. \n- 부모 클래스에 구현이 자식에게 노출 되므로 그것은 곧 부모 코드를 사용하여 의존하는 코드를 낳음\n- 결과적으로 부모 코드를 변경할 때 자식 코드도 변경할 확률이 높아지고 변경에 취약한 결과를 낳는다.\n\n### 상속을 사용하는 이유는 코드 재사용이 아니다.\n\n- 더 중요한 이유는 자식 타입이 부모 타입을 사용 할 수 있어 다형성을 통해 설계 및 코드가 유연해 지기 때문이다.\n\n\n### 상속은 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.\n\n해당 내용 조사 필요 이해 잘 안감..\n\n### 다형성\n\n- 동일한 메세지를 수신했을 때, 각 다른 객체 타입에 응답이 각각 다르게 할 수 있다.\n- 클라이언트 코드에서 보낸 메세지에 응답하는 시점은 컴파일 시점이 아니라 실행 시점이다. 그래서 객체지향 프로그래밍이 유연하다고 하는 것이다. 이를 지연 바인딩, 동적 바인딩이라 함\n","slug":"OOP/02 객체 지향 프로그래밍","published":1,"updated":"2019-08-18T06:08:59.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids0y001dk0otqzxz4913","content":"<h3><span id=\"객체지향-프로그래밍-이란\">객체지향 프로그래밍 이란</span></h3>\n<ul>\n<li>객체(도메인)가 중심이 되어서 객체와 객체간 메세지를 주고 받으면서 역활과 책임을 다하며 설계와 구현을 유연하게 하여 변경에 자유롭게 하기 위한 프로그래밍 기법</li>\n</ul>\n<h3><span id=\"객체지향-프로그래밍-할-때-중요한-점\">객체지향 프로그래밍 할 때 중요한 점</span></h3>\n<ul>\n<li>먼저 객체간 주고 받을 메세지 협력에 대해서 정의한 후에 각 각체에 적절한 역활과 책임을 부여한다.</li>\n<li>클래스로 코드를 어떻게 구현 할지를 생각하는게 아니라 객체 관점에서 서로 어떻게 역활과 책임을 정의하고 그것을 구현하는 메커니즘 중에 하나인 클래스로 구현하는 것이다.</li>\n</ul>\n<h3><span id=\"상속보다는-집합을-사용하라\">상속보다는 집합을 사용하라</span></h3>\n<ul>\n<li>캡슐화 위배 된다.</li>\n<li>상속을 받고 구현하려면 부모 클래스에 추상 메소드들 알아야 한다.</li>\n<li>부모 클래스에 구현이 자식에게 노출 되므로 그것은 곧 부모 코드를 사용하여 의존하는 코드를 낳음</li>\n<li>결과적으로 부모 코드를 변경할 때 자식 코드도 변경할 확률이 높아지고 변경에 취약한 결과를 낳는다.</li>\n</ul>\n<h3><span id=\"상속을-사용하는-이유는-코드-재사용이-아니다\">상속을 사용하는 이유는 코드 재사용이 아니다.</span></h3>\n<ul>\n<li>더 중요한 이유는 자식 타입이 부모 타입을 사용 할 수 있어 다형성을 통해 설계 및 코드가 유연해 지기 때문이다.</li>\n</ul>\n<h3><span id=\"상속은-실행-시점에-객체의-종류를-변경하는-것이-불가능하다\">상속은 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.</span></h3>\n<p>해당 내용 조사 필요 이해 잘 안감…</p>\n<h3><span id=\"다형성\">다형성</span></h3>\n<ul>\n<li>동일한 메세지를 수신했을 때, 각 다른 객체 타입에 응답이 각각 다르게 할 수 있다.</li>\n<li>클라이언트 코드에서 보낸 메세지에 응답하는 시점은 컴파일 시점이 아니라 실행 시점이다. 그래서 객체지향 프로그래밍이 유연하다고 하는 것이다. 이를 지연 바인딩, 동적 바인딩이라 함</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3>객체지향 프로그래밍 이란</h3>\n<ul>\n<li>객체(도메인)가 중심이 되어서 객체와 객체간 메세지를 주고 받으면서 역활과 책임을 다하며 설계와 구현을 유연하게 하여 변경에 자유롭게 하기 위한 프로그래밍 기법</li>\n</ul>\n<h3>객체지향 프로그래밍 할 때 중요한 점</h3>\n<ul>\n<li>먼저 객체간 주고 받을 메세지 협력에 대해서 정의한 후에 각 각체에 적절한 역활과 책임을 부여한다.</li>\n<li>클래스로 코드를 어떻게 구현 할지를 생각하는게 아니라 객체 관점에서 서로 어떻게 역활과 책임을 정의하고 그것을 구현하는 메커니즘 중에 하나인 클래스로 구현하는 것이다.</li>\n</ul>\n<h3>상속보다는 집합을 사용하라</h3>\n<ul>\n<li>캡슐화 위배 된다.</li>\n<li>상속을 받고 구현하려면 부모 클래스에 추상 메소드들 알아야 한다.</li>\n<li>부모 클래스에 구현이 자식에게 노출 되므로 그것은 곧 부모 코드를 사용하여 의존하는 코드를 낳음</li>\n<li>결과적으로 부모 코드를 변경할 때 자식 코드도 변경할 확률이 높아지고 변경에 취약한 결과를 낳는다.</li>\n</ul>\n<h3>상속을 사용하는 이유는 코드 재사용이 아니다.</h3>\n<ul>\n<li>더 중요한 이유는 자식 타입이 부모 타입을 사용 할 수 있어 다형성을 통해 설계 및 코드가 유연해 지기 때문이다.</li>\n</ul>\n<h3>상속은 실행 시점에 객체의 종류를 변경하는 것이 불가능하다.</h3>\n<p>해당 내용 조사 필요 이해 잘 안감…</p>\n<h3>다형성</h3>\n<ul>\n<li>동일한 메세지를 수신했을 때, 각 다른 객체 타입에 응답이 각각 다르게 할 수 있다.</li>\n<li>클라이언트 코드에서 보낸 메세지에 응답하는 시점은 컴파일 시점이 아니라 실행 시점이다. 그래서 객체지향 프로그래밍이 유연하다고 하는 것이다. 이를 지연 바인딩, 동적 바인딩이라 함</li>\n</ul>\n"},{"title":"객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유","catalog":true,"date":"2019-07-28T15:08:00.000Z","subtitle":"추상화, 결합도, 응집도를 잘 활용해야 변경에 유연해 진다.","header-img":"","_content":"\n### 왜 OOP를 할 때 데이터 중심으로 하면 안될까??\n\n데이터는 구현이다. 여기서 말하는 구현은 객체의 상태값이 될수도 있고 객체가 수행하는 로직이 될 수 도 있다. 즉, 객체 내부에서만 접근 가능한 것들이다.\n구현은 얼마든지 변경이 생길수 있기 때문에 데이터 중심으로 객체간 협력을 하게 되면 변경에 취약하게 된다.  \n\n책임은 인터페이스다. 책임 중심으로 이 객체는 어떤 책임을 가져야하는가? 라는 물음으로 객체를 설계하면 객체의 내부 구현은 캡슐화 화면서 설계 할 수 있기 때문에  \n코드 응집도 높고 변경에 유연한 설계를 얻을 수 있게 된다.  \n\n\n### 데이터 중심 객체 설게 문제점 1 - 캡슐화 위반\n\n객체가 어떤 책임을 가져야 하는지 알 수 있을려면 이 객체가 다른 객체와 어떤 협력을 해야햐는지 파악되야 어떤 책임을 가져야 하는지 알게 되는 것이다.  \n즉 협력이 있어야 책임도 있는 것이다. 그러한 반면에 데이터 중심 객체 설계는 이 객체가 어떤 협력과 책임은 고려하지 않고 오직 어떠한 데이터가 필요한지에만 관심이 있다.  \n이렇게 되면 개발자는 앞으로 어떤 데이터로 협력 될지 모르리 때문에 과도하게 접근자, 수정자를 추가하게 된다. 즉 캡슐화를 위반하기 쉽게 되는 상황을 만든다는 것이다.  \n\n**추측에 의한 설계가 아닌 객체가 어떤 협력을 하는지 명확히 인지한 상태에서 어떠한 책임을 가져야하는지 알고 객체**를 설계 해야 하는 것이다.\n\n\n\n**데이터 중심 설계 객체 예제**\n~~~ java\npublic class Movie {\n    private String title;\n    private Duration runningTime;\n    private Money fee;\n    private List<DiscountCondition> discountConditions;\n\n    private MovieType movieType;\n    private Money discountAmount;\n    private double discountPercent;\n\n    // getter, setter..\n}\n~~~\n\n과도하게 많은 데이터를 포함하게 되고 접근자, 수정자를 만들어 객체 캡슐화를 위반하게 만든다.\n\n**책임 중심 설계 객체 예제**\n~~~ java\npublic class Movie {\n    private String title;\n    private Duration runningTime;\n    private Money fee;\n    private DiscountPolicy discountPolicy;\n\n    // getter, setter..\n}\n~~~\n\n{% asset_img \"object-1.png\" %}  \n\nMovie 객체에 역활은 영화에 대한 정보를 가지고 있어야 하고 그 정보를 다른 객체 (예약, 상영)에서 활용하게 된다.  \n하지만 Movice 책임 영화에 대한 정보만 있으면 돤다. 영화 할인 정책에 관한 처리는 따른 객체 DiscountPolicy 에게 위임 또는 협력하여 정보를 가져오면 되는 것이다.  \n\n\n\n### 데이터 중심 객체 설게 문제점 2 - 높은 결합도\n\n객체에 과도하게 많은 접근자와 수정자가 생격 다른 객체에서 접근하여 사용 할 확률이 높다. 그렇게 되면 수정사항이 발생하면 사용한 객체들에게 모두 영향을 미치게 된다.  \n\n~~~ java\npublic class ReservationAgency {\n    public Reservation reserve(Screening screening, Customer customer, int audienceCount) {\n        // ...\n        fee = movie.getFee().minus(discountAmount).times(audienceCount);\n    }\n}\n~~~\n\nmovie.getFee() 리턴 타입이 변경되면 어떻게 될까?? .getFee()를 하는 모든 객체 타입을 변경해줘야한다. \n\n\n### 데이터 중심 객체 설게 문제점 3 - 낮은 응집도\n\n> 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말한다.   \n\n이것또한 과도한 접근을 허용하게 되어 여러 객체에서 접근하여 로직을 작성하다 보니 하나에 객체에 많은 접근자가 있을 것이고 어떠한 이유로 수정하려 하는데  \n다른 객체에 영향을 미치게 한다는 것이다. 다 캡슐화를 위반하게 만들어서 발생하는 이유이다.\n\n\n### 정리\n이 모든 문제는 데이터 중심으로 객체를 설계하다 보니 숨겨야 할 상태들을 숨기지 않고 인터페이스로 노출시켜 여러 객체들에 의존성이 강하게 결합되어 변경에 취약하게 된 것이다.  \n즉, 캡슐화가 깨져서 그런 것이다. 따라서 객체간에 어떠한 협력을 하는지 생각하고 책임중심으로 설계해야 캡슐화에 이점을 가지고 변경에 유연한 설계를 가질수 있게 된다.   \n\n앞으로 실무에서 보게 되는 클래스로 보지 말고 이 객체가 어떻게 협력하고 있는지를 그 문맥을 기반으로 캡슐화가 잘 되어 있는지 생각하면서 수정, 개발을 해야겠다.  \n그래야 진정으로 책임 중심 객체 설계를 해야 하는 이유를 머릿속에 각인이 될 것이기 때문이다.","source":"_posts/OOP/객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유.md","raw":"---\ntitle: 객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유\ncatalog: true\ndate: 2019-07-29 00:08:00\nsubtitle: 추상화, 결합도, 응집도를 잘 활용해야 변경에 유연해 진다.\nheader-img: \"\"\ncategories:\n- 객체지향프로그래밍\ntags: \n- Book\n---\n\n### 왜 OOP를 할 때 데이터 중심으로 하면 안될까??\n\n데이터는 구현이다. 여기서 말하는 구현은 객체의 상태값이 될수도 있고 객체가 수행하는 로직이 될 수 도 있다. 즉, 객체 내부에서만 접근 가능한 것들이다.\n구현은 얼마든지 변경이 생길수 있기 때문에 데이터 중심으로 객체간 협력을 하게 되면 변경에 취약하게 된다.  \n\n책임은 인터페이스다. 책임 중심으로 이 객체는 어떤 책임을 가져야하는가? 라는 물음으로 객체를 설계하면 객체의 내부 구현은 캡슐화 화면서 설계 할 수 있기 때문에  \n코드 응집도 높고 변경에 유연한 설계를 얻을 수 있게 된다.  \n\n\n### 데이터 중심 객체 설게 문제점 1 - 캡슐화 위반\n\n객체가 어떤 책임을 가져야 하는지 알 수 있을려면 이 객체가 다른 객체와 어떤 협력을 해야햐는지 파악되야 어떤 책임을 가져야 하는지 알게 되는 것이다.  \n즉 협력이 있어야 책임도 있는 것이다. 그러한 반면에 데이터 중심 객체 설계는 이 객체가 어떤 협력과 책임은 고려하지 않고 오직 어떠한 데이터가 필요한지에만 관심이 있다.  \n이렇게 되면 개발자는 앞으로 어떤 데이터로 협력 될지 모르리 때문에 과도하게 접근자, 수정자를 추가하게 된다. 즉 캡슐화를 위반하기 쉽게 되는 상황을 만든다는 것이다.  \n\n**추측에 의한 설계가 아닌 객체가 어떤 협력을 하는지 명확히 인지한 상태에서 어떠한 책임을 가져야하는지 알고 객체**를 설계 해야 하는 것이다.\n\n\n\n**데이터 중심 설계 객체 예제**\n~~~ java\npublic class Movie {\n    private String title;\n    private Duration runningTime;\n    private Money fee;\n    private List<DiscountCondition> discountConditions;\n\n    private MovieType movieType;\n    private Money discountAmount;\n    private double discountPercent;\n\n    // getter, setter..\n}\n~~~\n\n과도하게 많은 데이터를 포함하게 되고 접근자, 수정자를 만들어 객체 캡슐화를 위반하게 만든다.\n\n**책임 중심 설계 객체 예제**\n~~~ java\npublic class Movie {\n    private String title;\n    private Duration runningTime;\n    private Money fee;\n    private DiscountPolicy discountPolicy;\n\n    // getter, setter..\n}\n~~~\n\n{% asset_img \"object-1.png\" %}  \n\nMovie 객체에 역활은 영화에 대한 정보를 가지고 있어야 하고 그 정보를 다른 객체 (예약, 상영)에서 활용하게 된다.  \n하지만 Movice 책임 영화에 대한 정보만 있으면 돤다. 영화 할인 정책에 관한 처리는 따른 객체 DiscountPolicy 에게 위임 또는 협력하여 정보를 가져오면 되는 것이다.  \n\n\n\n### 데이터 중심 객체 설게 문제점 2 - 높은 결합도\n\n객체에 과도하게 많은 접근자와 수정자가 생격 다른 객체에서 접근하여 사용 할 확률이 높다. 그렇게 되면 수정사항이 발생하면 사용한 객체들에게 모두 영향을 미치게 된다.  \n\n~~~ java\npublic class ReservationAgency {\n    public Reservation reserve(Screening screening, Customer customer, int audienceCount) {\n        // ...\n        fee = movie.getFee().minus(discountAmount).times(audienceCount);\n    }\n}\n~~~\n\nmovie.getFee() 리턴 타입이 변경되면 어떻게 될까?? .getFee()를 하는 모든 객체 타입을 변경해줘야한다. \n\n\n### 데이터 중심 객체 설게 문제점 3 - 낮은 응집도\n\n> 서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말한다.   \n\n이것또한 과도한 접근을 허용하게 되어 여러 객체에서 접근하여 로직을 작성하다 보니 하나에 객체에 많은 접근자가 있을 것이고 어떠한 이유로 수정하려 하는데  \n다른 객체에 영향을 미치게 한다는 것이다. 다 캡슐화를 위반하게 만들어서 발생하는 이유이다.\n\n\n### 정리\n이 모든 문제는 데이터 중심으로 객체를 설계하다 보니 숨겨야 할 상태들을 숨기지 않고 인터페이스로 노출시켜 여러 객체들에 의존성이 강하게 결합되어 변경에 취약하게 된 것이다.  \n즉, 캡슐화가 깨져서 그런 것이다. 따라서 객체간에 어떠한 협력을 하는지 생각하고 책임중심으로 설계해야 캡슐화에 이점을 가지고 변경에 유연한 설계를 가질수 있게 된다.   \n\n앞으로 실무에서 보게 되는 클래스로 보지 말고 이 객체가 어떻게 협력하고 있는지를 그 문맥을 기반으로 캡슐화가 잘 되어 있는지 생각하면서 수정, 개발을 해야겠다.  \n그래야 진정으로 책임 중심 객체 설계를 해야 하는 이유를 머릿속에 각인이 될 것이기 때문이다.","slug":"OOP/객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유","published":1,"updated":"2019-08-18T06:09:04.255Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids10001gk0otbf7g1wsj","content":"<h3><span id=\"왜-oop를-할-때-데이터-중심으로-하면-안될까\">왜 OOP를 할 때 데이터 중심으로 하면 안될까??</span></h3>\n<p>데이터는 구현이다. 여기서 말하는 구현은 객체의 상태값이 될수도 있고 객체가 수행하는 로직이 될 수 도 있다. 즉, 객체 내부에서만 접근 가능한 것들이다.<br>\n구현은 얼마든지 변경이 생길수 있기 때문에 데이터 중심으로 객체간 협력을 하게 되면 변경에 취약하게 된다.</p>\n<p>책임은 인터페이스다. 책임 중심으로 이 객체는 어떤 책임을 가져야하는가? 라는 물음으로 객체를 설계하면 객체의 내부 구현은 캡슐화 화면서 설계 할 수 있기 때문에<br>\n코드 응집도 높고 변경에 유연한 설계를 얻을 수 있게 된다.</p>\n<h3><span id=\"데이터-중심-객체-설게-문제점-1-캡슐화-위반\">데이터 중심 객체 설게 문제점 1 - 캡슐화 위반</span></h3>\n<p>객체가 어떤 책임을 가져야 하는지 알 수 있을려면 이 객체가 다른 객체와 어떤 협력을 해야햐는지 파악되야 어떤 책임을 가져야 하는지 알게 되는 것이다.<br>\n즉 협력이 있어야 책임도 있는 것이다. 그러한 반면에 데이터 중심 객체 설계는 이 객체가 어떤 협력과 책임은 고려하지 않고 오직 어떠한 데이터가 필요한지에만 관심이 있다.<br>\n이렇게 되면 개발자는 앞으로 어떤 데이터로 협력 될지 모르리 때문에 과도하게 접근자, 수정자를 추가하게 된다. 즉 캡슐화를 위반하기 쉽게 되는 상황을 만든다는 것이다.</p>\n<p><strong>추측에 의한 설계가 아닌 객체가 어떤 협력을 하는지 명확히 인지한 상태에서 어떠한 책임을 가져야하는지 알고 객체</strong>를 설계 해야 하는 것이다.</p>\n<p><strong>데이터 중심 설계 객체 예제</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Movie</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Duration runningTime;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Money fee;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;DiscountCondition&gt; discountConditions;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MovieType movieType;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Money discountAmount;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> discountPercent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getter, setter..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>과도하게 많은 데이터를 포함하게 되고 접근자, 수정자를 만들어 객체 캡슐화를 위반하게 만든다.</p>\n<p><strong>책임 중심 설계 객체 예제</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Movie</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Duration runningTime;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Money fee;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DiscountPolicy discountPolicy;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getter, setter..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/29/OOP/객체%20설계%20할%20때%20데이터%20중심이%20아닌%20책임%20중심으로%20해야%20하는%20이유/object-1.png\">  \n<p>Movie 객체에 역활은 영화에 대한 정보를 가지고 있어야 하고 그 정보를 다른 객체 (예약, 상영)에서 활용하게 된다.<br>\n하지만 Movice 책임 영화에 대한 정보만 있으면 돤다. 영화 할인 정책에 관한 처리는 따른 객체 DiscountPolicy 에게 위임 또는 협력하여 정보를 가져오면 되는 것이다.</p>\n<h3><span id=\"데이터-중심-객체-설게-문제점-2-높은-결합도\">데이터 중심 객체 설게 문제점 2 - 높은 결합도</span></h3>\n<p>객체에 과도하게 많은 접근자와 수정자가 생격 다른 객체에서 접근하여 사용 할 확률이 높다. 그렇게 되면 수정사항이 발생하면 사용한 객체들에게 모두 영향을 미치게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReservationAgency</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Reservation <span class=\"title\">reserve</span><span class=\"params\">(Screening screening, Customer customer, <span class=\"keyword\">int</span> audienceCount)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        fee = movie.getFee().minus(discountAmount).times(audienceCount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>movie.getFee() 리턴 타입이 변경되면 어떻게 될까?? .getFee()를 하는 모든 객체 타입을 변경해줘야한다.</p>\n<h3><span id=\"데이터-중심-객체-설게-문제점-3-낮은-응집도\">데이터 중심 객체 설게 문제점 3 - 낮은 응집도</span></h3>\n<blockquote>\n<p>서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말한다.</p>\n</blockquote>\n<p>이것또한 과도한 접근을 허용하게 되어 여러 객체에서 접근하여 로직을 작성하다 보니 하나에 객체에 많은 접근자가 있을 것이고 어떠한 이유로 수정하려 하는데<br>\n다른 객체에 영향을 미치게 한다는 것이다. 다 캡슐화를 위반하게 만들어서 발생하는 이유이다.</p>\n<h3><span id=\"정리\">정리</span></h3>\n<p>이 모든 문제는 데이터 중심으로 객체를 설계하다 보니 숨겨야 할 상태들을 숨기지 않고 인터페이스로 노출시켜 여러 객체들에 의존성이 강하게 결합되어 변경에 취약하게 된 것이다.<br>\n즉, 캡슐화가 깨져서 그런 것이다. 따라서 객체간에 어떠한 협력을 하는지 생각하고 책임중심으로 설계해야 캡슐화에 이점을 가지고 변경에 유연한 설계를 가질수 있게 된다.</p>\n<p>앞으로 실무에서 보게 되는 클래스로 보지 말고 이 객체가 어떻게 협력하고 있는지를 그 문맥을 기반으로 캡슐화가 잘 되어 있는지 생각하면서 수정, 개발을 해야겠다.<br>\n그래야 진정으로 책임 중심 객체 설계를 해야 하는 이유를 머릿속에 각인이 될 것이기 때문이다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>왜 OOP를 할 때 데이터 중심으로 하면 안될까??</h3>\n<p>데이터는 구현이다. 여기서 말하는 구현은 객체의 상태값이 될수도 있고 객체가 수행하는 로직이 될 수 도 있다. 즉, 객체 내부에서만 접근 가능한 것들이다.<br>\n구현은 얼마든지 변경이 생길수 있기 때문에 데이터 중심으로 객체간 협력을 하게 되면 변경에 취약하게 된다.</p>\n<p>책임은 인터페이스다. 책임 중심으로 이 객체는 어떤 책임을 가져야하는가? 라는 물음으로 객체를 설계하면 객체의 내부 구현은 캡슐화 화면서 설계 할 수 있기 때문에<br>\n코드 응집도 높고 변경에 유연한 설계를 얻을 수 있게 된다.</p>\n<h3>데이터 중심 객체 설게 문제점 1 - 캡슐화 위반</h3>\n<p>객체가 어떤 책임을 가져야 하는지 알 수 있을려면 이 객체가 다른 객체와 어떤 협력을 해야햐는지 파악되야 어떤 책임을 가져야 하는지 알게 되는 것이다.<br>\n즉 협력이 있어야 책임도 있는 것이다. 그러한 반면에 데이터 중심 객체 설계는 이 객체가 어떤 협력과 책임은 고려하지 않고 오직 어떠한 데이터가 필요한지에만 관심이 있다.<br>\n이렇게 되면 개발자는 앞으로 어떤 데이터로 협력 될지 모르리 때문에 과도하게 접근자, 수정자를 추가하게 된다. 즉 캡슐화를 위반하기 쉽게 되는 상황을 만든다는 것이다.</p>\n<p><strong>추측에 의한 설계가 아닌 객체가 어떤 협력을 하는지 명확히 인지한 상태에서 어떠한 책임을 가져야하는지 알고 객체</strong>를 설계 해야 하는 것이다.</p>\n<p><strong>데이터 중심 설계 객체 예제</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Movie</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Duration runningTime;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Money fee;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> List&lt;DiscountCondition&gt; discountConditions;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> MovieType movieType;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Money discountAmount;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">double</span> discountPercent;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getter, setter..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>과도하게 많은 데이터를 포함하게 되고 접근자, 수정자를 만들어 객체 캡슐화를 위반하게 만든다.</p>\n<p><strong>책임 중심 설계 객체 예제</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Movie</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String title;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Duration runningTime;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Money fee;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> DiscountPolicy discountPolicy;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getter, setter..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"/2019/07/29/OOP/객체%20설계%20할%20때%20데이터%20중심이%20아닌%20책임%20중심으로%20해야%20하는%20이유/object-1.png\">  \n<p>Movie 객체에 역활은 영화에 대한 정보를 가지고 있어야 하고 그 정보를 다른 객체 (예약, 상영)에서 활용하게 된다.<br>\n하지만 Movice 책임 영화에 대한 정보만 있으면 돤다. 영화 할인 정책에 관한 처리는 따른 객체 DiscountPolicy 에게 위임 또는 협력하여 정보를 가져오면 되는 것이다.</p>\n<h3>데이터 중심 객체 설게 문제점 2 - 높은 결합도</h3>\n<p>객체에 과도하게 많은 접근자와 수정자가 생격 다른 객체에서 접근하여 사용 할 확률이 높다. 그렇게 되면 수정사항이 발생하면 사용한 객체들에게 모두 영향을 미치게 된다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ReservationAgency</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Reservation <span class=\"title\">reserve</span><span class=\"params\">(Screening screening, Customer customer, <span class=\"keyword\">int</span> audienceCount)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        fee = movie.getFee().minus(discountAmount).times(audienceCount);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>movie.getFee() 리턴 타입이 변경되면 어떻게 될까?? .getFee()를 하는 모든 객체 타입을 변경해줘야한다.</p>\n<h3>데이터 중심 객체 설게 문제점 3 - 낮은 응집도</h3>\n<blockquote>\n<p>서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말한다.</p>\n</blockquote>\n<p>이것또한 과도한 접근을 허용하게 되어 여러 객체에서 접근하여 로직을 작성하다 보니 하나에 객체에 많은 접근자가 있을 것이고 어떠한 이유로 수정하려 하는데<br>\n다른 객체에 영향을 미치게 한다는 것이다. 다 캡슐화를 위반하게 만들어서 발생하는 이유이다.</p>\n<h3>정리</h3>\n<p>이 모든 문제는 데이터 중심으로 객체를 설계하다 보니 숨겨야 할 상태들을 숨기지 않고 인터페이스로 노출시켜 여러 객체들에 의존성이 강하게 결합되어 변경에 취약하게 된 것이다.<br>\n즉, 캡슐화가 깨져서 그런 것이다. 따라서 객체간에 어떠한 협력을 하는지 생각하고 책임중심으로 설계해야 캡슐화에 이점을 가지고 변경에 유연한 설계를 가질수 있게 된다.</p>\n<p>앞으로 실무에서 보게 되는 클래스로 보지 말고 이 객체가 어떻게 협력하고 있는지를 그 문맥을 기반으로 캡슐화가 잘 되어 있는지 생각하면서 수정, 개발을 해야겠다.<br>\n그래야 진정으로 책임 중심 객체 설계를 해야 하는 이유를 머릿속에 각인이 될 것이기 때문이다.</p>\n"},{"title":"객체 지향 설계 5대 원칙 - SOLID","catalog":true,"date":"2019-05-23T12:48:15.000Z","subtitle":"OOP를 올바르게 설계 하는 방법","header-img":"bg_computer.jpg","_content":"\n### SOLID 란?\n객체지향이 탄생이후 50년 동안 수많은 시행착오 속에 태어난 5가지 원칙을 Robert C. Martin 이 2000년대 초반 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙으로 제시한 것을 Michael Feathers 가 앞글자만 따서 소개한 것이다.\n\n- SRP(Single Responsibility Principle) 단일 책임 원칙\n- OCP(Open Closed Principle) 개방 폐쇄 원칙\n- LSP(Liskov Substitution Principle) 리스코프 치환 원칙\n- ISP(Interface Segregation Principle) 인터페이스 분리 원칙\n- DIP(Dependency Inversion Principle) 의존 역전 법칙\n\n**객체지향 4대 요소**인 추상화, 상속, 다형성, 캡슐화는 **건물을 짓기 위해 필요한 도구** 즉, 망치, 파워크레인, 시멘트 등등 이 된다면 위 **SOLID 원칙**은 망치를 올바르게 사용하는 법, 시멘트를 올바르게 사용하는 법, **도구를 올바르게 사용하는 법**이 SOLID 원칙인 것이다.\n\n### SRP(Single Responsibility Principle) 단일 책임 원칙\n\n> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.\n\nSOLID 는 도구를 올바르게 사용하는 법이라고 표현하였는데 그럼 SOLID중에 하나인 SRP는 객체지향 4가지 도구중에 어떤 도구에 가장 잘 해당할까??  \n\n바로 추상화(모델링) 이다.  \n\n왜 그럴까?? 자, 클래스 변경하는 이유는 한가지여야 한다. 그 말뜻은 한가지 책임만 지어야 가능한 말이다. 그럼 클래스를 설계할 때 한가지 기능만 수행 할 수 있도록 모델링은 해야 한다는 뜻인데 바로 이러한 과정은 객체 지향 도구인 추상화에 해당하는 내용이기 때문이다.  \n\n그렇다면 왜 클래스는 한가지 기능만 수행해야 좋은 걸까??  \n바로 아래 클래스 설계도를 보자 아이언맨이 물론 필수로 해야 하는 기능들이긴 하지만 예를들어 평화가 찾아와 더이상 전투 기능을 사용하지 않는다고 해보자 근데도 여전히 아이언맨 클래스 내에서 전투 기능이 존재하여 다른 책임 예를 들어 인공 지능 기능에서 자꾸 전투 기능에서 사용한 것이 영향을 받게 된다. 즉, 책임이 너무 많다 보니 다른 책임들에게 영향을 끼치는 것이다.\n\n{% asset_img \"srp-1.png\" %}  \n\n\n책임에 따라 아래와 같이 분리 하게 되면 더이상 다른 책임들간에 간섭은 없게 된다. 또한 각 클래스가 어떤 역활을 하는지 더 명확해 졌다.  \n코드로 단일책임이 왜 필요한지 봐보겠다\n\n~~~ java\n아이언맨 mark15 = new 아이언맨();\nmark15.조립();\n~~~\n\n엥?? mark15라는 아이언맨이 탄생했는데 mark15를 조립한다고? 하나의 클래스에 우겨넣고 잘못된 추상화로 인해서 인간이 쉽게 이해하면서 프로그래밍 하는 방법이 객체지향인데 말이 안 맞는 코드가 된것이다.  바로 너무 많은 책임을 갖게 되면서 나타는 코드 냄새이다.\n\n\n\n{% asset_img \"srp-2.png\" %}  ","source":"_posts/OOP/객체 지향 설계 5대 원칙.md","raw":"---\ntitle: 객체 지향 설계 5대 원칙 - SOLID\ncatalog: true\ndate: 2019-05-23 21:48:15\nsubtitle: OOP를 올바르게 설계 하는 방법\nheader-img: \"bg_computer.jpg\"\ncategories:\n- 객체지향프로그래밍\n---\n\n### SOLID 란?\n객체지향이 탄생이후 50년 동안 수많은 시행착오 속에 태어난 5가지 원칙을 Robert C. Martin 이 2000년대 초반 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙으로 제시한 것을 Michael Feathers 가 앞글자만 따서 소개한 것이다.\n\n- SRP(Single Responsibility Principle) 단일 책임 원칙\n- OCP(Open Closed Principle) 개방 폐쇄 원칙\n- LSP(Liskov Substitution Principle) 리스코프 치환 원칙\n- ISP(Interface Segregation Principle) 인터페이스 분리 원칙\n- DIP(Dependency Inversion Principle) 의존 역전 법칙\n\n**객체지향 4대 요소**인 추상화, 상속, 다형성, 캡슐화는 **건물을 짓기 위해 필요한 도구** 즉, 망치, 파워크레인, 시멘트 등등 이 된다면 위 **SOLID 원칙**은 망치를 올바르게 사용하는 법, 시멘트를 올바르게 사용하는 법, **도구를 올바르게 사용하는 법**이 SOLID 원칙인 것이다.\n\n### SRP(Single Responsibility Principle) 단일 책임 원칙\n\n> 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.\n\nSOLID 는 도구를 올바르게 사용하는 법이라고 표현하였는데 그럼 SOLID중에 하나인 SRP는 객체지향 4가지 도구중에 어떤 도구에 가장 잘 해당할까??  \n\n바로 추상화(모델링) 이다.  \n\n왜 그럴까?? 자, 클래스 변경하는 이유는 한가지여야 한다. 그 말뜻은 한가지 책임만 지어야 가능한 말이다. 그럼 클래스를 설계할 때 한가지 기능만 수행 할 수 있도록 모델링은 해야 한다는 뜻인데 바로 이러한 과정은 객체 지향 도구인 추상화에 해당하는 내용이기 때문이다.  \n\n그렇다면 왜 클래스는 한가지 기능만 수행해야 좋은 걸까??  \n바로 아래 클래스 설계도를 보자 아이언맨이 물론 필수로 해야 하는 기능들이긴 하지만 예를들어 평화가 찾아와 더이상 전투 기능을 사용하지 않는다고 해보자 근데도 여전히 아이언맨 클래스 내에서 전투 기능이 존재하여 다른 책임 예를 들어 인공 지능 기능에서 자꾸 전투 기능에서 사용한 것이 영향을 받게 된다. 즉, 책임이 너무 많다 보니 다른 책임들에게 영향을 끼치는 것이다.\n\n{% asset_img \"srp-1.png\" %}  \n\n\n책임에 따라 아래와 같이 분리 하게 되면 더이상 다른 책임들간에 간섭은 없게 된다. 또한 각 클래스가 어떤 역활을 하는지 더 명확해 졌다.  \n코드로 단일책임이 왜 필요한지 봐보겠다\n\n~~~ java\n아이언맨 mark15 = new 아이언맨();\nmark15.조립();\n~~~\n\n엥?? mark15라는 아이언맨이 탄생했는데 mark15를 조립한다고? 하나의 클래스에 우겨넣고 잘못된 추상화로 인해서 인간이 쉽게 이해하면서 프로그래밍 하는 방법이 객체지향인데 말이 안 맞는 코드가 된것이다.  바로 너무 많은 책임을 갖게 되면서 나타는 코드 냄새이다.\n\n\n\n{% asset_img \"srp-2.png\" %}  ","slug":"OOP/객체 지향 설계 5대 원칙","published":1,"updated":"2019-08-18T06:09:18.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids12001jk0oth4t7v4jw","content":"<h3><span id=\"solid-란\">SOLID 란?</span></h3>\n<p>객체지향이 탄생이후 50년 동안 수많은 시행착오 속에 태어난 5가지 원칙을 Robert C. Martin 이 2000년대 초반 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙으로 제시한 것을 Michael Feathers 가 앞글자만 따서 소개한 것이다.</p>\n<ul>\n<li>SRP(Single Responsibility Principle) 단일 책임 원칙</li>\n<li>OCP(Open Closed Principle) 개방 폐쇄 원칙</li>\n<li>LSP(Liskov Substitution Principle) 리스코프 치환 원칙</li>\n<li>ISP(Interface Segregation Principle) 인터페이스 분리 원칙</li>\n<li>DIP(Dependency Inversion Principle) 의존 역전 법칙</li>\n</ul>\n<p><strong>객체지향 4대 요소</strong>인 추상화, 상속, 다형성, 캡슐화는 <strong>건물을 짓기 위해 필요한 도구</strong> 즉, 망치, 파워크레인, 시멘트 등등 이 된다면 위 <strong>SOLID 원칙</strong>은 망치를 올바르게 사용하는 법, 시멘트를 올바르게 사용하는 법, <strong>도구를 올바르게 사용하는 법</strong>이 SOLID 원칙인 것이다.</p>\n<h3><span id=\"srpsingle-responsibility-principle-단일-책임-원칙\">SRP(Single Responsibility Principle) 단일 책임 원칙</span></h3>\n<blockquote>\n<p>어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.</p>\n</blockquote>\n<p>SOLID 는 도구를 올바르게 사용하는 법이라고 표현하였는데 그럼 SOLID중에 하나인 SRP는 객체지향 4가지 도구중에 어떤 도구에 가장 잘 해당할까??</p>\n<p>바로 추상화(모델링) 이다.</p>\n<p>왜 그럴까?? 자, 클래스 변경하는 이유는 한가지여야 한다. 그 말뜻은 한가지 책임만 지어야 가능한 말이다. 그럼 클래스를 설계할 때 한가지 기능만 수행 할 수 있도록 모델링은 해야 한다는 뜻인데 바로 이러한 과정은 객체 지향 도구인 추상화에 해당하는 내용이기 때문이다.</p>\n<p>그렇다면 왜 클래스는 한가지 기능만 수행해야 좋은 걸까??<br>\n바로 아래 클래스 설계도를 보자 아이언맨이 물론 필수로 해야 하는 기능들이긴 하지만 예를들어 평화가 찾아와 더이상 전투 기능을 사용하지 않는다고 해보자 근데도 여전히 아이언맨 클래스 내에서 전투 기능이 존재하여 다른 책임 예를 들어 인공 지능 기능에서 자꾸 전투 기능에서 사용한 것이 영향을 받게 된다. 즉, 책임이 너무 많다 보니 다른 책임들에게 영향을 끼치는 것이다.</p>\n<img src=\"/2019/05/23/OOP/객체%20지향%20설계%205대%20원칙/srp-1.png\">  \n<p>책임에 따라 아래와 같이 분리 하게 되면 더이상 다른 책임들간에 간섭은 없게 된다. 또한 각 클래스가 어떤 역활을 하는지 더 명확해 졌다.<br>\n코드로 단일책임이 왜 필요한지 봐보겠다</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">아이언맨 mark15 = <span class=\"keyword\">new</span> 아이언맨();</span><br><span class=\"line\">mark15.조립();</span><br></pre></td></tr></table></figure>\n<p>엥?? mark15라는 아이언맨이 탄생했는데 mark15를 조립한다고? 하나의 클래스에 우겨넣고 잘못된 추상화로 인해서 인간이 쉽게 이해하면서 프로그래밍 하는 방법이 객체지향인데 말이 안 맞는 코드가 된것이다.  바로 너무 많은 책임을 갖게 되면서 나타는 코드 냄새이다.</p>\n<img src=\"/2019/05/23/OOP/객체%20지향%20설계%205대%20원칙/srp-2.png\">","site":{"data":{}},"excerpt":"","more":"<h3>SOLID 란?</h3>\n<p>객체지향이 탄생이후 50년 동안 수많은 시행착오 속에 태어난 5가지 원칙을 Robert C. Martin 이 2000년대 초반 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙으로 제시한 것을 Michael Feathers 가 앞글자만 따서 소개한 것이다.</p>\n<ul>\n<li>SRP(Single Responsibility Principle) 단일 책임 원칙</li>\n<li>OCP(Open Closed Principle) 개방 폐쇄 원칙</li>\n<li>LSP(Liskov Substitution Principle) 리스코프 치환 원칙</li>\n<li>ISP(Interface Segregation Principle) 인터페이스 분리 원칙</li>\n<li>DIP(Dependency Inversion Principle) 의존 역전 법칙</li>\n</ul>\n<p><strong>객체지향 4대 요소</strong>인 추상화, 상속, 다형성, 캡슐화는 <strong>건물을 짓기 위해 필요한 도구</strong> 즉, 망치, 파워크레인, 시멘트 등등 이 된다면 위 <strong>SOLID 원칙</strong>은 망치를 올바르게 사용하는 법, 시멘트를 올바르게 사용하는 법, <strong>도구를 올바르게 사용하는 법</strong>이 SOLID 원칙인 것이다.</p>\n<h3>SRP(Single Responsibility Principle) 단일 책임 원칙</h3>\n<blockquote>\n<p>어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.</p>\n</blockquote>\n<p>SOLID 는 도구를 올바르게 사용하는 법이라고 표현하였는데 그럼 SOLID중에 하나인 SRP는 객체지향 4가지 도구중에 어떤 도구에 가장 잘 해당할까??</p>\n<p>바로 추상화(모델링) 이다.</p>\n<p>왜 그럴까?? 자, 클래스 변경하는 이유는 한가지여야 한다. 그 말뜻은 한가지 책임만 지어야 가능한 말이다. 그럼 클래스를 설계할 때 한가지 기능만 수행 할 수 있도록 모델링은 해야 한다는 뜻인데 바로 이러한 과정은 객체 지향 도구인 추상화에 해당하는 내용이기 때문이다.</p>\n<p>그렇다면 왜 클래스는 한가지 기능만 수행해야 좋은 걸까??<br>\n바로 아래 클래스 설계도를 보자 아이언맨이 물론 필수로 해야 하는 기능들이긴 하지만 예를들어 평화가 찾아와 더이상 전투 기능을 사용하지 않는다고 해보자 근데도 여전히 아이언맨 클래스 내에서 전투 기능이 존재하여 다른 책임 예를 들어 인공 지능 기능에서 자꾸 전투 기능에서 사용한 것이 영향을 받게 된다. 즉, 책임이 너무 많다 보니 다른 책임들에게 영향을 끼치는 것이다.</p>\n<img src=\"/2019/05/23/OOP/객체%20지향%20설계%205대%20원칙/srp-1.png\">  \n<p>책임에 따라 아래와 같이 분리 하게 되면 더이상 다른 책임들간에 간섭은 없게 된다. 또한 각 클래스가 어떤 역활을 하는지 더 명확해 졌다.<br>\n코드로 단일책임이 왜 필요한지 봐보겠다</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">아이언맨 mark15 = <span class=\"keyword\">new</span> 아이언맨();</span><br><span class=\"line\">mark15.조립();</span><br></pre></td></tr></table></figure>\n<p>엥?? mark15라는 아이언맨이 탄생했는데 mark15를 조립한다고? 하나의 클래스에 우겨넣고 잘못된 추상화로 인해서 인간이 쉽게 이해하면서 프로그래밍 하는 방법이 객체지향인데 말이 안 맞는 코드가 된것이다.  바로 너무 많은 책임을 갖게 되면서 나타는 코드 냄새이다.</p>\n<img src=\"/2019/05/23/OOP/객체%20지향%20설계%205대%20원칙/srp-2.png\">"},{"title":"객체지향 캡슐화 그것이 알고 싶다.","catalog":true,"date":"2019-07-31T14:15:15.000Z","subtitle":null,"header-img":"bg_computer.jpg","_content":"\n# 캡슐화란?\n\n> 변경 될 수 있는 것은 어떤 것이라도 감춘다.\n\n반사적으로 생각나는 단어는 \"변경\" 입니다.  \n다시 말해 캡슐화를 잘 되어 있는 설계 일수록 응집도는 높고 결합도는 낮습니다. 각 객체들은 스스로 역활과 책임을 충실히 하기 때문에 **기능이 변경되어도 수정 할 수 있는 부분은 최소한으로 할 수 있습니다.** 즉, 캡슐화란 변경 될 수 있는 부분은 최대한 외부에 노출시키지 않고 협력에 의한 인터페이스로만 소통을 하는 것으로 객체지향 설계를 할 때 핵심중에 핵심이라 할 수 있죠.\n\n그럼 캡슐화를 지키지 못한 객체 코드를 보면서 캡슐화에 중요성에 대해서 직접 느껴 보죠\n\n# 너무 많은 참견을 하는 객체\n\n우선 극장 이라는 클래스를 봐보죠  \n\n관객이 초대권이 있냐 없냐에 따라서 분기되고 있으며 중요한 부분은 아래 코드 입니다.\n> Ticket ticket = ticketSeller.getTicketOffice().getTicket();\n\nTicketSeller -> getTicketOffice -> getTicket 객체를 다리 건너 건너 티켓을 가져오고 있는데 이것에 문제점은 캡슐화를 적절하게 하지 못해 변경에 굉장히 취약하다는 점입니다. Theater 객체에서 enter 역활을 관람객을 입장시키면 되는 것입니다. 근데 티켓을 가져오기 위해 건너 건너 참조하여 데이터를 가져와서 setTicket 하는 행위는 Theater에 역활이 아닙니다. 이렇게 역활이 아닌 Theater 객체에서 코드를 사용한 것처럼 여기 저기 사용하게 된다면 관련 코드 변경이 발생 할 시 여기 저기 코드를 수정해야 하고 이것은 변경에 취약한 설계가 되는 것이죠\n\n~~~ java\npublic class Theater {\n    private TicketSeller ticketSeller;\n\n    public Theater(TicketSeller ticketSeller) {\n        this.ticketSeller = ticketSeller;\n    }\n\n    public void enter(Audience audience) {\n        if (audience.getBag().hasInvitation()) {\n            Ticket ticket = ticketSeller.getTicketOffice().getTicket();\n            audience.getBag().setTicket(ticket);\n        } else {\n            Ticket ticket = ticketSeller.getTicketOffice().getTicket();\n            audience.getBag().minusAmount(ticket.getFee());\n            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());\n            audience.getBag().setTicket(ticket);\n        }\n    }\n}\n~~~\n\n# 그럼 어떻게 해야 돼? \n\n지적했던 코드는 Theater 에서가 아닌 TicketSeller 객체에서 하는 것이죠.   \n이것이 바로 협력이라는 문맥을 바탕으로 적절한 역활을 할 만한 객체를 찾는 행위가 되는 것입니다. 즉 \"Ticket을 판매한다.\" 라는 책임을 수행할 객체를 TicketSeller에게 할당한 것이죠 그러니 TicketSeller가 그 역활과 책임을 자율적으로 잘~~ 해주면 됩니다.  \n\n코드를 보죠\n\n~~~ java\npublic class Theater {\n    private TicketSeller ticketSeller;\n\n    public Theater(TicketSeller ticketSeller) {\n        this.ticketSeller = ticketSeller;\n    }\n\n    public void enter(Audience audience) {\n      ticketSeller.sellTo();\n    }\n}\n~~~\n\n~~~ java\npublic class TicketSeller {\n\n    private TicketOffice ticketOffice;\n\n    public TicketSeller(TicketOffice ticketOffice) {\n        this.ticketOffice = ticketOffice;\n    }\n\n    public void sellTo(Audience audience) {\n        if (audience.getBag().hasInvitation()) {\n            Ticket ticket = ticketSeller.getTicketOffice().getTicket();\n            audience.getBag().setTicket(ticket);\n        } else {\n            Ticket ticket = ticketSeller.getTicketOffice().getTicket();\n            audience.getBag().minusAmount(ticket.getFee());\n            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());\n            audience.getBag().setTicket(ticket);\n        }\n    }\n}\n~~~\n\n가장 중요한 것은 Theater 객체에서는 더이상 TicketOffice 객체를 몰라도 이전 기능을 그데로 수행 한다는 것입니다.  \nTicketOffice 객체를 모른다는 것은 TicketOffice 객체가 변경 되어도 영향이 미치치 않는다는 것입니다.\n\n자, 바로 이부분에서 캡슐화를 잘해야 하는 이유가 들어나게 되네요.\n캡슐화를 잘 하는 객체는 곧 변경되는 요구사항을 반영해도 의존하는 코드가 적어 코드 변경을 최소화 하게끔 만들어 줍니다.  \n\n이것은 곧 객체지향 프로그래밍에 지향점이 될 수도 있겠네요. 객체지향 프로그래밍은 변경에 강한 프로그래밍 기법이니까요.","source":"_posts/OOP/객체지향 캡슐화 그것이 알고 싶다.md","raw":"---\ntitle: 객체지향 캡슐화 그것이 알고 싶다.\ncatalog: true\ndate: 2019-07-31 23:15:15\nsubtitle: \nheader-img: \"bg_computer.jpg\"\ncategories:\n- 객체지향프로그래밍\n---\n\n# 캡슐화란?\n\n> 변경 될 수 있는 것은 어떤 것이라도 감춘다.\n\n반사적으로 생각나는 단어는 \"변경\" 입니다.  \n다시 말해 캡슐화를 잘 되어 있는 설계 일수록 응집도는 높고 결합도는 낮습니다. 각 객체들은 스스로 역활과 책임을 충실히 하기 때문에 **기능이 변경되어도 수정 할 수 있는 부분은 최소한으로 할 수 있습니다.** 즉, 캡슐화란 변경 될 수 있는 부분은 최대한 외부에 노출시키지 않고 협력에 의한 인터페이스로만 소통을 하는 것으로 객체지향 설계를 할 때 핵심중에 핵심이라 할 수 있죠.\n\n그럼 캡슐화를 지키지 못한 객체 코드를 보면서 캡슐화에 중요성에 대해서 직접 느껴 보죠\n\n# 너무 많은 참견을 하는 객체\n\n우선 극장 이라는 클래스를 봐보죠  \n\n관객이 초대권이 있냐 없냐에 따라서 분기되고 있으며 중요한 부분은 아래 코드 입니다.\n> Ticket ticket = ticketSeller.getTicketOffice().getTicket();\n\nTicketSeller -> getTicketOffice -> getTicket 객체를 다리 건너 건너 티켓을 가져오고 있는데 이것에 문제점은 캡슐화를 적절하게 하지 못해 변경에 굉장히 취약하다는 점입니다. Theater 객체에서 enter 역활을 관람객을 입장시키면 되는 것입니다. 근데 티켓을 가져오기 위해 건너 건너 참조하여 데이터를 가져와서 setTicket 하는 행위는 Theater에 역활이 아닙니다. 이렇게 역활이 아닌 Theater 객체에서 코드를 사용한 것처럼 여기 저기 사용하게 된다면 관련 코드 변경이 발생 할 시 여기 저기 코드를 수정해야 하고 이것은 변경에 취약한 설계가 되는 것이죠\n\n~~~ java\npublic class Theater {\n    private TicketSeller ticketSeller;\n\n    public Theater(TicketSeller ticketSeller) {\n        this.ticketSeller = ticketSeller;\n    }\n\n    public void enter(Audience audience) {\n        if (audience.getBag().hasInvitation()) {\n            Ticket ticket = ticketSeller.getTicketOffice().getTicket();\n            audience.getBag().setTicket(ticket);\n        } else {\n            Ticket ticket = ticketSeller.getTicketOffice().getTicket();\n            audience.getBag().minusAmount(ticket.getFee());\n            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());\n            audience.getBag().setTicket(ticket);\n        }\n    }\n}\n~~~\n\n# 그럼 어떻게 해야 돼? \n\n지적했던 코드는 Theater 에서가 아닌 TicketSeller 객체에서 하는 것이죠.   \n이것이 바로 협력이라는 문맥을 바탕으로 적절한 역활을 할 만한 객체를 찾는 행위가 되는 것입니다. 즉 \"Ticket을 판매한다.\" 라는 책임을 수행할 객체를 TicketSeller에게 할당한 것이죠 그러니 TicketSeller가 그 역활과 책임을 자율적으로 잘~~ 해주면 됩니다.  \n\n코드를 보죠\n\n~~~ java\npublic class Theater {\n    private TicketSeller ticketSeller;\n\n    public Theater(TicketSeller ticketSeller) {\n        this.ticketSeller = ticketSeller;\n    }\n\n    public void enter(Audience audience) {\n      ticketSeller.sellTo();\n    }\n}\n~~~\n\n~~~ java\npublic class TicketSeller {\n\n    private TicketOffice ticketOffice;\n\n    public TicketSeller(TicketOffice ticketOffice) {\n        this.ticketOffice = ticketOffice;\n    }\n\n    public void sellTo(Audience audience) {\n        if (audience.getBag().hasInvitation()) {\n            Ticket ticket = ticketSeller.getTicketOffice().getTicket();\n            audience.getBag().setTicket(ticket);\n        } else {\n            Ticket ticket = ticketSeller.getTicketOffice().getTicket();\n            audience.getBag().minusAmount(ticket.getFee());\n            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());\n            audience.getBag().setTicket(ticket);\n        }\n    }\n}\n~~~\n\n가장 중요한 것은 Theater 객체에서는 더이상 TicketOffice 객체를 몰라도 이전 기능을 그데로 수행 한다는 것입니다.  \nTicketOffice 객체를 모른다는 것은 TicketOffice 객체가 변경 되어도 영향이 미치치 않는다는 것입니다.\n\n자, 바로 이부분에서 캡슐화를 잘해야 하는 이유가 들어나게 되네요.\n캡슐화를 잘 하는 객체는 곧 변경되는 요구사항을 반영해도 의존하는 코드가 적어 코드 변경을 최소화 하게끔 만들어 줍니다.  \n\n이것은 곧 객체지향 프로그래밍에 지향점이 될 수도 있겠네요. 객체지향 프로그래밍은 변경에 강한 프로그래밍 기법이니까요.","slug":"OOP/객체지향 캡슐화 그것이 알고 싶다","published":1,"updated":"2019-08-18T06:09:15.910Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids15001ok0otg0gjqn5b","content":"<h1><span id=\"캡슐화란\">캡슐화란?</span></h1>\n<blockquote>\n<p>변경 될 수 있는 것은 어떤 것이라도 감춘다.</p>\n</blockquote>\n<p>반사적으로 생각나는 단어는 “변경” 입니다.<br>\n다시 말해 캡슐화를 잘 되어 있는 설계 일수록 응집도는 높고 결합도는 낮습니다. 각 객체들은 스스로 역활과 책임을 충실히 하기 때문에 <strong>기능이 변경되어도 수정 할 수 있는 부분은 최소한으로 할 수 있습니다.</strong> 즉, 캡슐화란 변경 될 수 있는 부분은 최대한 외부에 노출시키지 않고 협력에 의한 인터페이스로만 소통을 하는 것으로 객체지향 설계를 할 때 핵심중에 핵심이라 할 수 있죠.</p>\n<p>그럼 캡슐화를 지키지 못한 객체 코드를 보면서 캡슐화에 중요성에 대해서 직접 느껴 보죠</p>\n<h1><span id=\"너무-많은-참견을-하는-객체\">너무 많은 참견을 하는 객체</span></h1>\n<p>우선 극장 이라는 클래스를 봐보죠</p>\n<p>관객이 초대권이 있냐 없냐에 따라서 분기되고 있으며 중요한 부분은 아래 코드 입니다.</p>\n<blockquote>\n<p>Ticket ticket = ticketSeller.getTicketOffice().getTicket();</p>\n</blockquote>\n<p>TicketSeller -&gt; getTicketOffice -&gt; getTicket 객체를 다리 건너 건너 티켓을 가져오고 있는데 이것에 문제점은 캡슐화를 적절하게 하지 못해 변경에 굉장히 취약하다는 점입니다. Theater 객체에서 enter 역활을 관람객을 입장시키면 되는 것입니다. 근데 티켓을 가져오기 위해 건너 건너 참조하여 데이터를 가져와서 setTicket 하는 행위는 Theater에 역활이 아닙니다. 이렇게 역활이 아닌 Theater 객체에서 코드를 사용한 것처럼 여기 저기 사용하게 된다면 관련 코드 변경이 발생 할 시 여기 저기 코드를 수정해야 하고 이것은 변경에 취약한 설계가 되는 것이죠</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Theater</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TicketSeller ticketSeller;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Theater</span><span class=\"params\">(TicketSeller ticketSeller)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ticketSeller = ticketSeller;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enter</span><span class=\"params\">(Audience audience)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (audience.getBag().hasInvitation()) &#123;</span><br><span class=\"line\">            Ticket ticket = ticketSeller.getTicketOffice().getTicket();</span><br><span class=\"line\">            audience.getBag().setTicket(ticket);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Ticket ticket = ticketSeller.getTicketOffice().getTicket();</span><br><span class=\"line\">            audience.getBag().minusAmount(ticket.getFee());</span><br><span class=\"line\">            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());</span><br><span class=\"line\">            audience.getBag().setTicket(ticket);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1><span id=\"그럼-어떻게-해야-돼\">그럼 어떻게 해야 돼?</span></h1>\n<p>지적했던 코드는 Theater 에서가 아닌 TicketSeller 객체에서 하는 것이죠.<br>\n이것이 바로 협력이라는 문맥을 바탕으로 적절한 역활을 할 만한 객체를 찾는 행위가 되는 것입니다. 즉 “Ticket을 판매한다.” 라는 책임을 수행할 객체를 TicketSeller에게 할당한 것이죠 그러니 TicketSeller가 그 역활과 책임을 자율적으로 잘~~ 해주면 됩니다.</p>\n<p>코드를 보죠</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Theater</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TicketSeller ticketSeller;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Theater</span><span class=\"params\">(TicketSeller ticketSeller)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ticketSeller = ticketSeller;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enter</span><span class=\"params\">(Audience audience)</span> </span>&#123;</span><br><span class=\"line\">      ticketSeller.sellTo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TicketSeller</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TicketOffice ticketOffice;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TicketSeller</span><span class=\"params\">(TicketOffice ticketOffice)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ticketOffice = ticketOffice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sellTo</span><span class=\"params\">(Audience audience)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (audience.getBag().hasInvitation()) &#123;</span><br><span class=\"line\">            Ticket ticket = ticketSeller.getTicketOffice().getTicket();</span><br><span class=\"line\">            audience.getBag().setTicket(ticket);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Ticket ticket = ticketSeller.getTicketOffice().getTicket();</span><br><span class=\"line\">            audience.getBag().minusAmount(ticket.getFee());</span><br><span class=\"line\">            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());</span><br><span class=\"line\">            audience.getBag().setTicket(ticket);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>가장 중요한 것은 Theater 객체에서는 더이상 TicketOffice 객체를 몰라도 이전 기능을 그데로 수행 한다는 것입니다.<br>\nTicketOffice 객체를 모른다는 것은 TicketOffice 객체가 변경 되어도 영향이 미치치 않는다는 것입니다.</p>\n<p>자, 바로 이부분에서 캡슐화를 잘해야 하는 이유가 들어나게 되네요.<br>\n캡슐화를 잘 하는 객체는 곧 변경되는 요구사항을 반영해도 의존하는 코드가 적어 코드 변경을 최소화 하게끔 만들어 줍니다.</p>\n<p>이것은 곧 객체지향 프로그래밍에 지향점이 될 수도 있겠네요. 객체지향 프로그래밍은 변경에 강한 프로그래밍 기법이니까요.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>캡슐화란?</h1>\n<blockquote>\n<p>변경 될 수 있는 것은 어떤 것이라도 감춘다.</p>\n</blockquote>\n<p>반사적으로 생각나는 단어는 “변경” 입니다.<br>\n다시 말해 캡슐화를 잘 되어 있는 설계 일수록 응집도는 높고 결합도는 낮습니다. 각 객체들은 스스로 역활과 책임을 충실히 하기 때문에 <strong>기능이 변경되어도 수정 할 수 있는 부분은 최소한으로 할 수 있습니다.</strong> 즉, 캡슐화란 변경 될 수 있는 부분은 최대한 외부에 노출시키지 않고 협력에 의한 인터페이스로만 소통을 하는 것으로 객체지향 설계를 할 때 핵심중에 핵심이라 할 수 있죠.</p>\n<p>그럼 캡슐화를 지키지 못한 객체 코드를 보면서 캡슐화에 중요성에 대해서 직접 느껴 보죠</p>\n<h1>너무 많은 참견을 하는 객체</h1>\n<p>우선 극장 이라는 클래스를 봐보죠</p>\n<p>관객이 초대권이 있냐 없냐에 따라서 분기되고 있으며 중요한 부분은 아래 코드 입니다.</p>\n<blockquote>\n<p>Ticket ticket = ticketSeller.getTicketOffice().getTicket();</p>\n</blockquote>\n<p>TicketSeller -&gt; getTicketOffice -&gt; getTicket 객체를 다리 건너 건너 티켓을 가져오고 있는데 이것에 문제점은 캡슐화를 적절하게 하지 못해 변경에 굉장히 취약하다는 점입니다. Theater 객체에서 enter 역활을 관람객을 입장시키면 되는 것입니다. 근데 티켓을 가져오기 위해 건너 건너 참조하여 데이터를 가져와서 setTicket 하는 행위는 Theater에 역활이 아닙니다. 이렇게 역활이 아닌 Theater 객체에서 코드를 사용한 것처럼 여기 저기 사용하게 된다면 관련 코드 변경이 발생 할 시 여기 저기 코드를 수정해야 하고 이것은 변경에 취약한 설계가 되는 것이죠</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Theater</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TicketSeller ticketSeller;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Theater</span><span class=\"params\">(TicketSeller ticketSeller)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ticketSeller = ticketSeller;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enter</span><span class=\"params\">(Audience audience)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (audience.getBag().hasInvitation()) &#123;</span><br><span class=\"line\">            Ticket ticket = ticketSeller.getTicketOffice().getTicket();</span><br><span class=\"line\">            audience.getBag().setTicket(ticket);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Ticket ticket = ticketSeller.getTicketOffice().getTicket();</span><br><span class=\"line\">            audience.getBag().minusAmount(ticket.getFee());</span><br><span class=\"line\">            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());</span><br><span class=\"line\">            audience.getBag().setTicket(ticket);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1>그럼 어떻게 해야 돼?</h1>\n<p>지적했던 코드는 Theater 에서가 아닌 TicketSeller 객체에서 하는 것이죠.<br>\n이것이 바로 협력이라는 문맥을 바탕으로 적절한 역활을 할 만한 객체를 찾는 행위가 되는 것입니다. 즉 “Ticket을 판매한다.” 라는 책임을 수행할 객체를 TicketSeller에게 할당한 것이죠 그러니 TicketSeller가 그 역활과 책임을 자율적으로 잘~~ 해주면 됩니다.</p>\n<p>코드를 보죠</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Theater</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TicketSeller ticketSeller;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Theater</span><span class=\"params\">(TicketSeller ticketSeller)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ticketSeller = ticketSeller;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">enter</span><span class=\"params\">(Audience audience)</span> </span>&#123;</span><br><span class=\"line\">      ticketSeller.sellTo();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TicketSeller</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TicketOffice ticketOffice;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">TicketSeller</span><span class=\"params\">(TicketOffice ticketOffice)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ticketOffice = ticketOffice;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">sellTo</span><span class=\"params\">(Audience audience)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (audience.getBag().hasInvitation()) &#123;</span><br><span class=\"line\">            Ticket ticket = ticketSeller.getTicketOffice().getTicket();</span><br><span class=\"line\">            audience.getBag().setTicket(ticket);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            Ticket ticket = ticketSeller.getTicketOffice().getTicket();</span><br><span class=\"line\">            audience.getBag().minusAmount(ticket.getFee());</span><br><span class=\"line\">            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());</span><br><span class=\"line\">            audience.getBag().setTicket(ticket);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>가장 중요한 것은 Theater 객체에서는 더이상 TicketOffice 객체를 몰라도 이전 기능을 그데로 수행 한다는 것입니다.<br>\nTicketOffice 객체를 모른다는 것은 TicketOffice 객체가 변경 되어도 영향이 미치치 않는다는 것입니다.</p>\n<p>자, 바로 이부분에서 캡슐화를 잘해야 하는 이유가 들어나게 되네요.<br>\n캡슐화를 잘 하는 객체는 곧 변경되는 요구사항을 반영해도 의존하는 코드가 적어 코드 변경을 최소화 하게끔 만들어 줍니다.</p>\n<p>이것은 곧 객체지향 프로그래밍에 지향점이 될 수도 있겠네요. 객체지향 프로그래밍은 변경에 강한 프로그래밍 기법이니까요.</p>\n"},{"title":"상속보다는 합성을 사용해야 하는 이유","catalog":true,"date":"2019-07-31T14:15:15.000Z","subtitle":null,"header-img":"bg_computer.jpg","_content":"\n# 들어가며\n상속은 막연히 부모 자식 관계 합성은 Setter 메소드 처럼 객체를 주입받는 패턴 정도만 알고 있었는데 \"오브젝트 - 조영호\" 책을 읽으면서 내용을 학습하여 이해하고자 정리 합니다. 그러면 먼저 상속과 합성이 무엇인지 부터 제가 깨닳은 내용을 공유해 드리죠\n\n# 왜 상속보단 합성을 써야 할 까?\n\n공통 역활을 수행하는 부모 클래스를 두고 부모 기능을 더하여 각자에 기능을 수행하는 자식클래스를 사용하는게 잘 못된다고 말하는것은 아니었습니다. 책에서 말하는 상속에 위험성은 2가지 였습니다.  \n\n# 상속은 캡슐화가 약화된다.\n    \n[캡슐화](https://biggwang.github.io/2019/07/31/OOP/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%BA%A1%EC%8A%90%ED%99%94%20%EA%B7%B8%EA%B2%83%EC%9D%B4%20%EC%95%8C%EA%B3%A0%20%EC%8B%B6%EB%8B%A4/) 에 대한 설명은 따로 포스팅하였습니다~!\n> 부모 클래스에 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.  \n캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다. 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워진다.   \n\n저는 이렇게 이해했습니다.  \n상속은 캡슐화를 위반한다. -> 상속을 하면 캡슐화를 위반할 확률이 높아진다. 또는 상속을 하려면 캡슐화를 떠 신경써서 잘 해야 한다!!\n\n하지만, 캡슐화를 잘 시켜놓고 사용하면 좋은데 부모 클래스에 캡슐화가 잘 되지 않는다면 어떻게 될까요?  \n\n다시 말해서 **변경 될 수 있는 부분은 감추면서** 부모 클래스가 수행해야 할 역활과 책임을 온전히 처리하지 못하면 자식 클래스는 부모 클래스에 역활을 무자비하게 사용하여 강한 의존성을 가질수 있게 됩니다. 상황을 예로 들어 볼까요?\n\n# 변경이 엄청 어려움\n캡슐화 되지 못한 부모 클래스에 자식 클래스가 100개 있다고 가정해 보죠.  \n각 자식클래스는 신난다~~ 하고 부모 클래스에서 감추고 싶은 부분을 마음데로 접근하고 사용 하기 시작합니다. 코드를 보시죠  \n\n~~~ java\npublic abstract class RectangleSuperClass {\n\n    private int left;\n    private int top;\n    private int right;\n    private int bottom;\n\n    // construcotr..\n\n    // getter, setter ..\n}\n~~~\n\n부모 객체가 할 일을 자식 객체에서 일일이 이렇게 구현하는게 맞을까요?\n~~~ java\npublic class RectangleSubClass extends RectangleSuperClass {\n    \n    // any method\n\n    public void anyMethod(int multiple) {\n        super.setRight(super.getRight() * multiple);\n        super.setBottom(super.getBottom() * multiple);\n    }\n}\n~~~\n\n각 자식 클래스에서 사각형에 가로, 세로를 증가시키는 코드가 있다고 해보죠.  \n근데 부모 클래스에서 사각형의 넓이를 변경하는 변수명을 right, bottom이 아니라 length, hight로 바꿔야 겠다고 하면 어떻게 될까요?? 바꾸고 저장하면 100개의 클래스에서 빨간줄이 주르르르륵 뜰것입니다.  \n\n그 빨간줄이 많으면 많을수록 그만큼 코드 의존도가 높다고 할 수 있는것이죠.\n\n그 외 문제점은 코드 중복입니다. 부모 객체에서 사각형을 크기를 핸들링하는 메소드를 만들고 자식클래스에서 사용하라고 했다면 자식클래스 입장에서는 함수만 쓰기만 하면 됩니다. 위 코드 처럼 setRight, setBottom 를 신경쓸필요 없다는 것이죠.  \n\n**바로 이 맥락이 부모 클래스가 캡슐화 되지 못해서 벌어지는 현상을 보고 계시고 있는겁니다.**  \n\n부모객체가 변경될수 있는 부분(구현)은 감추고 함수만 호출(인터페이스)하도록 하여 변경에 코드 영향도를 최소화 시켜야 되는데 그러지 못해서 코드변경이 일어 날 때마나 자식 객체까지 영향을 미치게 되는 것이죠.  \n자식 객체는 잘못 없는겁니다. 왜냐하면 부모 객체에서 접근 할 수 있도록 해줬거든요.. 따라서 캡슐화는 곧 코드 변경에 코드 영향도를 최소화 하기 위해 존재한다고 볼 수 있겠네요.  \n\n그래서 어떻게 수정해야 되냐!  \n\n~~~ java\npublic abstract class RectangleSuperClass {\n\n    // ...\n\n    protected void changeRectangle(int multiple) {\n        this.right = multiple;\n        this.bottom = multiple;\n    }\n}\n~~~\n\n이렇게 하면 자식 객체는 3만큼 사각형을 늘려줘!! 라고 부모 객체에게 메세지를 전달만 하면 되는 것입니다.  \n\n**정리하면 상속을 쓰려면 부모 객체를 캡슐화를 잘해야 한다. 안그러면 자식 객체마다 코드 중복과 의존성이 강하게 결합되어 변경이 어렵다!! 가 되겠네요.**\n\n\n\n\n# 설계가 유연하지 않게된다.\n\n상속을 사용한 객체 설계는 실행시점에서 코드가 유연하지 못하는다는 것입니다.  \n무슨 말이냐 우선 아래 상속 관계를 보죠\n\n{% asset_img \"inherit-reason1.png\" %}\n출처: 이미지는 오브젝트 | 조영호\n\n이러한 상속 관계를 가질때 코드 실행중에 금액 할인 정책에서 비율 할인 정책으로 바꾸려면 어떻게 해야 할까요??  \n금액 할인 정책을 가지고 있는 AmountDiscountMovie 객체에는 각 상태값인 컨텍스트 정보가 있는데 바로 그냥 PercentDiscountMovie 객체로 스위칭 될까요? 한다 하더라도 AmountDiscountMovie에 컨텍스트 정보는 사라질것입니다. \n\n{% asset_img \"inherit-reason2.png\" %}\n\n\n위 코드 처럼 객체를 생성해서 각 컨텍스트 정보르 일일이 넣어 줘야하죠 ...\n\n바로 그래서 코드 실행시점에서도 유연하게 정책을 바꿀수 있는 방법이 합성인것입니다.  \n\n> 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법\n\n{% asset_img \"inherit-reason3.png\" %}\n\n위와 같이 하게 되면 실행중에도 얼마든지 changeDiscountPolicy 메소드를 호출하여 할인 정책을 스위칭 할 수 있습니다.  \n이것은 마치 Spring 에서 DI와 같은 개념이라 생각합니다. 이러한 이유 때문에 \"주입\" 을 통하여 실행중에도 유연하게 기능을 사용 할 수 있다고 생각합니다.","source":"_posts/OOP/상속보다는 합성을 사용해야 하는 이유.md","raw":"---\ntitle: 상속보다는 합성을 사용해야 하는 이유\ncatalog: true\ndate: 2019-07-31 23:15:15\nsubtitle: \nheader-img: \"bg_computer.jpg\"\ncategories:\n- 객체지향프로그래밍\ntags: \n- Book\n---\n\n# 들어가며\n상속은 막연히 부모 자식 관계 합성은 Setter 메소드 처럼 객체를 주입받는 패턴 정도만 알고 있었는데 \"오브젝트 - 조영호\" 책을 읽으면서 내용을 학습하여 이해하고자 정리 합니다. 그러면 먼저 상속과 합성이 무엇인지 부터 제가 깨닳은 내용을 공유해 드리죠\n\n# 왜 상속보단 합성을 써야 할 까?\n\n공통 역활을 수행하는 부모 클래스를 두고 부모 기능을 더하여 각자에 기능을 수행하는 자식클래스를 사용하는게 잘 못된다고 말하는것은 아니었습니다. 책에서 말하는 상속에 위험성은 2가지 였습니다.  \n\n# 상속은 캡슐화가 약화된다.\n    \n[캡슐화](https://biggwang.github.io/2019/07/31/OOP/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%BA%A1%EC%8A%90%ED%99%94%20%EA%B7%B8%EA%B2%83%EC%9D%B4%20%EC%95%8C%EA%B3%A0%20%EC%8B%B6%EB%8B%A4/) 에 대한 설명은 따로 포스팅하였습니다~!\n> 부모 클래스에 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.  \n캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다. 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워진다.   \n\n저는 이렇게 이해했습니다.  \n상속은 캡슐화를 위반한다. -> 상속을 하면 캡슐화를 위반할 확률이 높아진다. 또는 상속을 하려면 캡슐화를 떠 신경써서 잘 해야 한다!!\n\n하지만, 캡슐화를 잘 시켜놓고 사용하면 좋은데 부모 클래스에 캡슐화가 잘 되지 않는다면 어떻게 될까요?  \n\n다시 말해서 **변경 될 수 있는 부분은 감추면서** 부모 클래스가 수행해야 할 역활과 책임을 온전히 처리하지 못하면 자식 클래스는 부모 클래스에 역활을 무자비하게 사용하여 강한 의존성을 가질수 있게 됩니다. 상황을 예로 들어 볼까요?\n\n# 변경이 엄청 어려움\n캡슐화 되지 못한 부모 클래스에 자식 클래스가 100개 있다고 가정해 보죠.  \n각 자식클래스는 신난다~~ 하고 부모 클래스에서 감추고 싶은 부분을 마음데로 접근하고 사용 하기 시작합니다. 코드를 보시죠  \n\n~~~ java\npublic abstract class RectangleSuperClass {\n\n    private int left;\n    private int top;\n    private int right;\n    private int bottom;\n\n    // construcotr..\n\n    // getter, setter ..\n}\n~~~\n\n부모 객체가 할 일을 자식 객체에서 일일이 이렇게 구현하는게 맞을까요?\n~~~ java\npublic class RectangleSubClass extends RectangleSuperClass {\n    \n    // any method\n\n    public void anyMethod(int multiple) {\n        super.setRight(super.getRight() * multiple);\n        super.setBottom(super.getBottom() * multiple);\n    }\n}\n~~~\n\n각 자식 클래스에서 사각형에 가로, 세로를 증가시키는 코드가 있다고 해보죠.  \n근데 부모 클래스에서 사각형의 넓이를 변경하는 변수명을 right, bottom이 아니라 length, hight로 바꿔야 겠다고 하면 어떻게 될까요?? 바꾸고 저장하면 100개의 클래스에서 빨간줄이 주르르르륵 뜰것입니다.  \n\n그 빨간줄이 많으면 많을수록 그만큼 코드 의존도가 높다고 할 수 있는것이죠.\n\n그 외 문제점은 코드 중복입니다. 부모 객체에서 사각형을 크기를 핸들링하는 메소드를 만들고 자식클래스에서 사용하라고 했다면 자식클래스 입장에서는 함수만 쓰기만 하면 됩니다. 위 코드 처럼 setRight, setBottom 를 신경쓸필요 없다는 것이죠.  \n\n**바로 이 맥락이 부모 클래스가 캡슐화 되지 못해서 벌어지는 현상을 보고 계시고 있는겁니다.**  \n\n부모객체가 변경될수 있는 부분(구현)은 감추고 함수만 호출(인터페이스)하도록 하여 변경에 코드 영향도를 최소화 시켜야 되는데 그러지 못해서 코드변경이 일어 날 때마나 자식 객체까지 영향을 미치게 되는 것이죠.  \n자식 객체는 잘못 없는겁니다. 왜냐하면 부모 객체에서 접근 할 수 있도록 해줬거든요.. 따라서 캡슐화는 곧 코드 변경에 코드 영향도를 최소화 하기 위해 존재한다고 볼 수 있겠네요.  \n\n그래서 어떻게 수정해야 되냐!  \n\n~~~ java\npublic abstract class RectangleSuperClass {\n\n    // ...\n\n    protected void changeRectangle(int multiple) {\n        this.right = multiple;\n        this.bottom = multiple;\n    }\n}\n~~~\n\n이렇게 하면 자식 객체는 3만큼 사각형을 늘려줘!! 라고 부모 객체에게 메세지를 전달만 하면 되는 것입니다.  \n\n**정리하면 상속을 쓰려면 부모 객체를 캡슐화를 잘해야 한다. 안그러면 자식 객체마다 코드 중복과 의존성이 강하게 결합되어 변경이 어렵다!! 가 되겠네요.**\n\n\n\n\n# 설계가 유연하지 않게된다.\n\n상속을 사용한 객체 설계는 실행시점에서 코드가 유연하지 못하는다는 것입니다.  \n무슨 말이냐 우선 아래 상속 관계를 보죠\n\n{% asset_img \"inherit-reason1.png\" %}\n출처: 이미지는 오브젝트 | 조영호\n\n이러한 상속 관계를 가질때 코드 실행중에 금액 할인 정책에서 비율 할인 정책으로 바꾸려면 어떻게 해야 할까요??  \n금액 할인 정책을 가지고 있는 AmountDiscountMovie 객체에는 각 상태값인 컨텍스트 정보가 있는데 바로 그냥 PercentDiscountMovie 객체로 스위칭 될까요? 한다 하더라도 AmountDiscountMovie에 컨텍스트 정보는 사라질것입니다. \n\n{% asset_img \"inherit-reason2.png\" %}\n\n\n위 코드 처럼 객체를 생성해서 각 컨텍스트 정보르 일일이 넣어 줘야하죠 ...\n\n바로 그래서 코드 실행시점에서도 유연하게 정책을 바꿀수 있는 방법이 합성인것입니다.  \n\n> 합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법\n\n{% asset_img \"inherit-reason3.png\" %}\n\n위와 같이 하게 되면 실행중에도 얼마든지 changeDiscountPolicy 메소드를 호출하여 할인 정책을 스위칭 할 수 있습니다.  \n이것은 마치 Spring 에서 DI와 같은 개념이라 생각합니다. 이러한 이유 때문에 \"주입\" 을 통하여 실행중에도 유연하게 기능을 사용 할 수 있다고 생각합니다.","slug":"OOP/상속보다는 합성을 사용해야 하는 이유","published":1,"updated":"2019-08-18T06:55:34.986Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids17001rk0oth2bzdn8z","content":"<h1><span id=\"들어가며\">들어가며</span></h1>\n<p>상속은 막연히 부모 자식 관계 합성은 Setter 메소드 처럼 객체를 주입받는 패턴 정도만 알고 있었는데 “오브젝트 - 조영호” 책을 읽으면서 내용을 학습하여 이해하고자 정리 합니다. 그러면 먼저 상속과 합성이 무엇인지 부터 제가 깨닳은 내용을 공유해 드리죠</p>\n<h1><span id=\"왜-상속보단-합성을-써야-할-까\">왜 상속보단 합성을 써야 할 까?</span></h1>\n<p>공통 역활을 수행하는 부모 클래스를 두고 부모 기능을 더하여 각자에 기능을 수행하는 자식클래스를 사용하는게 잘 못된다고 말하는것은 아니었습니다. 책에서 말하는 상속에 위험성은 2가지 였습니다.</p>\n<h1><span id=\"상속은-캡슐화가-약화된다\">상속은 캡슐화가 약화된다.</span></h1>\n<p><a href=\"https://biggwang.github.io/2019/07/31/OOP/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%BA%A1%EC%8A%90%ED%99%94%20%EA%B7%B8%EA%B2%83%EC%9D%B4%20%EC%95%8C%EA%B3%A0%20%EC%8B%B6%EB%8B%A4/\">캡슐화</a> 에 대한 설명은 따로 포스팅하였습니다~!</p>\n<blockquote>\n<p>부모 클래스에 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.<br>\n캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다. 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워진다.</p>\n</blockquote>\n<p>저는 이렇게 이해했습니다.<br>\n상속은 캡슐화를 위반한다. -&gt; 상속을 하면 캡슐화를 위반할 확률이 높아진다. 또는 상속을 하려면 캡슐화를 떠 신경써서 잘 해야 한다!!</p>\n<p>하지만, 캡슐화를 잘 시켜놓고 사용하면 좋은데 부모 클래스에 캡슐화가 잘 되지 않는다면 어떻게 될까요?</p>\n<p>다시 말해서 <strong>변경 될 수 있는 부분은 감추면서</strong> 부모 클래스가 수행해야 할 역활과 책임을 온전히 처리하지 못하면 자식 클래스는 부모 클래스에 역활을 무자비하게 사용하여 강한 의존성을 가질수 있게 됩니다. 상황을 예로 들어 볼까요?</p>\n<h1><span id=\"변경이-엄청-어려움\">변경이 엄청 어려움</span></h1>\n<p>캡슐화 되지 못한 부모 클래스에 자식 클래스가 100개 있다고 가정해 보죠.<br>\n각 자식클래스는 신난다~~ 하고 부모 클래스에서 감추고 싶은 부분을 마음데로 접근하고 사용 하기 시작합니다. 코드를 보시죠</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RectangleSuperClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> left;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> top;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> right;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> bottom;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// construcotr..</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getter, setter ..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>부모 객체가 할 일을 자식 객체에서 일일이 이렇게 구현하는게 맞을까요?</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RectangleSubClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">RectangleSuperClass</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// any method</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">anyMethod</span><span class=\"params\">(<span class=\"keyword\">int</span> multiple)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setRight(<span class=\"keyword\">super</span>.getRight() * multiple);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setBottom(<span class=\"keyword\">super</span>.getBottom() * multiple);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>각 자식 클래스에서 사각형에 가로, 세로를 증가시키는 코드가 있다고 해보죠.<br>\n근데 부모 클래스에서 사각형의 넓이를 변경하는 변수명을 right, bottom이 아니라 length, hight로 바꿔야 겠다고 하면 어떻게 될까요?? 바꾸고 저장하면 100개의 클래스에서 빨간줄이 주르르르륵 뜰것입니다.</p>\n<p>그 빨간줄이 많으면 많을수록 그만큼 코드 의존도가 높다고 할 수 있는것이죠.</p>\n<p>그 외 문제점은 코드 중복입니다. 부모 객체에서 사각형을 크기를 핸들링하는 메소드를 만들고 자식클래스에서 사용하라고 했다면 자식클래스 입장에서는 함수만 쓰기만 하면 됩니다. 위 코드 처럼 setRight, setBottom 를 신경쓸필요 없다는 것이죠.</p>\n<p><strong>바로 이 맥락이 부모 클래스가 캡슐화 되지 못해서 벌어지는 현상을 보고 계시고 있는겁니다.</strong></p>\n<p>부모객체가 변경될수 있는 부분(구현)은 감추고 함수만 호출(인터페이스)하도록 하여 변경에 코드 영향도를 최소화 시켜야 되는데 그러지 못해서 코드변경이 일어 날 때마나 자식 객체까지 영향을 미치게 되는 것이죠.<br>\n자식 객체는 잘못 없는겁니다. 왜냐하면 부모 객체에서 접근 할 수 있도록 해줬거든요… 따라서 캡슐화는 곧 코드 변경에 코드 영향도를 최소화 하기 위해 존재한다고 볼 수 있겠네요.</p>\n<p>그래서 어떻게 수정해야 되냐!</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RectangleSuperClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">changeRectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> multiple)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.right = multiple;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bottom = multiple;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 하면 자식 객체는 3만큼 사각형을 늘려줘!! 라고 부모 객체에게 메세지를 전달만 하면 되는 것입니다.</p>\n<p><strong>정리하면 상속을 쓰려면 부모 객체를 캡슐화를 잘해야 한다. 안그러면 자식 객체마다 코드 중복과 의존성이 강하게 결합되어 변경이 어렵다!! 가 되겠네요.</strong></p>\n<h1><span id=\"설계가-유연하지-않게된다\">설계가 유연하지 않게된다.</span></h1>\n<p>상속을 사용한 객체 설계는 실행시점에서 코드가 유연하지 못하는다는 것입니다.<br>\n무슨 말이냐 우선 아래 상속 관계를 보죠</p>\n<img src=\"/2019/07/31/OOP/상속보다는%20합성을%20사용해야%20하는%20이유/inherit-reason1.png\">\n<p>출처: 이미지는 오브젝트 | 조영호</p>\n<p>이러한 상속 관계를 가질때 코드 실행중에 금액 할인 정책에서 비율 할인 정책으로 바꾸려면 어떻게 해야 할까요??<br>\n금액 할인 정책을 가지고 있는 AmountDiscountMovie 객체에는 각 상태값인 컨텍스트 정보가 있는데 바로 그냥 PercentDiscountMovie 객체로 스위칭 될까요? 한다 하더라도 AmountDiscountMovie에 컨텍스트 정보는 사라질것입니다.</p>\n<img src=\"/2019/07/31/OOP/상속보다는%20합성을%20사용해야%20하는%20이유/inherit-reason2.png\">\n<p>위 코드 처럼 객체를 생성해서 각 컨텍스트 정보르 일일이 넣어 줘야하죠 …</p>\n<p>바로 그래서 코드 실행시점에서도 유연하게 정책을 바꿀수 있는 방법이 합성인것입니다.</p>\n<blockquote>\n<p>합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법</p>\n</blockquote>\n<img src=\"/2019/07/31/OOP/상속보다는%20합성을%20사용해야%20하는%20이유/inherit-reason3.png\">\n<p>위와 같이 하게 되면 실행중에도 얼마든지 changeDiscountPolicy 메소드를 호출하여 할인 정책을 스위칭 할 수 있습니다.<br>\n이것은 마치 Spring 에서 DI와 같은 개념이라 생각합니다. 이러한 이유 때문에 “주입” 을 통하여 실행중에도 유연하게 기능을 사용 할 수 있다고 생각합니다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>들어가며</h1>\n<p>상속은 막연히 부모 자식 관계 합성은 Setter 메소드 처럼 객체를 주입받는 패턴 정도만 알고 있었는데 “오브젝트 - 조영호” 책을 읽으면서 내용을 학습하여 이해하고자 정리 합니다. 그러면 먼저 상속과 합성이 무엇인지 부터 제가 깨닳은 내용을 공유해 드리죠</p>\n<h1>왜 상속보단 합성을 써야 할 까?</h1>\n<p>공통 역활을 수행하는 부모 클래스를 두고 부모 기능을 더하여 각자에 기능을 수행하는 자식클래스를 사용하는게 잘 못된다고 말하는것은 아니었습니다. 책에서 말하는 상속에 위험성은 2가지 였습니다.</p>\n<h1>상속은 캡슐화가 약화된다.</h1>\n<p><a href=\"https://biggwang.github.io/2019/07/31/OOP/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%BA%A1%EC%8A%90%ED%99%94%20%EA%B7%B8%EA%B2%83%EC%9D%B4%20%EC%95%8C%EA%B3%A0%20%EC%8B%B6%EB%8B%A4/\">캡슐화</a> 에 대한 설명은 따로 포스팅하였습니다~!</p>\n<blockquote>\n<p>부모 클래스에 구현이 자식 클래스에게 노출되기 때문에 캡슐화가 약화된다.<br>\n캡슐화의 약화는 자식 클래스가 부모 클래스에 강하게 결합되도록 만들기 때문에 부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률을 높인다. 결과적으로 상속을 과도하게 사용한 코드는 변경하기도 어려워진다.</p>\n</blockquote>\n<p>저는 이렇게 이해했습니다.<br>\n상속은 캡슐화를 위반한다. -&gt; 상속을 하면 캡슐화를 위반할 확률이 높아진다. 또는 상속을 하려면 캡슐화를 떠 신경써서 잘 해야 한다!!</p>\n<p>하지만, 캡슐화를 잘 시켜놓고 사용하면 좋은데 부모 클래스에 캡슐화가 잘 되지 않는다면 어떻게 될까요?</p>\n<p>다시 말해서 <strong>변경 될 수 있는 부분은 감추면서</strong> 부모 클래스가 수행해야 할 역활과 책임을 온전히 처리하지 못하면 자식 클래스는 부모 클래스에 역활을 무자비하게 사용하여 강한 의존성을 가질수 있게 됩니다. 상황을 예로 들어 볼까요?</p>\n<h1>변경이 엄청 어려움</h1>\n<p>캡슐화 되지 못한 부모 클래스에 자식 클래스가 100개 있다고 가정해 보죠.<br>\n각 자식클래스는 신난다~~ 하고 부모 클래스에서 감추고 싶은 부분을 마음데로 접근하고 사용 하기 시작합니다. 코드를 보시죠</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RectangleSuperClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> left;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> top;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> right;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> bottom;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// construcotr..</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getter, setter ..</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>부모 객체가 할 일을 자식 객체에서 일일이 이렇게 구현하는게 맞을까요?</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RectangleSubClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">RectangleSuperClass</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// any method</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">anyMethod</span><span class=\"params\">(<span class=\"keyword\">int</span> multiple)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setRight(<span class=\"keyword\">super</span>.getRight() * multiple);</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setBottom(<span class=\"keyword\">super</span>.getBottom() * multiple);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>각 자식 클래스에서 사각형에 가로, 세로를 증가시키는 코드가 있다고 해보죠.<br>\n근데 부모 클래스에서 사각형의 넓이를 변경하는 변수명을 right, bottom이 아니라 length, hight로 바꿔야 겠다고 하면 어떻게 될까요?? 바꾸고 저장하면 100개의 클래스에서 빨간줄이 주르르르륵 뜰것입니다.</p>\n<p>그 빨간줄이 많으면 많을수록 그만큼 코드 의존도가 높다고 할 수 있는것이죠.</p>\n<p>그 외 문제점은 코드 중복입니다. 부모 객체에서 사각형을 크기를 핸들링하는 메소드를 만들고 자식클래스에서 사용하라고 했다면 자식클래스 입장에서는 함수만 쓰기만 하면 됩니다. 위 코드 처럼 setRight, setBottom 를 신경쓸필요 없다는 것이죠.</p>\n<p><strong>바로 이 맥락이 부모 클래스가 캡슐화 되지 못해서 벌어지는 현상을 보고 계시고 있는겁니다.</strong></p>\n<p>부모객체가 변경될수 있는 부분(구현)은 감추고 함수만 호출(인터페이스)하도록 하여 변경에 코드 영향도를 최소화 시켜야 되는데 그러지 못해서 코드변경이 일어 날 때마나 자식 객체까지 영향을 미치게 되는 것이죠.<br>\n자식 객체는 잘못 없는겁니다. 왜냐하면 부모 객체에서 접근 할 수 있도록 해줬거든요… 따라서 캡슐화는 곧 코드 변경에 코드 영향도를 최소화 하기 위해 존재한다고 볼 수 있겠네요.</p>\n<p>그래서 어떻게 수정해야 되냐!</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RectangleSuperClass</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">changeRectangle</span><span class=\"params\">(<span class=\"keyword\">int</span> multiple)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.right = multiple;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bottom = multiple;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>이렇게 하면 자식 객체는 3만큼 사각형을 늘려줘!! 라고 부모 객체에게 메세지를 전달만 하면 되는 것입니다.</p>\n<p><strong>정리하면 상속을 쓰려면 부모 객체를 캡슐화를 잘해야 한다. 안그러면 자식 객체마다 코드 중복과 의존성이 강하게 결합되어 변경이 어렵다!! 가 되겠네요.</strong></p>\n<h1>설계가 유연하지 않게된다.</h1>\n<p>상속을 사용한 객체 설계는 실행시점에서 코드가 유연하지 못하는다는 것입니다.<br>\n무슨 말이냐 우선 아래 상속 관계를 보죠</p>\n<img src=\"/2019/07/31/OOP/상속보다는%20합성을%20사용해야%20하는%20이유/inherit-reason1.png\">\n<p>출처: 이미지는 오브젝트 | 조영호</p>\n<p>이러한 상속 관계를 가질때 코드 실행중에 금액 할인 정책에서 비율 할인 정책으로 바꾸려면 어떻게 해야 할까요??<br>\n금액 할인 정책을 가지고 있는 AmountDiscountMovie 객체에는 각 상태값인 컨텍스트 정보가 있는데 바로 그냥 PercentDiscountMovie 객체로 스위칭 될까요? 한다 하더라도 AmountDiscountMovie에 컨텍스트 정보는 사라질것입니다.</p>\n<img src=\"/2019/07/31/OOP/상속보다는%20합성을%20사용해야%20하는%20이유/inherit-reason2.png\">\n<p>위 코드 처럼 객체를 생성해서 각 컨텍스트 정보르 일일이 넣어 줘야하죠 …</p>\n<p>바로 그래서 코드 실행시점에서도 유연하게 정책을 바꿀수 있는 방법이 합성인것입니다.</p>\n<blockquote>\n<p>합성은 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법</p>\n</blockquote>\n<img src=\"/2019/07/31/OOP/상속보다는%20합성을%20사용해야%20하는%20이유/inherit-reason3.png\">\n<p>위와 같이 하게 되면 실행중에도 얼마든지 changeDiscountPolicy 메소드를 호출하여 할인 정책을 스위칭 할 수 있습니다.<br>\n이것은 마치 Spring 에서 DI와 같은 개념이라 생각합니다. 이러한 이유 때문에 “주입” 을 통하여 실행중에도 유연하게 기능을 사용 할 수 있다고 생각합니다.</p>\n"},{"title":"개발자 논리적인 사고력에 대해서","catalog":true,"date":"2019-01-04T14:05:05.000Z","subtitle":"문제해결과 알고리즘 책을 읽고","header-img":"bg_computer.jpg","catagories":null,"_content":"\n### 들어가며 \n컴퓨팅사고력 향상을 위한 문제해결과 알고리즘에 대한 책을 읽으면서 개발자에 필수 역략인 문제해결 능력, 논리력, 절차적 사고력에 관한 정의와 개념이 잘되어 있어 내용을 정리하여 머릿속에 넣고 싶어 포스팅을 시작해 본다.\n\n\n### 문제란?\n> 현재 상태의 변화로 인해 본인이 원하는 방향의 목표 상태가 생기는 것을 의미\n\n여려 요인에 의해서 이루어야(해결해야) 하는 목표가 생긴 상태\n\n### 문제해결이란?\n> 현재 상태와 목표 상태의 차이를 해결한 결과물\n\n### 일반적 문제해결 과정\n> 문제 이해 -> 해결 방안 고안 -> 해결책 선택 -> 실행 및 평가\n\n### 컴퓨팅 기반 문제해결 과정\n> 문제 이해 -> 해결 과정 설계 -> 프로그램이 구현 -> 결과물 확인\n\n### 문제 이해\n가장 중요한 단계라고 생각한다. 이 단계에서 정확하게 상황을 이해한다면 나머지 단계는 이행만 하면 되기 때문이다.\n\n**그러면 일반적 문제 이해를 어떻게 하면 올바르게 할 수 있을까?**  \n- 문제 상황에 대해 주어진 조건과 정보를 바르게 이해하고 파악하기\n- 문제가 무엇인지 문제의 상황과 조건을 바탕으로 논리적 사고에 의해 문제를 분석\n- 문제를 다양한 측면에서 이해하고 바라볼 수 있는 통합적 사고\n\n**그러면 컴퓨팅 기반 문제 이해를 어떻게 하면 올바르게 할 수 있을까?**  \n- 주어진 자료를 가지고 규칙이나 패턴을 찾아서 문제를 재 정의 한다.\n\n책에서 말한 내용이지만 내생각을 표현해 보면 주어진 조건과 상황들을 조합하여 유추하고 결론을 이끌어 내며 편협적이지 않고 다양한 시선으로 생각하여 문제를 이해하는 능력을 말한다고 생각한다.\n\n### 절차적 문제해결의 과정\n> 문제해결 과정이란 문제를 해결하기 위해 필요한 절차 혹은 순서로 현재 상태에서 목표 상태로 도달하기 위한 일련의 인지적 처리 및 사고 활동의 과정을 순차적으로 나열하는 것..... 여기서 말하는 절차 혹은 순서란 목제해결을 위한 인지적 처리 과정을 정해진 순서에 따라 하나씩 단계별로 나열하는 것으로, 우리는 이를 '절차적 문제해결 과정' 이라고 한다.\n\n#### 종이접기\n절차적 문제를 해결하는 적절한 예이다.  \n종이접기를 하려면 접는 순서데로 해야 원하는 종이접기 결과물을 만들어 낼 수 었다. \n\n문제해결 하는 과정에서도 마찬가지라 생각이 든다. 목표로 하는 결과를 얻기 위해서 내가 어떤 과정을 밟아야 도달 할 수 있을까? 라는 생각하면서 논리적 사고력을 통해 절차를 만들어 가는게 정말 중요한 능력이라 생각한다.\n\n### 알고리즘이란?\n> 어떠한 주어진 문제를 해결하기 위한 절차적 순서나 방법\n\n위에서 말한것 처럼 절차적인 사고를 통해 문제 해결을 한다고 하였는데 여기서 절차적인 사고를 표현 하는 방식이 알고리즘 이다. \n\n### 자료구조란?\n자료(데이터)를 정확하고 빠르게 얻기 위해 자료를 잘 정돈(구조화)하는 것을 말한다.\n\n### 왜 자료구조가 필요할까?\n방금 위에서 말하였지만 데이터를 정확하고 빠르게 얻기 위해서이다.\n일상 생활에서 예를 들면 출근 시간이 늦어 빨리 옷을 입어야 하는 상황인데 옷정리를 하나도 하지 않고 심지어 겨울인데 여름옷이랑 섞여 있는 경우와 옷장에 용도와 계절에 맞게 구조적으로 정리된 옷장을 봤을때 어느 케이스가 더 정확하고 빠르게 옷을 골라 입을 수 있을까??\n\n컴퓨터 입장에서도 옷을 고르기 위해, 데이터를 정화하고 빠르게 얻기 위해 그에 맞는 자료 구조화가 필요한것이다.\n\n### 논리적 사고란\n> 논리적 사고는 문제에서 해답을 이끌어 내는 과정이 타당하고, 분석적이며, 단계적인 사고를 의미. 논리적 사고는 문제해결 과정의 단계에 대한 조건 및 근거를 명확히 해야 하며, 이는 서로 유기적인 관계를 가져야 한다. ~~ 논리적이란 애매모한 것을 분명하게 밝힐 수 있어야 하며 논리적 사고력은 애매성에서 벗어나 명확성, 정확성을 갖출 수 있게 생각을 구체화 시키고 발전시켜 나갈 수 있어야 한다.\n\n### 논리적 사고의 중요성\n문제 해결을 하기 위해서는 절차적 사고가 필요하고 그 절차가 정확하려면 논리적인 사고가 필수 이다.  프로그래머가 어떤 기능 크게는 아키텍처를 구상한다고 했을 때 정확한 논리적 사고를 바탕으로 결론을 도출해야 정확한 기능과 서비스가 나온다고 생각한다.  \n논리적 사고는 프로그래머에 역량중에 역량이다.\n\n### 논리적 사고력 기르기 \n#### 생각하는 습관\n평소 접하는 무엇이든 논리적으로 생각하는 습관을 길러야 한다.\n\n#### 상대 논리의 구조화\n하고자 하는 일에 실패했을 때 문제 논리를 구조화 하고 원인 분석을 통해 논리를 재구조화 하여 문제를 해결 해야 한다.\n\n#### 구체적인 생각\n나의 생각을 구체적으로 표현해야 한다. 예를 들어 그림을 그린다거나 도식으로 표현한다거나 나만의 편리하고 확실한 방법을 이용해 머릿속 생각을 끄집어 내어 구조화 시켜 뚜렷하게 생각을 표현하는 것이 중요하다.\n\n#### 타인에 대한 이해\n상대방에 대한 생각과 논리를 피드백 삼아 나의 논리에 밑거름이 되게 하자\n\n#### 설득\n논리적 사고는 고정된 생각이 아니다. 타인과 의논하면서 내가 깨닫지 못했던 내용을 발견하고 생각해 낼 수 있다.","source":"_posts/메타인지/[meta] 개발자 논리적인 사고력에 대해서.md","raw":"---\ntitle: 개발자 논리적인 사고력에 대해서\ncatalog: true\ndate: 2019-01-04 23:05:05\nsubtitle: 문제해결과 알고리즘 책을 읽고\nheader-img: \"bg_computer.jpg\"\ntags:\n- 개발일반\n- 메타\n- Book\ncatagories:\n---\n\n### 들어가며 \n컴퓨팅사고력 향상을 위한 문제해결과 알고리즘에 대한 책을 읽으면서 개발자에 필수 역략인 문제해결 능력, 논리력, 절차적 사고력에 관한 정의와 개념이 잘되어 있어 내용을 정리하여 머릿속에 넣고 싶어 포스팅을 시작해 본다.\n\n\n### 문제란?\n> 현재 상태의 변화로 인해 본인이 원하는 방향의 목표 상태가 생기는 것을 의미\n\n여려 요인에 의해서 이루어야(해결해야) 하는 목표가 생긴 상태\n\n### 문제해결이란?\n> 현재 상태와 목표 상태의 차이를 해결한 결과물\n\n### 일반적 문제해결 과정\n> 문제 이해 -> 해결 방안 고안 -> 해결책 선택 -> 실행 및 평가\n\n### 컴퓨팅 기반 문제해결 과정\n> 문제 이해 -> 해결 과정 설계 -> 프로그램이 구현 -> 결과물 확인\n\n### 문제 이해\n가장 중요한 단계라고 생각한다. 이 단계에서 정확하게 상황을 이해한다면 나머지 단계는 이행만 하면 되기 때문이다.\n\n**그러면 일반적 문제 이해를 어떻게 하면 올바르게 할 수 있을까?**  \n- 문제 상황에 대해 주어진 조건과 정보를 바르게 이해하고 파악하기\n- 문제가 무엇인지 문제의 상황과 조건을 바탕으로 논리적 사고에 의해 문제를 분석\n- 문제를 다양한 측면에서 이해하고 바라볼 수 있는 통합적 사고\n\n**그러면 컴퓨팅 기반 문제 이해를 어떻게 하면 올바르게 할 수 있을까?**  \n- 주어진 자료를 가지고 규칙이나 패턴을 찾아서 문제를 재 정의 한다.\n\n책에서 말한 내용이지만 내생각을 표현해 보면 주어진 조건과 상황들을 조합하여 유추하고 결론을 이끌어 내며 편협적이지 않고 다양한 시선으로 생각하여 문제를 이해하는 능력을 말한다고 생각한다.\n\n### 절차적 문제해결의 과정\n> 문제해결 과정이란 문제를 해결하기 위해 필요한 절차 혹은 순서로 현재 상태에서 목표 상태로 도달하기 위한 일련의 인지적 처리 및 사고 활동의 과정을 순차적으로 나열하는 것..... 여기서 말하는 절차 혹은 순서란 목제해결을 위한 인지적 처리 과정을 정해진 순서에 따라 하나씩 단계별로 나열하는 것으로, 우리는 이를 '절차적 문제해결 과정' 이라고 한다.\n\n#### 종이접기\n절차적 문제를 해결하는 적절한 예이다.  \n종이접기를 하려면 접는 순서데로 해야 원하는 종이접기 결과물을 만들어 낼 수 었다. \n\n문제해결 하는 과정에서도 마찬가지라 생각이 든다. 목표로 하는 결과를 얻기 위해서 내가 어떤 과정을 밟아야 도달 할 수 있을까? 라는 생각하면서 논리적 사고력을 통해 절차를 만들어 가는게 정말 중요한 능력이라 생각한다.\n\n### 알고리즘이란?\n> 어떠한 주어진 문제를 해결하기 위한 절차적 순서나 방법\n\n위에서 말한것 처럼 절차적인 사고를 통해 문제 해결을 한다고 하였는데 여기서 절차적인 사고를 표현 하는 방식이 알고리즘 이다. \n\n### 자료구조란?\n자료(데이터)를 정확하고 빠르게 얻기 위해 자료를 잘 정돈(구조화)하는 것을 말한다.\n\n### 왜 자료구조가 필요할까?\n방금 위에서 말하였지만 데이터를 정확하고 빠르게 얻기 위해서이다.\n일상 생활에서 예를 들면 출근 시간이 늦어 빨리 옷을 입어야 하는 상황인데 옷정리를 하나도 하지 않고 심지어 겨울인데 여름옷이랑 섞여 있는 경우와 옷장에 용도와 계절에 맞게 구조적으로 정리된 옷장을 봤을때 어느 케이스가 더 정확하고 빠르게 옷을 골라 입을 수 있을까??\n\n컴퓨터 입장에서도 옷을 고르기 위해, 데이터를 정화하고 빠르게 얻기 위해 그에 맞는 자료 구조화가 필요한것이다.\n\n### 논리적 사고란\n> 논리적 사고는 문제에서 해답을 이끌어 내는 과정이 타당하고, 분석적이며, 단계적인 사고를 의미. 논리적 사고는 문제해결 과정의 단계에 대한 조건 및 근거를 명확히 해야 하며, 이는 서로 유기적인 관계를 가져야 한다. ~~ 논리적이란 애매모한 것을 분명하게 밝힐 수 있어야 하며 논리적 사고력은 애매성에서 벗어나 명확성, 정확성을 갖출 수 있게 생각을 구체화 시키고 발전시켜 나갈 수 있어야 한다.\n\n### 논리적 사고의 중요성\n문제 해결을 하기 위해서는 절차적 사고가 필요하고 그 절차가 정확하려면 논리적인 사고가 필수 이다.  프로그래머가 어떤 기능 크게는 아키텍처를 구상한다고 했을 때 정확한 논리적 사고를 바탕으로 결론을 도출해야 정확한 기능과 서비스가 나온다고 생각한다.  \n논리적 사고는 프로그래머에 역량중에 역량이다.\n\n### 논리적 사고력 기르기 \n#### 생각하는 습관\n평소 접하는 무엇이든 논리적으로 생각하는 습관을 길러야 한다.\n\n#### 상대 논리의 구조화\n하고자 하는 일에 실패했을 때 문제 논리를 구조화 하고 원인 분석을 통해 논리를 재구조화 하여 문제를 해결 해야 한다.\n\n#### 구체적인 생각\n나의 생각을 구체적으로 표현해야 한다. 예를 들어 그림을 그린다거나 도식으로 표현한다거나 나만의 편리하고 확실한 방법을 이용해 머릿속 생각을 끄집어 내어 구조화 시켜 뚜렷하게 생각을 표현하는 것이 중요하다.\n\n#### 타인에 대한 이해\n상대방에 대한 생각과 논리를 피드백 삼아 나의 논리에 밑거름이 되게 하자\n\n#### 설득\n논리적 사고는 고정된 생각이 아니다. 타인과 의논하면서 내가 깨닫지 못했던 내용을 발견하고 생각해 낼 수 있다.","slug":"메타인지/[meta] 개발자 논리적인 사고력에 대해서","published":1,"updated":"2019-07-10T14:43:29.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids1b001yk0otv9p35l6m","content":"<h3><span id=\"들어가며\">들어가며</span></h3>\n<p>컴퓨팅사고력 향상을 위한 문제해결과 알고리즘에 대한 책을 읽으면서 개발자에 필수 역략인 문제해결 능력, 논리력, 절차적 사고력에 관한 정의와 개념이 잘되어 있어 내용을 정리하여 머릿속에 넣고 싶어 포스팅을 시작해 본다.</p>\n<h3><span id=\"문제란\">문제란?</span></h3>\n<blockquote>\n<p>현재 상태의 변화로 인해 본인이 원하는 방향의 목표 상태가 생기는 것을 의미</p>\n</blockquote>\n<p>여려 요인에 의해서 이루어야(해결해야) 하는 목표가 생긴 상태</p>\n<h3><span id=\"문제해결이란\">문제해결이란?</span></h3>\n<blockquote>\n<p>현재 상태와 목표 상태의 차이를 해결한 결과물</p>\n</blockquote>\n<h3><span id=\"일반적-문제해결-과정\">일반적 문제해결 과정</span></h3>\n<blockquote>\n<p>문제 이해 -&gt; 해결 방안 고안 -&gt; 해결책 선택 -&gt; 실행 및 평가</p>\n</blockquote>\n<h3><span id=\"컴퓨팅-기반-문제해결-과정\">컴퓨팅 기반 문제해결 과정</span></h3>\n<blockquote>\n<p>문제 이해 -&gt; 해결 과정 설계 -&gt; 프로그램이 구현 -&gt; 결과물 확인</p>\n</blockquote>\n<h3><span id=\"문제-이해\">문제 이해</span></h3>\n<p>가장 중요한 단계라고 생각한다. 이 단계에서 정확하게 상황을 이해한다면 나머지 단계는 이행만 하면 되기 때문이다.</p>\n<p><strong>그러면 일반적 문제 이해를 어떻게 하면 올바르게 할 수 있을까?</strong></p>\n<ul>\n<li>문제 상황에 대해 주어진 조건과 정보를 바르게 이해하고 파악하기</li>\n<li>문제가 무엇인지 문제의 상황과 조건을 바탕으로 논리적 사고에 의해 문제를 분석</li>\n<li>문제를 다양한 측면에서 이해하고 바라볼 수 있는 통합적 사고</li>\n</ul>\n<p><strong>그러면 컴퓨팅 기반 문제 이해를 어떻게 하면 올바르게 할 수 있을까?</strong></p>\n<ul>\n<li>주어진 자료를 가지고 규칙이나 패턴을 찾아서 문제를 재 정의 한다.</li>\n</ul>\n<p>책에서 말한 내용이지만 내생각을 표현해 보면 주어진 조건과 상황들을 조합하여 유추하고 결론을 이끌어 내며 편협적이지 않고 다양한 시선으로 생각하여 문제를 이해하는 능력을 말한다고 생각한다.</p>\n<h3><span id=\"절차적-문제해결의-과정\">절차적 문제해결의 과정</span></h3>\n<blockquote>\n<p>문제해결 과정이란 문제를 해결하기 위해 필요한 절차 혹은 순서로 현재 상태에서 목표 상태로 도달하기 위한 일련의 인지적 처리 및 사고 활동의 과정을 순차적으로 나열하는 것… 여기서 말하는 절차 혹은 순서란 목제해결을 위한 인지적 처리 과정을 정해진 순서에 따라 하나씩 단계별로 나열하는 것으로, 우리는 이를 ‘절차적 문제해결 과정’ 이라고 한다.</p>\n</blockquote>\n<h4><span id=\"종이접기\">종이접기</span></h4>\n<p>절차적 문제를 해결하는 적절한 예이다.<br>\n종이접기를 하려면 접는 순서데로 해야 원하는 종이접기 결과물을 만들어 낼 수 었다.</p>\n<p>문제해결 하는 과정에서도 마찬가지라 생각이 든다. 목표로 하는 결과를 얻기 위해서 내가 어떤 과정을 밟아야 도달 할 수 있을까? 라는 생각하면서 논리적 사고력을 통해 절차를 만들어 가는게 정말 중요한 능력이라 생각한다.</p>\n<h3><span id=\"알고리즘이란\">알고리즘이란?</span></h3>\n<blockquote>\n<p>어떠한 주어진 문제를 해결하기 위한 절차적 순서나 방법</p>\n</blockquote>\n<p>위에서 말한것 처럼 절차적인 사고를 통해 문제 해결을 한다고 하였는데 여기서 절차적인 사고를 표현 하는 방식이 알고리즘 이다.</p>\n<h3><span id=\"자료구조란\">자료구조란?</span></h3>\n<p>자료(데이터)를 정확하고 빠르게 얻기 위해 자료를 잘 정돈(구조화)하는 것을 말한다.</p>\n<h3><span id=\"왜-자료구조가-필요할까\">왜 자료구조가 필요할까?</span></h3>\n<p>방금 위에서 말하였지만 데이터를 정확하고 빠르게 얻기 위해서이다.<br>\n일상 생활에서 예를 들면 출근 시간이 늦어 빨리 옷을 입어야 하는 상황인데 옷정리를 하나도 하지 않고 심지어 겨울인데 여름옷이랑 섞여 있는 경우와 옷장에 용도와 계절에 맞게 구조적으로 정리된 옷장을 봤을때 어느 케이스가 더 정확하고 빠르게 옷을 골라 입을 수 있을까??</p>\n<p>컴퓨터 입장에서도 옷을 고르기 위해, 데이터를 정화하고 빠르게 얻기 위해 그에 맞는 자료 구조화가 필요한것이다.</p>\n<h3><span id=\"논리적-사고란\">논리적 사고란</span></h3>\n<blockquote>\n<p>논리적 사고는 문제에서 해답을 이끌어 내는 과정이 타당하고, 분석적이며, 단계적인 사고를 의미. 논리적 사고는 문제해결 과정의 단계에 대한 조건 및 근거를 명확히 해야 하며, 이는 서로 유기적인 관계를 가져야 한다. ~~ 논리적이란 애매모한 것을 분명하게 밝힐 수 있어야 하며 논리적 사고력은 애매성에서 벗어나 명확성, 정확성을 갖출 수 있게 생각을 구체화 시키고 발전시켜 나갈 수 있어야 한다.</p>\n</blockquote>\n<h3><span id=\"논리적-사고의-중요성\">논리적 사고의 중요성</span></h3>\n<p>문제 해결을 하기 위해서는 절차적 사고가 필요하고 그 절차가 정확하려면 논리적인 사고가 필수 이다.  프로그래머가 어떤 기능 크게는 아키텍처를 구상한다고 했을 때 정확한 논리적 사고를 바탕으로 결론을 도출해야 정확한 기능과 서비스가 나온다고 생각한다.<br>\n논리적 사고는 프로그래머에 역량중에 역량이다.</p>\n<h3><span id=\"논리적-사고력-기르기\">논리적 사고력 기르기</span></h3>\n<h4><span id=\"생각하는-습관\">생각하는 습관</span></h4>\n<p>평소 접하는 무엇이든 논리적으로 생각하는 습관을 길러야 한다.</p>\n<h4><span id=\"상대-논리의-구조화\">상대 논리의 구조화</span></h4>\n<p>하고자 하는 일에 실패했을 때 문제 논리를 구조화 하고 원인 분석을 통해 논리를 재구조화 하여 문제를 해결 해야 한다.</p>\n<h4><span id=\"구체적인-생각\">구체적인 생각</span></h4>\n<p>나의 생각을 구체적으로 표현해야 한다. 예를 들어 그림을 그린다거나 도식으로 표현한다거나 나만의 편리하고 확실한 방법을 이용해 머릿속 생각을 끄집어 내어 구조화 시켜 뚜렷하게 생각을 표현하는 것이 중요하다.</p>\n<h4><span id=\"타인에-대한-이해\">타인에 대한 이해</span></h4>\n<p>상대방에 대한 생각과 논리를 피드백 삼아 나의 논리에 밑거름이 되게 하자</p>\n<h4><span id=\"설득\">설득</span></h4>\n<p>논리적 사고는 고정된 생각이 아니다. 타인과 의논하면서 내가 깨닫지 못했던 내용을 발견하고 생각해 낼 수 있다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>들어가며</h3>\n<p>컴퓨팅사고력 향상을 위한 문제해결과 알고리즘에 대한 책을 읽으면서 개발자에 필수 역략인 문제해결 능력, 논리력, 절차적 사고력에 관한 정의와 개념이 잘되어 있어 내용을 정리하여 머릿속에 넣고 싶어 포스팅을 시작해 본다.</p>\n<h3>문제란?</h3>\n<blockquote>\n<p>현재 상태의 변화로 인해 본인이 원하는 방향의 목표 상태가 생기는 것을 의미</p>\n</blockquote>\n<p>여려 요인에 의해서 이루어야(해결해야) 하는 목표가 생긴 상태</p>\n<h3>문제해결이란?</h3>\n<blockquote>\n<p>현재 상태와 목표 상태의 차이를 해결한 결과물</p>\n</blockquote>\n<h3>일반적 문제해결 과정</h3>\n<blockquote>\n<p>문제 이해 -&gt; 해결 방안 고안 -&gt; 해결책 선택 -&gt; 실행 및 평가</p>\n</blockquote>\n<h3>컴퓨팅 기반 문제해결 과정</h3>\n<blockquote>\n<p>문제 이해 -&gt; 해결 과정 설계 -&gt; 프로그램이 구현 -&gt; 결과물 확인</p>\n</blockquote>\n<h3>문제 이해</h3>\n<p>가장 중요한 단계라고 생각한다. 이 단계에서 정확하게 상황을 이해한다면 나머지 단계는 이행만 하면 되기 때문이다.</p>\n<p><strong>그러면 일반적 문제 이해를 어떻게 하면 올바르게 할 수 있을까?</strong></p>\n<ul>\n<li>문제 상황에 대해 주어진 조건과 정보를 바르게 이해하고 파악하기</li>\n<li>문제가 무엇인지 문제의 상황과 조건을 바탕으로 논리적 사고에 의해 문제를 분석</li>\n<li>문제를 다양한 측면에서 이해하고 바라볼 수 있는 통합적 사고</li>\n</ul>\n<p><strong>그러면 컴퓨팅 기반 문제 이해를 어떻게 하면 올바르게 할 수 있을까?</strong></p>\n<ul>\n<li>주어진 자료를 가지고 규칙이나 패턴을 찾아서 문제를 재 정의 한다.</li>\n</ul>\n<p>책에서 말한 내용이지만 내생각을 표현해 보면 주어진 조건과 상황들을 조합하여 유추하고 결론을 이끌어 내며 편협적이지 않고 다양한 시선으로 생각하여 문제를 이해하는 능력을 말한다고 생각한다.</p>\n<h3>절차적 문제해결의 과정</h3>\n<blockquote>\n<p>문제해결 과정이란 문제를 해결하기 위해 필요한 절차 혹은 순서로 현재 상태에서 목표 상태로 도달하기 위한 일련의 인지적 처리 및 사고 활동의 과정을 순차적으로 나열하는 것… 여기서 말하는 절차 혹은 순서란 목제해결을 위한 인지적 처리 과정을 정해진 순서에 따라 하나씩 단계별로 나열하는 것으로, 우리는 이를 ‘절차적 문제해결 과정’ 이라고 한다.</p>\n</blockquote>\n<h4>종이접기</h4>\n<p>절차적 문제를 해결하는 적절한 예이다.<br>\n종이접기를 하려면 접는 순서데로 해야 원하는 종이접기 결과물을 만들어 낼 수 었다.</p>\n<p>문제해결 하는 과정에서도 마찬가지라 생각이 든다. 목표로 하는 결과를 얻기 위해서 내가 어떤 과정을 밟아야 도달 할 수 있을까? 라는 생각하면서 논리적 사고력을 통해 절차를 만들어 가는게 정말 중요한 능력이라 생각한다.</p>\n<h3>알고리즘이란?</h3>\n<blockquote>\n<p>어떠한 주어진 문제를 해결하기 위한 절차적 순서나 방법</p>\n</blockquote>\n<p>위에서 말한것 처럼 절차적인 사고를 통해 문제 해결을 한다고 하였는데 여기서 절차적인 사고를 표현 하는 방식이 알고리즘 이다.</p>\n<h3>자료구조란?</h3>\n<p>자료(데이터)를 정확하고 빠르게 얻기 위해 자료를 잘 정돈(구조화)하는 것을 말한다.</p>\n<h3>왜 자료구조가 필요할까?</h3>\n<p>방금 위에서 말하였지만 데이터를 정확하고 빠르게 얻기 위해서이다.<br>\n일상 생활에서 예를 들면 출근 시간이 늦어 빨리 옷을 입어야 하는 상황인데 옷정리를 하나도 하지 않고 심지어 겨울인데 여름옷이랑 섞여 있는 경우와 옷장에 용도와 계절에 맞게 구조적으로 정리된 옷장을 봤을때 어느 케이스가 더 정확하고 빠르게 옷을 골라 입을 수 있을까??</p>\n<p>컴퓨터 입장에서도 옷을 고르기 위해, 데이터를 정화하고 빠르게 얻기 위해 그에 맞는 자료 구조화가 필요한것이다.</p>\n<h3>논리적 사고란</h3>\n<blockquote>\n<p>논리적 사고는 문제에서 해답을 이끌어 내는 과정이 타당하고, 분석적이며, 단계적인 사고를 의미. 논리적 사고는 문제해결 과정의 단계에 대한 조건 및 근거를 명확히 해야 하며, 이는 서로 유기적인 관계를 가져야 한다. ~~ 논리적이란 애매모한 것을 분명하게 밝힐 수 있어야 하며 논리적 사고력은 애매성에서 벗어나 명확성, 정확성을 갖출 수 있게 생각을 구체화 시키고 발전시켜 나갈 수 있어야 한다.</p>\n</blockquote>\n<h3>논리적 사고의 중요성</h3>\n<p>문제 해결을 하기 위해서는 절차적 사고가 필요하고 그 절차가 정확하려면 논리적인 사고가 필수 이다.  프로그래머가 어떤 기능 크게는 아키텍처를 구상한다고 했을 때 정확한 논리적 사고를 바탕으로 결론을 도출해야 정확한 기능과 서비스가 나온다고 생각한다.<br>\n논리적 사고는 프로그래머에 역량중에 역량이다.</p>\n<h3>논리적 사고력 기르기</h3>\n<h4>생각하는 습관</h4>\n<p>평소 접하는 무엇이든 논리적으로 생각하는 습관을 길러야 한다.</p>\n<h4>상대 논리의 구조화</h4>\n<p>하고자 하는 일에 실패했을 때 문제 논리를 구조화 하고 원인 분석을 통해 논리를 재구조화 하여 문제를 해결 해야 한다.</p>\n<h4>구체적인 생각</h4>\n<p>나의 생각을 구체적으로 표현해야 한다. 예를 들어 그림을 그린다거나 도식으로 표현한다거나 나만의 편리하고 확실한 방법을 이용해 머릿속 생각을 끄집어 내어 구조화 시켜 뚜렷하게 생각을 표현하는 것이 중요하다.</p>\n<h4>타인에 대한 이해</h4>\n<p>상대방에 대한 생각과 논리를 피드백 삼아 나의 논리에 밑거름이 되게 하자</p>\n<h4>설득</h4>\n<p>논리적 사고는 고정된 생각이 아니다. 타인과 의논하면서 내가 깨닫지 못했던 내용을 발견하고 생각해 낼 수 있다.</p>\n"},{"title":"개발자 어떻게 공부 해야 할까","catalog":true,"date":"2018-12-26T14:41:21.000Z","subtitle":"선배 개발자님들에 조언 정리와 나의 생각","header-img":"bg_computer.jpg","catagories":["개발일반"],"_content":"\n# 작성 동기\n개발자 어떻게 공부 해야 할까? 그 대답을 찾기위해 고민하고 스스롭 방법을 정립을 머릿속으로만 하였다.  \n**\"개발자 공부\"** 에 대한 선배 개발자님들에 영감을 얻고 내 나름데로 생각을 정리하고 방법을 정립하기 위해 작성해 본다.\n\n# 먼저 영감을준 선배 개발자님들에 조언 정리\n\n## 개발자의 평생 공부 | 임백준 \n----\n[보러가기](https://goo.gl/26K1HE)\n\n\n## 개발자는 어떻게 성장해야 할까? | 강대명 \n----\n[보러가기](https://goo.gl/4fcv6r)\n\n### 내가 흥미 있는 주제 위주로 블로그 하기\n\n### 나의 토이 프로젝트 공개하기\n\n### 팀에서 사용하지 않는 기술이라면 그럼 나혼자 사용해 봄으로써 기술을 습득하면 된다.\n\n### 실력\n#### 지금 얼마나 알고 있는지\n#### 얼마나 빨리 배우는지\n#### 지속적으로 학습하는지\n\n### 실력보다 중요한것은?\n\n#### 커뮤니케이션\n- 함께 일하고 싶은 동료인가?\n- 정보 공유를 잘하고 나의 생산성을 향상시켜줄 수 있는 사람\n- 나중에 우리팀에 함께 일하고자 추천 할 수 있는 사람\n\n위 질문에 Yes! 라고 주변에서 말할수 있는 상태라면 성실하고 잘하는 개발자이며 나아가 사람들과 잘 소통하고 끌어당기는 힘 개발 그이상에 힘이 있다고 생각한다.\n\n\n\n## 오픈소스 개발자 이야기 20170701_오픈소스 개발자의 공부방법(강대명) \n----\n[보러가기](https://goo.gl/7C17Tw)\n\n### 절대적인 노력과 시간은 필요함\n\n### 기반지식  \n강대명 개발자님은 새로운 것을 접할 때 쉬운책을 3~4권 정도 본다든지 어떤 기술을 습득할 때 이 기술이 왜 탄생했는지에 대한 탄생,역사 등을 접한다고 했다.  \n이것은 기반지식을 쌓는 행위라고 생각한다. 예전 부터 나도 기반지식에 대한 의미를 생각 했었는데 누군가의 이야기가 이해 되지 않는 경우는 2가지라고 했다.  \n\n- 내용자체가 어려운 경우\n- 기반 지식(컨텍스트)이 부족한 경우\n\n바로 2번째 경우에서 기반 지식은 곧 이해와 직결되는 사항이라 생각한다.\n이해라는 전체적인 그림을 그리기 위해서 각 기반 지식들이 퍼즐 조각과도 같은 것이다.  \n따라서 새로운 개념을 습득할 때 기반지식이 없는 상태라면 아래와 같은 행위로 기반지식을 많이 쌓아두면 점점 익숙해져서 더 많이 깨닿고 습득 할 수 있을 거라 생각한다.\n\n- 쉬운 개념부터 0부터 100까지 빠르게 습득한다. (예) 기본 서적, 동영상, 블로그 활용)\n- 탄생, 역사에 대한 히스토리를 보며 탄생의도를 파악한다.\n- 제일 중요한건 내가 배우고 싶어하는 호기심과 관심이다.\n- 그 관심을 가지고 토이프로젝트를 하면 최고다.\n- 그 과정에서 알게되고 적용했을때 즐거움이 좋은 선순환을 만들 것이다.\n\n\n### 공부 방법에 중요성\n> 추가적인 지식습득 없이 특정 방법으로 14%의 수학 성적 향상  \n올바른 방법만 바꿔도 Input 되는 지식없이도 실력이 향상된다는 것이고 이는 프로그래밍에도 적용된다고 한다.  \n나 또한 같은 생각이며 항상 올바른 방법을 추가하며 공부해야 한다고 생각한다.\n\n\n### 의식적인 연습\n\n#### 스타크래프트 럴커 피하기 연습\n프로게이머는 럴커 피하기 연습을 할 때 촉수가 delay 되는 시간 촉수를 피하기 위해 마우스 포인터 위치를 파악하여 끊임없는 반복 연습을 하여 럴커를 피하게 된다.\n\n> 의식적 연습이란 럴커를 피하기 위한 의식적 생각에 답으로 delay 시간과 마우스 포인트 위치를 파악하여 집중 노력을 했다는 것이다.  \n프로그래머가 어떠한 새로운 개념,기술,지식을 습득하기 위해선 내가 얻고자 하는 그 무언가를 전략적이고 의식적인 생각을 통해 끊임없이 노력, 제대로 된 노력, 정확 노력을 집중해서 하는 것이라고 생각한다.\n\n관련된 내용에 추천 책 \n- [아웃라이어](https://goo.gl/DB6dKW)\n- [1만 시간의 재발견](https://goo.gl/AbmyPJ)\n\n\n### 피드백\n반드시 필요한 단계이다.  \n투입한 나의 코스트가 낭비되지 않으려면 최대한 빨리 피드백을 받아 나의 상태를 진단하여 무엇이 잘못된지를 파악하여 계획을 다시 잡을 수 있다.\n\n> 제가 아는 모분은 아는 사람 볼때마다 코드 리뷰 부탁합니다.\n\n정말 개발을 잘하고 싶어하는 의지가 보이는 개발자인거 같다.  \n나도 위와 같은 행동이 정말 필요하다 생각하는데 실천은 잘 안되는거 같다.  \n정말 빨리 배우고 습득하고 싶다면 반드시 필요한 행동이라 생각한다.\n\n피드백 받는 방법은\n\n- 잘하는 선배 개발자에게 질문, 리뷰 요청\n- 웹상에서 질문\n- 오픈소스 개발 활동\n\n\n### 교정\n피드백을 통해 알게 된 내용을 바탕으로 실제 고쳐서 적용하는 것\n\n\n### 그리고 다시 의식적인 연습\n고쳐진 방법으로 다시 의식적인 연습\n\n\n\n## 그래서 나는 어떻게??\n----\n\n### 의식적연습 -> 피드백 -> 교정 -> 의시적연습 반복 \n각 단계에 대한 충실하게 지속적인 실천을 한다.\n\n\n\n","source":"_posts/메타인지/[meta] 개발자 어떻게 공부 해야 할까.md","raw":"---\ntitle: 개발자 어떻게 공부 해야 할까\ncatalog: true\ndate: 2018-12-26 23:41:21\nsubtitle: 선배 개발자님들에 조언 정리와 나의 생각\nheader-img: \"bg_computer.jpg\"\ntags:\n- 개발일반\n- 메타\ncatagories:\n- 개발일반\n---\n\n# 작성 동기\n개발자 어떻게 공부 해야 할까? 그 대답을 찾기위해 고민하고 스스롭 방법을 정립을 머릿속으로만 하였다.  \n**\"개발자 공부\"** 에 대한 선배 개발자님들에 영감을 얻고 내 나름데로 생각을 정리하고 방법을 정립하기 위해 작성해 본다.\n\n# 먼저 영감을준 선배 개발자님들에 조언 정리\n\n## 개발자의 평생 공부 | 임백준 \n----\n[보러가기](https://goo.gl/26K1HE)\n\n\n## 개발자는 어떻게 성장해야 할까? | 강대명 \n----\n[보러가기](https://goo.gl/4fcv6r)\n\n### 내가 흥미 있는 주제 위주로 블로그 하기\n\n### 나의 토이 프로젝트 공개하기\n\n### 팀에서 사용하지 않는 기술이라면 그럼 나혼자 사용해 봄으로써 기술을 습득하면 된다.\n\n### 실력\n#### 지금 얼마나 알고 있는지\n#### 얼마나 빨리 배우는지\n#### 지속적으로 학습하는지\n\n### 실력보다 중요한것은?\n\n#### 커뮤니케이션\n- 함께 일하고 싶은 동료인가?\n- 정보 공유를 잘하고 나의 생산성을 향상시켜줄 수 있는 사람\n- 나중에 우리팀에 함께 일하고자 추천 할 수 있는 사람\n\n위 질문에 Yes! 라고 주변에서 말할수 있는 상태라면 성실하고 잘하는 개발자이며 나아가 사람들과 잘 소통하고 끌어당기는 힘 개발 그이상에 힘이 있다고 생각한다.\n\n\n\n## 오픈소스 개발자 이야기 20170701_오픈소스 개발자의 공부방법(강대명) \n----\n[보러가기](https://goo.gl/7C17Tw)\n\n### 절대적인 노력과 시간은 필요함\n\n### 기반지식  \n강대명 개발자님은 새로운 것을 접할 때 쉬운책을 3~4권 정도 본다든지 어떤 기술을 습득할 때 이 기술이 왜 탄생했는지에 대한 탄생,역사 등을 접한다고 했다.  \n이것은 기반지식을 쌓는 행위라고 생각한다. 예전 부터 나도 기반지식에 대한 의미를 생각 했었는데 누군가의 이야기가 이해 되지 않는 경우는 2가지라고 했다.  \n\n- 내용자체가 어려운 경우\n- 기반 지식(컨텍스트)이 부족한 경우\n\n바로 2번째 경우에서 기반 지식은 곧 이해와 직결되는 사항이라 생각한다.\n이해라는 전체적인 그림을 그리기 위해서 각 기반 지식들이 퍼즐 조각과도 같은 것이다.  \n따라서 새로운 개념을 습득할 때 기반지식이 없는 상태라면 아래와 같은 행위로 기반지식을 많이 쌓아두면 점점 익숙해져서 더 많이 깨닿고 습득 할 수 있을 거라 생각한다.\n\n- 쉬운 개념부터 0부터 100까지 빠르게 습득한다. (예) 기본 서적, 동영상, 블로그 활용)\n- 탄생, 역사에 대한 히스토리를 보며 탄생의도를 파악한다.\n- 제일 중요한건 내가 배우고 싶어하는 호기심과 관심이다.\n- 그 관심을 가지고 토이프로젝트를 하면 최고다.\n- 그 과정에서 알게되고 적용했을때 즐거움이 좋은 선순환을 만들 것이다.\n\n\n### 공부 방법에 중요성\n> 추가적인 지식습득 없이 특정 방법으로 14%의 수학 성적 향상  \n올바른 방법만 바꿔도 Input 되는 지식없이도 실력이 향상된다는 것이고 이는 프로그래밍에도 적용된다고 한다.  \n나 또한 같은 생각이며 항상 올바른 방법을 추가하며 공부해야 한다고 생각한다.\n\n\n### 의식적인 연습\n\n#### 스타크래프트 럴커 피하기 연습\n프로게이머는 럴커 피하기 연습을 할 때 촉수가 delay 되는 시간 촉수를 피하기 위해 마우스 포인터 위치를 파악하여 끊임없는 반복 연습을 하여 럴커를 피하게 된다.\n\n> 의식적 연습이란 럴커를 피하기 위한 의식적 생각에 답으로 delay 시간과 마우스 포인트 위치를 파악하여 집중 노력을 했다는 것이다.  \n프로그래머가 어떠한 새로운 개념,기술,지식을 습득하기 위해선 내가 얻고자 하는 그 무언가를 전략적이고 의식적인 생각을 통해 끊임없이 노력, 제대로 된 노력, 정확 노력을 집중해서 하는 것이라고 생각한다.\n\n관련된 내용에 추천 책 \n- [아웃라이어](https://goo.gl/DB6dKW)\n- [1만 시간의 재발견](https://goo.gl/AbmyPJ)\n\n\n### 피드백\n반드시 필요한 단계이다.  \n투입한 나의 코스트가 낭비되지 않으려면 최대한 빨리 피드백을 받아 나의 상태를 진단하여 무엇이 잘못된지를 파악하여 계획을 다시 잡을 수 있다.\n\n> 제가 아는 모분은 아는 사람 볼때마다 코드 리뷰 부탁합니다.\n\n정말 개발을 잘하고 싶어하는 의지가 보이는 개발자인거 같다.  \n나도 위와 같은 행동이 정말 필요하다 생각하는데 실천은 잘 안되는거 같다.  \n정말 빨리 배우고 습득하고 싶다면 반드시 필요한 행동이라 생각한다.\n\n피드백 받는 방법은\n\n- 잘하는 선배 개발자에게 질문, 리뷰 요청\n- 웹상에서 질문\n- 오픈소스 개발 활동\n\n\n### 교정\n피드백을 통해 알게 된 내용을 바탕으로 실제 고쳐서 적용하는 것\n\n\n### 그리고 다시 의식적인 연습\n고쳐진 방법으로 다시 의식적인 연습\n\n\n\n## 그래서 나는 어떻게??\n----\n\n### 의식적연습 -> 피드백 -> 교정 -> 의시적연습 반복 \n각 단계에 대한 충실하게 지속적인 실천을 한다.\n\n\n\n","slug":"메타인지/[meta] 개발자 어떻게 공부 해야 할까","published":1,"updated":"2019-07-10T14:43:29.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids1d0022k0otrt8ulo4c","content":"<h1><span id=\"작성-동기\">작성 동기</span></h1>\n<p>개발자 어떻게 공부 해야 할까? 그 대답을 찾기위해 고민하고 스스롭 방법을 정립을 머릿속으로만 하였다.<br>\n<strong>“개발자 공부”</strong> 에 대한 선배 개발자님들에 영감을 얻고 내 나름데로 생각을 정리하고 방법을 정립하기 위해 작성해 본다.</p>\n<h1><span id=\"먼저-영감을준-선배-개발자님들에-조언-정리\">먼저 영감을준 선배 개발자님들에 조언 정리</span></h1>\n<h2><span id=\"개발자의-평생-공부-임백준\">개발자의 평생 공부 | 임백준</span></h2>\n<hr>\n<p><a href=\"https://goo.gl/26K1HE\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">보러가기</a></p>\n<h2><span id=\"개발자는-어떻게-성장해야-할까-강대명\">개발자는 어떻게 성장해야 할까? | 강대명</span></h2>\n<hr>\n<p><a href=\"https://goo.gl/4fcv6r\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">보러가기</a></p>\n<h3><span id=\"내가-흥미-있는-주제-위주로-블로그-하기\">내가 흥미 있는 주제 위주로 블로그 하기</span></h3>\n<h3><span id=\"나의-토이-프로젝트-공개하기\">나의 토이 프로젝트 공개하기</span></h3>\n<h3><span id=\"팀에서-사용하지-않는-기술이라면-그럼-나혼자-사용해-봄으로써-기술을-습득하면-된다\">팀에서 사용하지 않는 기술이라면 그럼 나혼자 사용해 봄으로써 기술을 습득하면 된다.</span></h3>\n<h3><span id=\"실력\">실력</span></h3>\n<h4><span id=\"지금-얼마나-알고-있는지\">지금 얼마나 알고 있는지</span></h4>\n<h4><span id=\"얼마나-빨리-배우는지\">얼마나 빨리 배우는지</span></h4>\n<h4><span id=\"지속적으로-학습하는지\">지속적으로 학습하는지</span></h4>\n<h3><span id=\"실력보다-중요한것은\">실력보다 중요한것은?</span></h3>\n<h4><span id=\"커뮤니케이션\">커뮤니케이션</span></h4>\n<ul>\n<li>함께 일하고 싶은 동료인가?</li>\n<li>정보 공유를 잘하고 나의 생산성을 향상시켜줄 수 있는 사람</li>\n<li>나중에 우리팀에 함께 일하고자 추천 할 수 있는 사람</li>\n</ul>\n<p>위 질문에 Yes! 라고 주변에서 말할수 있는 상태라면 성실하고 잘하는 개발자이며 나아가 사람들과 잘 소통하고 끌어당기는 힘 개발 그이상에 힘이 있다고 생각한다.</p>\n<h2><span id=\"오픈소스-개발자-이야기-20170701_오픈소스-개발자의-공부방법강대명\">오픈소스 개발자 이야기 20170701_오픈소스 개발자의 공부방법(강대명)</span></h2>\n<hr>\n<p><a href=\"https://goo.gl/7C17Tw\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">보러가기</a></p>\n<h3><span id=\"절대적인-노력과-시간은-필요함\">절대적인 노력과 시간은 필요함</span></h3>\n<h3><span id=\"기반지식\">기반지식</span></h3>\n<p>강대명 개발자님은 새로운 것을 접할 때 쉬운책을 3~4권 정도 본다든지 어떤 기술을 습득할 때 이 기술이 왜 탄생했는지에 대한 탄생,역사 등을 접한다고 했다.<br>\n이것은 기반지식을 쌓는 행위라고 생각한다. 예전 부터 나도 기반지식에 대한 의미를 생각 했었는데 누군가의 이야기가 이해 되지 않는 경우는 2가지라고 했다.</p>\n<ul>\n<li>내용자체가 어려운 경우</li>\n<li>기반 지식(컨텍스트)이 부족한 경우</li>\n</ul>\n<p>바로 2번째 경우에서 기반 지식은 곧 이해와 직결되는 사항이라 생각한다.<br>\n이해라는 전체적인 그림을 그리기 위해서 각 기반 지식들이 퍼즐 조각과도 같은 것이다.<br>\n따라서 새로운 개념을 습득할 때 기반지식이 없는 상태라면 아래와 같은 행위로 기반지식을 많이 쌓아두면 점점 익숙해져서 더 많이 깨닿고 습득 할 수 있을 거라 생각한다.</p>\n<ul>\n<li>쉬운 개념부터 0부터 100까지 빠르게 습득한다. (예) 기본 서적, 동영상, 블로그 활용)</li>\n<li>탄생, 역사에 대한 히스토리를 보며 탄생의도를 파악한다.</li>\n<li>제일 중요한건 내가 배우고 싶어하는 호기심과 관심이다.</li>\n<li>그 관심을 가지고 토이프로젝트를 하면 최고다.</li>\n<li>그 과정에서 알게되고 적용했을때 즐거움이 좋은 선순환을 만들 것이다.</li>\n</ul>\n<h3><span id=\"공부-방법에-중요성\">공부 방법에 중요성</span></h3>\n<blockquote>\n<p>추가적인 지식습득 없이 특정 방법으로 14%의 수학 성적 향상<br>\n올바른 방법만 바꿔도 Input 되는 지식없이도 실력이 향상된다는 것이고 이는 프로그래밍에도 적용된다고 한다.<br>\n나 또한 같은 생각이며 항상 올바른 방법을 추가하며 공부해야 한다고 생각한다.</p>\n</blockquote>\n<h3><span id=\"의식적인-연습\">의식적인 연습</span></h3>\n<h4><span id=\"스타크래프트-럴커-피하기-연습\">스타크래프트 럴커 피하기 연습</span></h4>\n<p>프로게이머는 럴커 피하기 연습을 할 때 촉수가 delay 되는 시간 촉수를 피하기 위해 마우스 포인터 위치를 파악하여 끊임없는 반복 연습을 하여 럴커를 피하게 된다.</p>\n<blockquote>\n<p>의식적 연습이란 럴커를 피하기 위한 의식적 생각에 답으로 delay 시간과 마우스 포인트 위치를 파악하여 집중 노력을 했다는 것이다.<br>\n프로그래머가 어떠한 새로운 개념,기술,지식을 습득하기 위해선 내가 얻고자 하는 그 무언가를 전략적이고 의식적인 생각을 통해 끊임없이 노력, 제대로 된 노력, 정확 노력을 집중해서 하는 것이라고 생각한다.</p>\n</blockquote>\n<p>관련된 내용에 추천 책</p>\n<ul>\n<li><a href=\"https://goo.gl/DB6dKW\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">아웃라이어</a></li>\n<li><a href=\"https://goo.gl/AbmyPJ\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">1만 시간의 재발견</a></li>\n</ul>\n<h3><span id=\"피드백\">피드백</span></h3>\n<p>반드시 필요한 단계이다.<br>\n투입한 나의 코스트가 낭비되지 않으려면 최대한 빨리 피드백을 받아 나의 상태를 진단하여 무엇이 잘못된지를 파악하여 계획을 다시 잡을 수 있다.</p>\n<blockquote>\n<p>제가 아는 모분은 아는 사람 볼때마다 코드 리뷰 부탁합니다.</p>\n</blockquote>\n<p>정말 개발을 잘하고 싶어하는 의지가 보이는 개발자인거 같다.<br>\n나도 위와 같은 행동이 정말 필요하다 생각하는데 실천은 잘 안되는거 같다.<br>\n정말 빨리 배우고 습득하고 싶다면 반드시 필요한 행동이라 생각한다.</p>\n<p>피드백 받는 방법은</p>\n<ul>\n<li>잘하는 선배 개발자에게 질문, 리뷰 요청</li>\n<li>웹상에서 질문</li>\n<li>오픈소스 개발 활동</li>\n</ul>\n<h3><span id=\"교정\">교정</span></h3>\n<p>피드백을 통해 알게 된 내용을 바탕으로 실제 고쳐서 적용하는 것</p>\n<h3><span id=\"그리고-다시-의식적인-연습\">그리고 다시 의식적인 연습</span></h3>\n<p>고쳐진 방법으로 다시 의식적인 연습</p>\n<h2><span id=\"그래서-나는-어떻게\">그래서 나는 어떻게??</span></h2>\n<hr>\n<h3><span id=\"의식적연습-gt-피드백-gt-교정-gt-의시적연습-반복\">의식적연습 -&gt; 피드백 -&gt; 교정 -&gt; 의시적연습 반복</span></h3>\n<p>각 단계에 대한 충실하게 지속적인 실천을 한다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>작성 동기</h1>\n<p>개발자 어떻게 공부 해야 할까? 그 대답을 찾기위해 고민하고 스스롭 방법을 정립을 머릿속으로만 하였다.<br>\n<strong>“개발자 공부”</strong> 에 대한 선배 개발자님들에 영감을 얻고 내 나름데로 생각을 정리하고 방법을 정립하기 위해 작성해 본다.</p>\n<h1>먼저 영감을준 선배 개발자님들에 조언 정리</h1>\n<h2>개발자의 평생 공부 | 임백준</h2>\n<hr>\n<p><a href=\"https://goo.gl/26K1HE\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">보러가기</a></p>\n<h2>개발자는 어떻게 성장해야 할까? | 강대명</h2>\n<hr>\n<p><a href=\"https://goo.gl/4fcv6r\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">보러가기</a></p>\n<h3>내가 흥미 있는 주제 위주로 블로그 하기</h3>\n<h3>나의 토이 프로젝트 공개하기</h3>\n<h3>팀에서 사용하지 않는 기술이라면 그럼 나혼자 사용해 봄으로써 기술을 습득하면 된다.</h3>\n<h3>실력</h3>\n<h4>지금 얼마나 알고 있는지</h4>\n<h4>얼마나 빨리 배우는지</h4>\n<h4>지속적으로 학습하는지</h4>\n<h3>실력보다 중요한것은?</h3>\n<h4>커뮤니케이션</h4>\n<ul>\n<li>함께 일하고 싶은 동료인가?</li>\n<li>정보 공유를 잘하고 나의 생산성을 향상시켜줄 수 있는 사람</li>\n<li>나중에 우리팀에 함께 일하고자 추천 할 수 있는 사람</li>\n</ul>\n<p>위 질문에 Yes! 라고 주변에서 말할수 있는 상태라면 성실하고 잘하는 개발자이며 나아가 사람들과 잘 소통하고 끌어당기는 힘 개발 그이상에 힘이 있다고 생각한다.</p>\n<h2>오픈소스 개발자 이야기 20170701_오픈소스 개발자의 공부방법(강대명)</h2>\n<hr>\n<p><a href=\"https://goo.gl/7C17Tw\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">보러가기</a></p>\n<h3>절대적인 노력과 시간은 필요함</h3>\n<h3>기반지식</h3>\n<p>강대명 개발자님은 새로운 것을 접할 때 쉬운책을 3~4권 정도 본다든지 어떤 기술을 습득할 때 이 기술이 왜 탄생했는지에 대한 탄생,역사 등을 접한다고 했다.<br>\n이것은 기반지식을 쌓는 행위라고 생각한다. 예전 부터 나도 기반지식에 대한 의미를 생각 했었는데 누군가의 이야기가 이해 되지 않는 경우는 2가지라고 했다.</p>\n<ul>\n<li>내용자체가 어려운 경우</li>\n<li>기반 지식(컨텍스트)이 부족한 경우</li>\n</ul>\n<p>바로 2번째 경우에서 기반 지식은 곧 이해와 직결되는 사항이라 생각한다.<br>\n이해라는 전체적인 그림을 그리기 위해서 각 기반 지식들이 퍼즐 조각과도 같은 것이다.<br>\n따라서 새로운 개념을 습득할 때 기반지식이 없는 상태라면 아래와 같은 행위로 기반지식을 많이 쌓아두면 점점 익숙해져서 더 많이 깨닿고 습득 할 수 있을 거라 생각한다.</p>\n<ul>\n<li>쉬운 개념부터 0부터 100까지 빠르게 습득한다. (예) 기본 서적, 동영상, 블로그 활용)</li>\n<li>탄생, 역사에 대한 히스토리를 보며 탄생의도를 파악한다.</li>\n<li>제일 중요한건 내가 배우고 싶어하는 호기심과 관심이다.</li>\n<li>그 관심을 가지고 토이프로젝트를 하면 최고다.</li>\n<li>그 과정에서 알게되고 적용했을때 즐거움이 좋은 선순환을 만들 것이다.</li>\n</ul>\n<h3>공부 방법에 중요성</h3>\n<blockquote>\n<p>추가적인 지식습득 없이 특정 방법으로 14%의 수학 성적 향상<br>\n올바른 방법만 바꿔도 Input 되는 지식없이도 실력이 향상된다는 것이고 이는 프로그래밍에도 적용된다고 한다.<br>\n나 또한 같은 생각이며 항상 올바른 방법을 추가하며 공부해야 한다고 생각한다.</p>\n</blockquote>\n<h3>의식적인 연습</h3>\n<h4>스타크래프트 럴커 피하기 연습</h4>\n<p>프로게이머는 럴커 피하기 연습을 할 때 촉수가 delay 되는 시간 촉수를 피하기 위해 마우스 포인터 위치를 파악하여 끊임없는 반복 연습을 하여 럴커를 피하게 된다.</p>\n<blockquote>\n<p>의식적 연습이란 럴커를 피하기 위한 의식적 생각에 답으로 delay 시간과 마우스 포인트 위치를 파악하여 집중 노력을 했다는 것이다.<br>\n프로그래머가 어떠한 새로운 개념,기술,지식을 습득하기 위해선 내가 얻고자 하는 그 무언가를 전략적이고 의식적인 생각을 통해 끊임없이 노력, 제대로 된 노력, 정확 노력을 집중해서 하는 것이라고 생각한다.</p>\n</blockquote>\n<p>관련된 내용에 추천 책</p>\n<ul>\n<li><a href=\"https://goo.gl/DB6dKW\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">아웃라이어</a></li>\n<li><a href=\"https://goo.gl/AbmyPJ\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">1만 시간의 재발견</a></li>\n</ul>\n<h3>피드백</h3>\n<p>반드시 필요한 단계이다.<br>\n투입한 나의 코스트가 낭비되지 않으려면 최대한 빨리 피드백을 받아 나의 상태를 진단하여 무엇이 잘못된지를 파악하여 계획을 다시 잡을 수 있다.</p>\n<blockquote>\n<p>제가 아는 모분은 아는 사람 볼때마다 코드 리뷰 부탁합니다.</p>\n</blockquote>\n<p>정말 개발을 잘하고 싶어하는 의지가 보이는 개발자인거 같다.<br>\n나도 위와 같은 행동이 정말 필요하다 생각하는데 실천은 잘 안되는거 같다.<br>\n정말 빨리 배우고 습득하고 싶다면 반드시 필요한 행동이라 생각한다.</p>\n<p>피드백 받는 방법은</p>\n<ul>\n<li>잘하는 선배 개발자에게 질문, 리뷰 요청</li>\n<li>웹상에서 질문</li>\n<li>오픈소스 개발 활동</li>\n</ul>\n<h3>교정</h3>\n<p>피드백을 통해 알게 된 내용을 바탕으로 실제 고쳐서 적용하는 것</p>\n<h3>그리고 다시 의식적인 연습</h3>\n<p>고쳐진 방법으로 다시 의식적인 연습</p>\n<h2>그래서 나는 어떻게??</h2>\n<hr>\n<h3>의식적연습 -&gt; 피드백 -&gt; 교정 -&gt; 의시적연습 반복</h3>\n<p>각 단계에 대한 충실하게 지속적인 실천을 한다.</p>\n"},{"title":"2018년 회고 - 시행착오","catalog":true,"subtitle":null,"header-img":"bg_computer.jpg","_content":"\n# Overview\n시행착오가 참 많았던 2018년 이었다.  \n다른 개발자 블로그를 많이 보면서 회고에 필요성을 느껴 처음 2018년도 회고를 작성해 본다.\n\n# 목차\n- **2018년 나의 키워드**\n    + 습관\n    + 멀티 스레드\n    + 본질, 프로그래머 본질적 능력, 역량\n\n- **습관 만들기**\n    + 독서\n    + 나의 계획 실천 프레임워크\n\n- **개발 자취**\n    + 매일 알고리즘 문제 풀기\n    + 패스트캠퍼스 컴퓨터 공학 인강\n    + TIL\n    + 토이프로젝트\n\n- **반성**\n    + 하루에 할 수 있는 것만!\n\n- **2018년 마무리**\n- **2019년에는?**\n\n## 2018년 나의 키워드\n\n### 습관\n독서를 통해 습관에 중요성을 깨닳았고 습관을 기르기 위해 나름 노력을 많이 했다. 노력한 결과 올해 내가 만든 습관은 아래와 같다.  \n\n- 독서\n- TIL\n- 계획\n\n내가 깨닳기도 전에 어느순간 위 행동을 하는데 힘이 전혀 들지 않았다. 해야 되기 때문에 해야 했고 그것은 확실한 동기가 부여된 상태면 실천하는 힘이 나한테 나온다는 것을 깨닳았다.\n\n### 멀티 스레드\n올해는 주로 Java단에서 멀티 스레드 환경에서 코딩을 많이 하게 되었고 관련 내용에 무한한 호기심과 관심으로 스스로 공부도 많이 하게 되었다.  버거운 일을 나누어서 처리하여 다시 취합하여 결과를 얻어내는 것이 참 매력적으로 다가왔다. \n\n### 본질\n개발자 실력은 본질적 능력을 키워야 한다는 것에 격한 공감을 가지게 되어 프로그래머로 본질적 능력을 어떻게 키워야 하는지에 관심을 많이 갖고 키우려 노력하였다.  \n\n- 문제해결 능력\n- 논리력\n- 새로운 개념 습득/적용 능력\n\n이것이 내가 생각하는 프로그래머가 가져야 하는 역략이자 본질적 능력이라 생각한다. 올해는 본질적 능력이 무엇인지에 대한 답만 알게 되었고 실질적 실천은 내년에는 **의도적 수련**을 통해 능력을 향상 시키자\n\n이러한 생각을 정립하게 된 것은 많은 선배 개발자님들에 지식 공유가 없었다면 영감도 얻지 못했을 것이다. 공유해주셔서 감사 드리며 영감을 얻은 경로는 아래와 같다.  \n\n- [개발자의 평생공부 | 임백준](https://goo.gl/26K1HE)\n- [개발자의 생명은 커뮤니케이션 능력 | 임백준](https://goo.gl/az65WJ)\n- [개발자처럼 생각하는 방법 - 문제 해결의 교훈 | 오역 유발자 의 IT 블로그 번역(번역자), Richard Reis(저자)](https://goo.gl/dFzW2M)\n- [오픈소스 개발자 이야기 20170701_오픈소스 개발자의 공부방법 | 강대명](https://goo.gl/LpeFdB)\n\n이 밖에 많은 개발자분들이 올려주신 글을 읽고 영향을 받아 어떤 능력이 필요하고 체화시켜야 하는지 알게 되어 내년에는 더 확실하게 묙표를 세울 수 있게 되었다.\n\n\n## 습관 만들기\n\n\n### 독서\n올해 가장 잘한 일 중에 하나가 독서하는 습관을 만들었다는 것이다.\n왜냐하면 다양한 분야에 책을 읽는 과정에서 공감, 까닳음, 반성, 동기부여, 삶의 계획 등 많은 것을 느끼게 해주었고 그것들은 내가 인생을 어떻게 살아야 겠다라는\n가이드? 역활을 해주어서 삶을 계획하고 주체적으로 살아 갈 수 있게 해주었기 때문이다.\n\n집근처 도서관이 있는것을 보고 한번 가볼까? 하고 아내랑 도서관을 들어가봤다.\n충격이었다. 남녀노소 공부하는 열기가 장난 아니었기 때문이었다. 더불어 수많은 책들의 제목만 봐도 그동안 내가 궁금해었던 주제들 보고 싶었던 책이 많다는것과 \n더 놀라운것은 내가 정말 지적 호기심이 많은 사람이었다는것을 깨닳은 것이었다. \n\n그 날부터 평균 1주에 1권씩 책을 읽어 나갔고 주로 프로그래밍 관련 된 책이었지만 그 외 인문, 과학, 자기개발 책들도 읽었다.\n\n#### 1년 70권 \n1년 100권이 목표였지만 올해는 70권을 읽었다기 보다 70권 정도 대출한것이다. 책을 볼때 0부터 100까지 끝까지 읽을때도 있고 아닐때도 있기 때문에 70권을 다 읽은 것은 아니다.\n하지만 30년 살면서 올해가 가장 많이 책을 읽었고 그만큼 독서의 중요성을 알게된 중요한 해이기도 했다.\n\n#### 하지만 독서 노트는....\n독서를 하고나서 얻은 지식을 써먹거나 실천하기 위해서는 메모를 하던가 장기기억으로 만들어야 한다.\n독서 노트를 통해 내가 그당시 얻은 영감, 생각, 느낀점, 앞으로 계획 등을 적음으로써 내용을 반복하고 실천하고 장기기억으로 이루어져 생각이 바뀌고 실천 할 수 있다.\n\n하지만 책을 많이 읽은 만큼 적은 독서노트는 5개정도 밖에 되지 않는다.. 얻은 지식을 체화시키지 않으면 밑빠지 독에 물붓기 밖에 되지 않으니 내년에는 독서 노트 반드시 적도록 하자\n\n#### 프로그래밍 책\n관련 내용이 없는 책이 없을 정도로 다양한 주제로 된 책들이 엄청나게 많이 나와있다. 욕심이 많아 다 읽고 싶어 닥치는데로 빌려보고 사고 하였지만 결국 전략이 필요헀다.\n\n**머릿속에 남는게 없다.**\n책을 다 읽었다고 내 지식이 되지 않는다.. 그냥 책을 1권 읽었다 성취감만 느기고 싶어 책만! 읽는것이다. 내것으로 만드는 전략없이 즉, 의도적인 행위 없이 글만 본것은 도로아미타불이다..\n\n**그럼 전략은?**\n- 읽는 목적을 분명히 한다.\n    + 특정 주제를 보고 싶은가? 그러면 목차보고 관심있는 주제부터 보자 그래야 집중력과 머릿속에 잘 기억에 남는다.\n    + 0부터 100까지 봐야 하는가? 그러면 목차를 쭉 스캔하고나서 읽되 특정 구절에 나의 생각을 적으면서 그날 읽은 것을 독서노트에 적고 반드시 내용을 공유하자\n    그리고 반복과 실천 뿐이다.\n    + 책을 더럽게 보자\n\n### 나의 계획 실천 프레임워크\n독서를 하면서 내가 이루고 싶은 것들을 이루기 위해서 체계적인 계획이 있어야 동기부여도 되면서 내가 무엇을 해야 하는지 딱 정해놔야 내가 실천 잘 할 수 있다는 것을 깨닳게 되어 고민해서 만든 나의 실천 프레임워크를 만들어 보았다. \n\n#### Evernote\n{% asset_img \"evernote.png\" %}  \n\n제일 먼저 사용했던 앱으로 계획에 대한 진행 상황을 한눈에 볼 수 없다는 단점이 있어서 Notion 갈아타게 되었다.\n\n#### Notion\n메모앱 끝판왕이라고 할 수 있다.\n자유롭게 내가 하고 싶은 포맷을 바꿀수 있어 편리하다.\n\n계획을 보기 편하고 잘 짜기 위해 여러 앱을 사용해보았다.  \n계획을 짜면서 느낀점은 하루에 내가 할 수 있는 양을 정확히 알고 그선 안에서 해야 한다는 것이다.  \n\n## 개발 \n\n### 매일 알고리즘 문제 풀기\n알고리즘 자체를 하기 위한 것이 아니라 논리력, 문제해결 능력을 키우기 위해 시작하였다.  \n하지만 시간이 많이 소요되고 전략없이 무작정 풀려고만해서 그런지 재미도 없고 금방 지쳐서 꾸준히 못했다.\n약한 분야이다 보니 기반지식, 의식적 수련이 많이 필요한것을 느꼈다. \n\n중요한 능력인 만큼 내년에는 반드시 매일 실천 할 것이며 해당 습관을 만들기 위해 Github에 실천 [repo](https://goo.gl/VdhQoz)를 생성하였다. \n내년에는 반드시 코딩 문제를 풀면서 사고력과 논리력을 키워 기본기가 탄탄한 프로그래머가 되자\n\n### 패스트캠퍼스 컴퓨터 공학 인강\nOS에 대한 개념은 확실히 많이 알게 되었다.  \n내년에는 컴퓨터 구조, 리눅스, C/C++, Phython 까지 모두 완강하고 정리까지 마쳐야 겠다.\n\n### TIL\n하루를 정말 쌓아가는 느낌을 들게 해주는 역활이었던거 같다.  \n비록 2달째 정도 거의 빠지지 않고 잘 유지하고 있는데 내년에도 계속 이어나가 내가 알게 된 지식을 잘 정리하고 장기기억으로 이어질수 있도록 하자\n\n\n\n### 토이프로젝트 \n- 일단 제대로 완성 시킨것은 없다..\n- 개발범위를 너무 넓게 잡고 개발기간도 너무 오래 잡아 타이트 하지 않아 집중려고 떨어 졌다.\n- 내년에는 2주짜리, 3개월짜리 개발기간을 딱 정하고 평소 해보고 싶었던 기술을 써보아서 나의 개발 무기를 추가해보자\n\n\n# 반성\n\n## 하루에 할 수 있는 것만!\n하고싶은것은 많아 무리하게 계획하여 하루에 다 못이루는 경우가 많았다...  \n욕심이 많아 얼른 머릿속에 지식을 넣고 싶지만 지식을 내것으로 만드는 과정은 그렇게 빨리 이루어지지 않는다느것 이해와 반복이 계속 수반되어야 체화 되는 것을 다시 한번 알게 되었다.  \n내가 하루에 얼마나 투자 할 수 있을지 시간을 계산해보고 그 범위내에서 계획하고 꾸준히 이루어 나가자\n\n\n# 2018년 마무리\n참 많이 시도도 해보고 성장도 많이 한 한해인거 같다.  \n책도 많이 읽었고 계획한것을 잘 실천하기 위해 메모앱을 활용하면서 시도도 많이 해보고 지금은 시행착오에 대한 결과로 나만의 실천 프레임워크가 잘 정착된거 같다.  \n육아 하면서 짬짬히 시간내기가 정말 힘들었지만 그것또한 이제 익숙해져서 시간도 잘 활용하고 있다.  \n내년 2019년도에는 지금보다 훨씬 더 큰 폭으로 성장 할 것이라는 확신이 든다.  \n이제 나의 실천 프레임워크 기반 위에서 해야 할 플랜을 잘 실천하자 내년에는 참 많이 달라진 내모습을 기대하면서 기록은 마무리 하겠다.\n\n\n# 내년에는?\n- 프로그래머 필수 역량 논리력, 문제해결능력 이 본질적인 능력을 키우는 것을 최우선으로 한다.\n- 영어 듣고, 말하고, 쓰고, 읽고가 되는 실력을 만들자, 영어 레퍼런스 문서, 책, 유트브영상 보는데 부담이 없을 정도로 만든다.\n- 웹에서 류윤광이라는 개발자를 알리고 개발자들 사이에 편리한 서비스 및 아이디어를 구상하여 개발자들에게 편리함을 줘보자 \n- 구상한 토이프로젝트는 반드시 기간 맞춰서 완성도 있게 완성 시킨다.\n\n\n# 내년에는?\n\n## 쳬계적인 시간 관리\n\n### 평일 투자 가용 시간\n- 출/퇴근 시간(100분)\n- 점심 시간(50분)\n- 자기전 까지(3시간)\n\n**약 5시간 30분이다.**\n\n### 시간간분배\n- 출/퇴근: 독서/개발자 블로그 보기\n- 점심: 코딩문제\n- 집 22:00 ~ 23:00: TIL \n- 집 23:00 ~ 23:30: 영어\n- 집 23:30 ~ 01:30: 개인개발공부\n\n#### 출/퇴근 독서/개발자 블로그 보기\n독서 할 떄 이제는 양보단 질이다. 빨리 읽고 다른거 읽자 이런 마인드보다 한구절이라도 나를 울려 나의 행동과 생각을 깨뜨릴수 있도록 소중히 읽도록하자 \n\n- 그날 읽은 내용 그날 독서노트 정리\n- 정리 시간은 TIL 시간에 할애 하자\n\n#### 점심 코딩문제\n반드시 습관을 만들어야 한다. \n\n- 문제 해결 전략을 만들어보자\n- 30분 투자해도 안되면 다른 사람의 답과 비교해 보자\n- 뭐가 문제인지 정확히 파악하고 해당 내용을 Github에 실천 [repo](https://goo.gl/VdhQoz)에 적자\n- 다시 첨부터 풀어보자\n\n#### 집 22:00 ~ 23:00: TIL \n\n- 반드시 1시간만 투자한다. 다른거 할 꺼 많음 이거에 너무 많은 시간투자 하지는 말자\n- 너무 내용이 많으면 큰 덩이리들로만 한번 다 적고 나머지 디테일은 주말찬스를 쓰도록 하자\n\n#### 집 23:00 ~ 23:30: 영어\n\n- 2019년 가장 중요한 목표중에 하나\n- 발음,강세,리듬을 신경쓰면서 영어와 친해지자\n- 한문장이라도 제대로 파악하고 입에 연습한다.\n\n\n#### 집 23:30 ~ 01:30: 개인개발공부\n\n- 이왕이면 업무 할 때 할 수 없는 기술들을 사용해 보는 시간을 가지자\n- 주로 토이프로젝트 할 때 시간을 할애 하자\n\n\n## 토이프로젝트\n만들고 싶은 주제를 선정하여 짧으면 1달 길면 3개월 정도 걸리는 범위를 정하고 플젝을 만들자.  \n질질 끌게 되면 지치고 성취감도 느낄수 없게된다.  \n일단 목표치까지 만들고 살을 붙이 도록 하자\n\n\n## 프로그래밍 기본, 본질에 충실하기\n토이보다 중요한건 프로그래밍 기본과 본질적 능력을 의식적인 노력을 키우는 것이다.\n\n- 컴퓨터 구조, OS, 전산 관련 필수 지식을 확실히 내것을 만들기\n- 클린코드, TDD, 리펙토링, 디자인패턴, OOP 특정 라이브러리 프레임워크 의존없이 개발에 기본기를 탄탄히 하여야 한다.\n\n## 영문 레퍼런스 문서 술술~~\n답은 거의 레퍼런스 문서에 다있다. 읽을줄 알면 신세계다. 반드시 독해능력을 향상 시키자\n\n## 영어 컨텐츠 영상 쏙쏙~~\n국내 컨텐츠는 빙산의 일각이다. 귀가 뚫리면 더많이 알 수 있다.","source":"_posts/회고/2018년 회고.md","raw":"---\ntitle: 2018년 회고 - 시행착오\ncatalog: true\nsubtitle:\nheader-img: \"bg_computer.jpg\"\ntags: \n- 회고\n---\n\n# Overview\n시행착오가 참 많았던 2018년 이었다.  \n다른 개발자 블로그를 많이 보면서 회고에 필요성을 느껴 처음 2018년도 회고를 작성해 본다.\n\n# 목차\n- **2018년 나의 키워드**\n    + 습관\n    + 멀티 스레드\n    + 본질, 프로그래머 본질적 능력, 역량\n\n- **습관 만들기**\n    + 독서\n    + 나의 계획 실천 프레임워크\n\n- **개발 자취**\n    + 매일 알고리즘 문제 풀기\n    + 패스트캠퍼스 컴퓨터 공학 인강\n    + TIL\n    + 토이프로젝트\n\n- **반성**\n    + 하루에 할 수 있는 것만!\n\n- **2018년 마무리**\n- **2019년에는?**\n\n## 2018년 나의 키워드\n\n### 습관\n독서를 통해 습관에 중요성을 깨닳았고 습관을 기르기 위해 나름 노력을 많이 했다. 노력한 결과 올해 내가 만든 습관은 아래와 같다.  \n\n- 독서\n- TIL\n- 계획\n\n내가 깨닳기도 전에 어느순간 위 행동을 하는데 힘이 전혀 들지 않았다. 해야 되기 때문에 해야 했고 그것은 확실한 동기가 부여된 상태면 실천하는 힘이 나한테 나온다는 것을 깨닳았다.\n\n### 멀티 스레드\n올해는 주로 Java단에서 멀티 스레드 환경에서 코딩을 많이 하게 되었고 관련 내용에 무한한 호기심과 관심으로 스스로 공부도 많이 하게 되었다.  버거운 일을 나누어서 처리하여 다시 취합하여 결과를 얻어내는 것이 참 매력적으로 다가왔다. \n\n### 본질\n개발자 실력은 본질적 능력을 키워야 한다는 것에 격한 공감을 가지게 되어 프로그래머로 본질적 능력을 어떻게 키워야 하는지에 관심을 많이 갖고 키우려 노력하였다.  \n\n- 문제해결 능력\n- 논리력\n- 새로운 개념 습득/적용 능력\n\n이것이 내가 생각하는 프로그래머가 가져야 하는 역략이자 본질적 능력이라 생각한다. 올해는 본질적 능력이 무엇인지에 대한 답만 알게 되었고 실질적 실천은 내년에는 **의도적 수련**을 통해 능력을 향상 시키자\n\n이러한 생각을 정립하게 된 것은 많은 선배 개발자님들에 지식 공유가 없었다면 영감도 얻지 못했을 것이다. 공유해주셔서 감사 드리며 영감을 얻은 경로는 아래와 같다.  \n\n- [개발자의 평생공부 | 임백준](https://goo.gl/26K1HE)\n- [개발자의 생명은 커뮤니케이션 능력 | 임백준](https://goo.gl/az65WJ)\n- [개발자처럼 생각하는 방법 - 문제 해결의 교훈 | 오역 유발자 의 IT 블로그 번역(번역자), Richard Reis(저자)](https://goo.gl/dFzW2M)\n- [오픈소스 개발자 이야기 20170701_오픈소스 개발자의 공부방법 | 강대명](https://goo.gl/LpeFdB)\n\n이 밖에 많은 개발자분들이 올려주신 글을 읽고 영향을 받아 어떤 능력이 필요하고 체화시켜야 하는지 알게 되어 내년에는 더 확실하게 묙표를 세울 수 있게 되었다.\n\n\n## 습관 만들기\n\n\n### 독서\n올해 가장 잘한 일 중에 하나가 독서하는 습관을 만들었다는 것이다.\n왜냐하면 다양한 분야에 책을 읽는 과정에서 공감, 까닳음, 반성, 동기부여, 삶의 계획 등 많은 것을 느끼게 해주었고 그것들은 내가 인생을 어떻게 살아야 겠다라는\n가이드? 역활을 해주어서 삶을 계획하고 주체적으로 살아 갈 수 있게 해주었기 때문이다.\n\n집근처 도서관이 있는것을 보고 한번 가볼까? 하고 아내랑 도서관을 들어가봤다.\n충격이었다. 남녀노소 공부하는 열기가 장난 아니었기 때문이었다. 더불어 수많은 책들의 제목만 봐도 그동안 내가 궁금해었던 주제들 보고 싶었던 책이 많다는것과 \n더 놀라운것은 내가 정말 지적 호기심이 많은 사람이었다는것을 깨닳은 것이었다. \n\n그 날부터 평균 1주에 1권씩 책을 읽어 나갔고 주로 프로그래밍 관련 된 책이었지만 그 외 인문, 과학, 자기개발 책들도 읽었다.\n\n#### 1년 70권 \n1년 100권이 목표였지만 올해는 70권을 읽었다기 보다 70권 정도 대출한것이다. 책을 볼때 0부터 100까지 끝까지 읽을때도 있고 아닐때도 있기 때문에 70권을 다 읽은 것은 아니다.\n하지만 30년 살면서 올해가 가장 많이 책을 읽었고 그만큼 독서의 중요성을 알게된 중요한 해이기도 했다.\n\n#### 하지만 독서 노트는....\n독서를 하고나서 얻은 지식을 써먹거나 실천하기 위해서는 메모를 하던가 장기기억으로 만들어야 한다.\n독서 노트를 통해 내가 그당시 얻은 영감, 생각, 느낀점, 앞으로 계획 등을 적음으로써 내용을 반복하고 실천하고 장기기억으로 이루어져 생각이 바뀌고 실천 할 수 있다.\n\n하지만 책을 많이 읽은 만큼 적은 독서노트는 5개정도 밖에 되지 않는다.. 얻은 지식을 체화시키지 않으면 밑빠지 독에 물붓기 밖에 되지 않으니 내년에는 독서 노트 반드시 적도록 하자\n\n#### 프로그래밍 책\n관련 내용이 없는 책이 없을 정도로 다양한 주제로 된 책들이 엄청나게 많이 나와있다. 욕심이 많아 다 읽고 싶어 닥치는데로 빌려보고 사고 하였지만 결국 전략이 필요헀다.\n\n**머릿속에 남는게 없다.**\n책을 다 읽었다고 내 지식이 되지 않는다.. 그냥 책을 1권 읽었다 성취감만 느기고 싶어 책만! 읽는것이다. 내것으로 만드는 전략없이 즉, 의도적인 행위 없이 글만 본것은 도로아미타불이다..\n\n**그럼 전략은?**\n- 읽는 목적을 분명히 한다.\n    + 특정 주제를 보고 싶은가? 그러면 목차보고 관심있는 주제부터 보자 그래야 집중력과 머릿속에 잘 기억에 남는다.\n    + 0부터 100까지 봐야 하는가? 그러면 목차를 쭉 스캔하고나서 읽되 특정 구절에 나의 생각을 적으면서 그날 읽은 것을 독서노트에 적고 반드시 내용을 공유하자\n    그리고 반복과 실천 뿐이다.\n    + 책을 더럽게 보자\n\n### 나의 계획 실천 프레임워크\n독서를 하면서 내가 이루고 싶은 것들을 이루기 위해서 체계적인 계획이 있어야 동기부여도 되면서 내가 무엇을 해야 하는지 딱 정해놔야 내가 실천 잘 할 수 있다는 것을 깨닳게 되어 고민해서 만든 나의 실천 프레임워크를 만들어 보았다. \n\n#### Evernote\n{% asset_img \"evernote.png\" %}  \n\n제일 먼저 사용했던 앱으로 계획에 대한 진행 상황을 한눈에 볼 수 없다는 단점이 있어서 Notion 갈아타게 되었다.\n\n#### Notion\n메모앱 끝판왕이라고 할 수 있다.\n자유롭게 내가 하고 싶은 포맷을 바꿀수 있어 편리하다.\n\n계획을 보기 편하고 잘 짜기 위해 여러 앱을 사용해보았다.  \n계획을 짜면서 느낀점은 하루에 내가 할 수 있는 양을 정확히 알고 그선 안에서 해야 한다는 것이다.  \n\n## 개발 \n\n### 매일 알고리즘 문제 풀기\n알고리즘 자체를 하기 위한 것이 아니라 논리력, 문제해결 능력을 키우기 위해 시작하였다.  \n하지만 시간이 많이 소요되고 전략없이 무작정 풀려고만해서 그런지 재미도 없고 금방 지쳐서 꾸준히 못했다.\n약한 분야이다 보니 기반지식, 의식적 수련이 많이 필요한것을 느꼈다. \n\n중요한 능력인 만큼 내년에는 반드시 매일 실천 할 것이며 해당 습관을 만들기 위해 Github에 실천 [repo](https://goo.gl/VdhQoz)를 생성하였다. \n내년에는 반드시 코딩 문제를 풀면서 사고력과 논리력을 키워 기본기가 탄탄한 프로그래머가 되자\n\n### 패스트캠퍼스 컴퓨터 공학 인강\nOS에 대한 개념은 확실히 많이 알게 되었다.  \n내년에는 컴퓨터 구조, 리눅스, C/C++, Phython 까지 모두 완강하고 정리까지 마쳐야 겠다.\n\n### TIL\n하루를 정말 쌓아가는 느낌을 들게 해주는 역활이었던거 같다.  \n비록 2달째 정도 거의 빠지지 않고 잘 유지하고 있는데 내년에도 계속 이어나가 내가 알게 된 지식을 잘 정리하고 장기기억으로 이어질수 있도록 하자\n\n\n\n### 토이프로젝트 \n- 일단 제대로 완성 시킨것은 없다..\n- 개발범위를 너무 넓게 잡고 개발기간도 너무 오래 잡아 타이트 하지 않아 집중려고 떨어 졌다.\n- 내년에는 2주짜리, 3개월짜리 개발기간을 딱 정하고 평소 해보고 싶었던 기술을 써보아서 나의 개발 무기를 추가해보자\n\n\n# 반성\n\n## 하루에 할 수 있는 것만!\n하고싶은것은 많아 무리하게 계획하여 하루에 다 못이루는 경우가 많았다...  \n욕심이 많아 얼른 머릿속에 지식을 넣고 싶지만 지식을 내것으로 만드는 과정은 그렇게 빨리 이루어지지 않는다느것 이해와 반복이 계속 수반되어야 체화 되는 것을 다시 한번 알게 되었다.  \n내가 하루에 얼마나 투자 할 수 있을지 시간을 계산해보고 그 범위내에서 계획하고 꾸준히 이루어 나가자\n\n\n# 2018년 마무리\n참 많이 시도도 해보고 성장도 많이 한 한해인거 같다.  \n책도 많이 읽었고 계획한것을 잘 실천하기 위해 메모앱을 활용하면서 시도도 많이 해보고 지금은 시행착오에 대한 결과로 나만의 실천 프레임워크가 잘 정착된거 같다.  \n육아 하면서 짬짬히 시간내기가 정말 힘들었지만 그것또한 이제 익숙해져서 시간도 잘 활용하고 있다.  \n내년 2019년도에는 지금보다 훨씬 더 큰 폭으로 성장 할 것이라는 확신이 든다.  \n이제 나의 실천 프레임워크 기반 위에서 해야 할 플랜을 잘 실천하자 내년에는 참 많이 달라진 내모습을 기대하면서 기록은 마무리 하겠다.\n\n\n# 내년에는?\n- 프로그래머 필수 역량 논리력, 문제해결능력 이 본질적인 능력을 키우는 것을 최우선으로 한다.\n- 영어 듣고, 말하고, 쓰고, 읽고가 되는 실력을 만들자, 영어 레퍼런스 문서, 책, 유트브영상 보는데 부담이 없을 정도로 만든다.\n- 웹에서 류윤광이라는 개발자를 알리고 개발자들 사이에 편리한 서비스 및 아이디어를 구상하여 개발자들에게 편리함을 줘보자 \n- 구상한 토이프로젝트는 반드시 기간 맞춰서 완성도 있게 완성 시킨다.\n\n\n# 내년에는?\n\n## 쳬계적인 시간 관리\n\n### 평일 투자 가용 시간\n- 출/퇴근 시간(100분)\n- 점심 시간(50분)\n- 자기전 까지(3시간)\n\n**약 5시간 30분이다.**\n\n### 시간간분배\n- 출/퇴근: 독서/개발자 블로그 보기\n- 점심: 코딩문제\n- 집 22:00 ~ 23:00: TIL \n- 집 23:00 ~ 23:30: 영어\n- 집 23:30 ~ 01:30: 개인개발공부\n\n#### 출/퇴근 독서/개발자 블로그 보기\n독서 할 떄 이제는 양보단 질이다. 빨리 읽고 다른거 읽자 이런 마인드보다 한구절이라도 나를 울려 나의 행동과 생각을 깨뜨릴수 있도록 소중히 읽도록하자 \n\n- 그날 읽은 내용 그날 독서노트 정리\n- 정리 시간은 TIL 시간에 할애 하자\n\n#### 점심 코딩문제\n반드시 습관을 만들어야 한다. \n\n- 문제 해결 전략을 만들어보자\n- 30분 투자해도 안되면 다른 사람의 답과 비교해 보자\n- 뭐가 문제인지 정확히 파악하고 해당 내용을 Github에 실천 [repo](https://goo.gl/VdhQoz)에 적자\n- 다시 첨부터 풀어보자\n\n#### 집 22:00 ~ 23:00: TIL \n\n- 반드시 1시간만 투자한다. 다른거 할 꺼 많음 이거에 너무 많은 시간투자 하지는 말자\n- 너무 내용이 많으면 큰 덩이리들로만 한번 다 적고 나머지 디테일은 주말찬스를 쓰도록 하자\n\n#### 집 23:00 ~ 23:30: 영어\n\n- 2019년 가장 중요한 목표중에 하나\n- 발음,강세,리듬을 신경쓰면서 영어와 친해지자\n- 한문장이라도 제대로 파악하고 입에 연습한다.\n\n\n#### 집 23:30 ~ 01:30: 개인개발공부\n\n- 이왕이면 업무 할 때 할 수 없는 기술들을 사용해 보는 시간을 가지자\n- 주로 토이프로젝트 할 때 시간을 할애 하자\n\n\n## 토이프로젝트\n만들고 싶은 주제를 선정하여 짧으면 1달 길면 3개월 정도 걸리는 범위를 정하고 플젝을 만들자.  \n질질 끌게 되면 지치고 성취감도 느낄수 없게된다.  \n일단 목표치까지 만들고 살을 붙이 도록 하자\n\n\n## 프로그래밍 기본, 본질에 충실하기\n토이보다 중요한건 프로그래밍 기본과 본질적 능력을 의식적인 노력을 키우는 것이다.\n\n- 컴퓨터 구조, OS, 전산 관련 필수 지식을 확실히 내것을 만들기\n- 클린코드, TDD, 리펙토링, 디자인패턴, OOP 특정 라이브러리 프레임워크 의존없이 개발에 기본기를 탄탄히 하여야 한다.\n\n## 영문 레퍼런스 문서 술술~~\n답은 거의 레퍼런스 문서에 다있다. 읽을줄 알면 신세계다. 반드시 독해능력을 향상 시키자\n\n## 영어 컨텐츠 영상 쏙쏙~~\n국내 컨텐츠는 빙산의 일각이다. 귀가 뚫리면 더많이 알 수 있다.","slug":"회고/2018년 회고","published":1,"date":"2019-01-13T03:37:38.320Z","updated":"2019-07-10T14:39:48.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids1t002kk0ot7s55euai","content":"<h1><span id=\"overview\">Overview</span></h1>\n<p>시행착오가 참 많았던 2018년 이었다.<br>\n다른 개발자 블로그를 많이 보면서 회고에 필요성을 느껴 처음 2018년도 회고를 작성해 본다.</p>\n<h1><span id=\"목차\">목차</span></h1>\n<ul>\n<li>\n<p><strong>2018년 나의 키워드</strong></p>\n<ul>\n<li>습관</li>\n<li>멀티 스레드</li>\n<li>본질, 프로그래머 본질적 능력, 역량</li>\n</ul>\n</li>\n<li>\n<p><strong>습관 만들기</strong></p>\n<ul>\n<li>독서</li>\n<li>나의 계획 실천 프레임워크</li>\n</ul>\n</li>\n<li>\n<p><strong>개발 자취</strong></p>\n<ul>\n<li>매일 알고리즘 문제 풀기</li>\n<li>패스트캠퍼스 컴퓨터 공학 인강</li>\n<li>TIL</li>\n<li>토이프로젝트</li>\n</ul>\n</li>\n<li>\n<p><strong>반성</strong></p>\n<ul>\n<li>하루에 할 수 있는 것만!</li>\n</ul>\n</li>\n<li>\n<p><strong>2018년 마무리</strong></p>\n</li>\n<li>\n<p><strong>2019년에는?</strong></p>\n</li>\n</ul>\n<h2><span id=\"2018년-나의-키워드\">2018년 나의 키워드</span></h2>\n<h3><span id=\"습관\">습관</span></h3>\n<p>독서를 통해 습관에 중요성을 깨닳았고 습관을 기르기 위해 나름 노력을 많이 했다. 노력한 결과 올해 내가 만든 습관은 아래와 같다.</p>\n<ul>\n<li>독서</li>\n<li>TIL</li>\n<li>계획</li>\n</ul>\n<p>내가 깨닳기도 전에 어느순간 위 행동을 하는데 힘이 전혀 들지 않았다. 해야 되기 때문에 해야 했고 그것은 확실한 동기가 부여된 상태면 실천하는 힘이 나한테 나온다는 것을 깨닳았다.</p>\n<h3><span id=\"멀티-스레드\">멀티 스레드</span></h3>\n<p>올해는 주로 Java단에서 멀티 스레드 환경에서 코딩을 많이 하게 되었고 관련 내용에 무한한 호기심과 관심으로 스스로 공부도 많이 하게 되었다.  버거운 일을 나누어서 처리하여 다시 취합하여 결과를 얻어내는 것이 참 매력적으로 다가왔다.</p>\n<h3><span id=\"본질\">본질</span></h3>\n<p>개발자 실력은 본질적 능력을 키워야 한다는 것에 격한 공감을 가지게 되어 프로그래머로 본질적 능력을 어떻게 키워야 하는지에 관심을 많이 갖고 키우려 노력하였다.</p>\n<ul>\n<li>문제해결 능력</li>\n<li>논리력</li>\n<li>새로운 개념 습득/적용 능력</li>\n</ul>\n<p>이것이 내가 생각하는 프로그래머가 가져야 하는 역략이자 본질적 능력이라 생각한다. 올해는 본질적 능력이 무엇인지에 대한 답만 알게 되었고 실질적 실천은 내년에는 <strong>의도적 수련</strong>을 통해 능력을 향상 시키자</p>\n<p>이러한 생각을 정립하게 된 것은 많은 선배 개발자님들에 지식 공유가 없었다면 영감도 얻지 못했을 것이다. 공유해주셔서 감사 드리며 영감을 얻은 경로는 아래와 같다.</p>\n<ul>\n<li><a href=\"https://goo.gl/26K1HE\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">개발자의 평생공부 | 임백준</a></li>\n<li><a href=\"https://goo.gl/az65WJ\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">개발자의 생명은 커뮤니케이션 능력 | 임백준</a></li>\n<li><a href=\"https://goo.gl/dFzW2M\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">개발자처럼 생각하는 방법 - 문제 해결의 교훈 | 오역 유발자 의 IT 블로그 번역(번역자), Richard Reis(저자)</a></li>\n<li><a href=\"https://goo.gl/LpeFdB\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">오픈소스 개발자 이야기 20170701_오픈소스 개발자의 공부방법 | 강대명</a></li>\n</ul>\n<p>이 밖에 많은 개발자분들이 올려주신 글을 읽고 영향을 받아 어떤 능력이 필요하고 체화시켜야 하는지 알게 되어 내년에는 더 확실하게 묙표를 세울 수 있게 되었다.</p>\n<h2><span id=\"습관-만들기\">습관 만들기</span></h2>\n<h3><span id=\"독서\">독서</span></h3>\n<p>올해 가장 잘한 일 중에 하나가 독서하는 습관을 만들었다는 것이다.<br>\n왜냐하면 다양한 분야에 책을 읽는 과정에서 공감, 까닳음, 반성, 동기부여, 삶의 계획 등 많은 것을 느끼게 해주었고 그것들은 내가 인생을 어떻게 살아야 겠다라는<br>\n가이드? 역활을 해주어서 삶을 계획하고 주체적으로 살아 갈 수 있게 해주었기 때문이다.</p>\n<p>집근처 도서관이 있는것을 보고 한번 가볼까? 하고 아내랑 도서관을 들어가봤다.<br>\n충격이었다. 남녀노소 공부하는 열기가 장난 아니었기 때문이었다. 더불어 수많은 책들의 제목만 봐도 그동안 내가 궁금해었던 주제들 보고 싶었던 책이 많다는것과<br>\n더 놀라운것은 내가 정말 지적 호기심이 많은 사람이었다는것을 깨닳은 것이었다.</p>\n<p>그 날부터 평균 1주에 1권씩 책을 읽어 나갔고 주로 프로그래밍 관련 된 책이었지만 그 외 인문, 과학, 자기개발 책들도 읽었다.</p>\n<h4><span id=\"1년-70권\">1년 70권</span></h4>\n<p>1년 100권이 목표였지만 올해는 70권을 읽었다기 보다 70권 정도 대출한것이다. 책을 볼때 0부터 100까지 끝까지 읽을때도 있고 아닐때도 있기 때문에 70권을 다 읽은 것은 아니다.<br>\n하지만 30년 살면서 올해가 가장 많이 책을 읽었고 그만큼 독서의 중요성을 알게된 중요한 해이기도 했다.</p>\n<h4><span id=\"하지만-독서-노트는\">하지만 독서 노트는…</span></h4>\n<p>독서를 하고나서 얻은 지식을 써먹거나 실천하기 위해서는 메모를 하던가 장기기억으로 만들어야 한다.<br>\n독서 노트를 통해 내가 그당시 얻은 영감, 생각, 느낀점, 앞으로 계획 등을 적음으로써 내용을 반복하고 실천하고 장기기억으로 이루어져 생각이 바뀌고 실천 할 수 있다.</p>\n<p>하지만 책을 많이 읽은 만큼 적은 독서노트는 5개정도 밖에 되지 않는다… 얻은 지식을 체화시키지 않으면 밑빠지 독에 물붓기 밖에 되지 않으니 내년에는 독서 노트 반드시 적도록 하자</p>\n<h4><span id=\"프로그래밍-책\">프로그래밍 책</span></h4>\n<p>관련 내용이 없는 책이 없을 정도로 다양한 주제로 된 책들이 엄청나게 많이 나와있다. 욕심이 많아 다 읽고 싶어 닥치는데로 빌려보고 사고 하였지만 결국 전략이 필요헀다.</p>\n<p><strong>머릿속에 남는게 없다.</strong><br>\n책을 다 읽었다고 내 지식이 되지 않는다… 그냥 책을 1권 읽었다 성취감만 느기고 싶어 책만! 읽는것이다. 내것으로 만드는 전략없이 즉, 의도적인 행위 없이 글만 본것은 도로아미타불이다…</p>\n<p><strong>그럼 전략은?</strong></p>\n<ul>\n<li>읽는 목적을 분명히 한다.\n<ul>\n<li>특정 주제를 보고 싶은가? 그러면 목차보고 관심있는 주제부터 보자 그래야 집중력과 머릿속에 잘 기억에 남는다.</li>\n<li>0부터 100까지 봐야 하는가? 그러면 목차를 쭉 스캔하고나서 읽되 특정 구절에 나의 생각을 적으면서 그날 읽은 것을 독서노트에 적고 반드시 내용을 공유하자<br>\n그리고 반복과 실천 뿐이다.</li>\n<li>책을 더럽게 보자</li>\n</ul>\n</li>\n</ul>\n<h3><span id=\"나의-계획-실천-프레임워크\">나의 계획 실천 프레임워크</span></h3>\n<p>독서를 하면서 내가 이루고 싶은 것들을 이루기 위해서 체계적인 계획이 있어야 동기부여도 되면서 내가 무엇을 해야 하는지 딱 정해놔야 내가 실천 잘 할 수 있다는 것을 깨닳게 되어 고민해서 만든 나의 실천 프레임워크를 만들어 보았다.</p>\n<h4><span id=\"evernote\">Evernote</span></h4>\n<img src=\"/2019/01/13/회고/2018년%20회고/evernote.png\">  \n<p>제일 먼저 사용했던 앱으로 계획에 대한 진행 상황을 한눈에 볼 수 없다는 단점이 있어서 Notion 갈아타게 되었다.</p>\n<h4><span id=\"notion\">Notion</span></h4>\n<p>메모앱 끝판왕이라고 할 수 있다.<br>\n자유롭게 내가 하고 싶은 포맷을 바꿀수 있어 편리하다.</p>\n<p>계획을 보기 편하고 잘 짜기 위해 여러 앱을 사용해보았다.<br>\n계획을 짜면서 느낀점은 하루에 내가 할 수 있는 양을 정확히 알고 그선 안에서 해야 한다는 것이다.</p>\n<h2><span id=\"개발\">개발</span></h2>\n<h3><span id=\"매일-알고리즘-문제-풀기\">매일 알고리즘 문제 풀기</span></h3>\n<p>알고리즘 자체를 하기 위한 것이 아니라 논리력, 문제해결 능력을 키우기 위해 시작하였다.<br>\n하지만 시간이 많이 소요되고 전략없이 무작정 풀려고만해서 그런지 재미도 없고 금방 지쳐서 꾸준히 못했다.<br>\n약한 분야이다 보니 기반지식, 의식적 수련이 많이 필요한것을 느꼈다.</p>\n<p>중요한 능력인 만큼 내년에는 반드시 매일 실천 할 것이며 해당 습관을 만들기 위해 Github에 실천 <a href=\"https://goo.gl/VdhQoz\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">repo</a>를 생성하였다.<br>\n내년에는 반드시 코딩 문제를 풀면서 사고력과 논리력을 키워 기본기가 탄탄한 프로그래머가 되자</p>\n<h3><span id=\"패스트캠퍼스-컴퓨터-공학-인강\">패스트캠퍼스 컴퓨터 공학 인강</span></h3>\n<p>OS에 대한 개념은 확실히 많이 알게 되었다.<br>\n내년에는 컴퓨터 구조, 리눅스, C/C++, Phython 까지 모두 완강하고 정리까지 마쳐야 겠다.</p>\n<h3><span id=\"til\">TIL</span></h3>\n<p>하루를 정말 쌓아가는 느낌을 들게 해주는 역활이었던거 같다.<br>\n비록 2달째 정도 거의 빠지지 않고 잘 유지하고 있는데 내년에도 계속 이어나가 내가 알게 된 지식을 잘 정리하고 장기기억으로 이어질수 있도록 하자</p>\n<h3><span id=\"토이프로젝트\">토이프로젝트</span></h3>\n<ul>\n<li>일단 제대로 완성 시킨것은 없다…</li>\n<li>개발범위를 너무 넓게 잡고 개발기간도 너무 오래 잡아 타이트 하지 않아 집중려고 떨어 졌다.</li>\n<li>내년에는 2주짜리, 3개월짜리 개발기간을 딱 정하고 평소 해보고 싶었던 기술을 써보아서 나의 개발 무기를 추가해보자</li>\n</ul>\n<h1><span id=\"반성\">반성</span></h1>\n<h2><span id=\"하루에-할-수-있는-것만\">하루에 할 수 있는 것만!</span></h2>\n<p>하고싶은것은 많아 무리하게 계획하여 하루에 다 못이루는 경우가 많았다…<br>\n욕심이 많아 얼른 머릿속에 지식을 넣고 싶지만 지식을 내것으로 만드는 과정은 그렇게 빨리 이루어지지 않는다느것 이해와 반복이 계속 수반되어야 체화 되는 것을 다시 한번 알게 되었다.<br>\n내가 하루에 얼마나 투자 할 수 있을지 시간을 계산해보고 그 범위내에서 계획하고 꾸준히 이루어 나가자</p>\n<h1><span id=\"2018년-마무리\">2018년 마무리</span></h1>\n<p>참 많이 시도도 해보고 성장도 많이 한 한해인거 같다.<br>\n책도 많이 읽었고 계획한것을 잘 실천하기 위해 메모앱을 활용하면서 시도도 많이 해보고 지금은 시행착오에 대한 결과로 나만의 실천 프레임워크가 잘 정착된거 같다.<br>\n육아 하면서 짬짬히 시간내기가 정말 힘들었지만 그것또한 이제 익숙해져서 시간도 잘 활용하고 있다.<br>\n내년 2019년도에는 지금보다 훨씬 더 큰 폭으로 성장 할 것이라는 확신이 든다.<br>\n이제 나의 실천 프레임워크 기반 위에서 해야 할 플랜을 잘 실천하자 내년에는 참 많이 달라진 내모습을 기대하면서 기록은 마무리 하겠다.</p>\n<h1><span id=\"내년에는\">내년에는?</span></h1>\n<ul>\n<li>프로그래머 필수 역량 논리력, 문제해결능력 이 본질적인 능력을 키우는 것을 최우선으로 한다.</li>\n<li>영어 듣고, 말하고, 쓰고, 읽고가 되는 실력을 만들자, 영어 레퍼런스 문서, 책, 유트브영상 보는데 부담이 없을 정도로 만든다.</li>\n<li>웹에서 류윤광이라는 개발자를 알리고 개발자들 사이에 편리한 서비스 및 아이디어를 구상하여 개발자들에게 편리함을 줘보자</li>\n<li>구상한 토이프로젝트는 반드시 기간 맞춰서 완성도 있게 완성 시킨다.</li>\n</ul>\n<h1><span id=\"내년에는\">내년에는?</span></h1>\n<h2><span id=\"쳬계적인-시간-관리\">쳬계적인 시간 관리</span></h2>\n<h3><span id=\"평일-투자-가용-시간\">평일 투자 가용 시간</span></h3>\n<ul>\n<li>출/퇴근 시간(100분)</li>\n<li>점심 시간(50분)</li>\n<li>자기전 까지(3시간)</li>\n</ul>\n<p><strong>약 5시간 30분이다.</strong></p>\n<h3><span id=\"시간간분배\">시간간분배</span></h3>\n<ul>\n<li>출/퇴근: 독서/개발자 블로그 보기</li>\n<li>점심: 코딩문제</li>\n<li>집 22:00 ~ 23:00: TIL</li>\n<li>집 23:00 ~ 23:30: 영어</li>\n<li>집 23:30 ~ 01:30: 개인개발공부</li>\n</ul>\n<h4><span id=\"출퇴근-독서개발자-블로그-보기\">출/퇴근 독서/개발자 블로그 보기</span></h4>\n<p>독서 할 떄 이제는 양보단 질이다. 빨리 읽고 다른거 읽자 이런 마인드보다 한구절이라도 나를 울려 나의 행동과 생각을 깨뜨릴수 있도록 소중히 읽도록하자</p>\n<ul>\n<li>그날 읽은 내용 그날 독서노트 정리</li>\n<li>정리 시간은 TIL 시간에 할애 하자</li>\n</ul>\n<h4><span id=\"점심-코딩문제\">점심 코딩문제</span></h4>\n<p>반드시 습관을 만들어야 한다.</p>\n<ul>\n<li>문제 해결 전략을 만들어보자</li>\n<li>30분 투자해도 안되면 다른 사람의 답과 비교해 보자</li>\n<li>뭐가 문제인지 정확히 파악하고 해당 내용을 Github에 실천 <a href=\"https://goo.gl/VdhQoz\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">repo</a>에 적자</li>\n<li>다시 첨부터 풀어보자</li>\n</ul>\n<h4><span id=\"집-2200-~-2300-til\">집 22:00 ~ 23:00: TIL</span></h4>\n<ul>\n<li>반드시 1시간만 투자한다. 다른거 할 꺼 많음 이거에 너무 많은 시간투자 하지는 말자</li>\n<li>너무 내용이 많으면 큰 덩이리들로만 한번 다 적고 나머지 디테일은 주말찬스를 쓰도록 하자</li>\n</ul>\n<h4><span id=\"집-2300-~-2330-영어\">집 23:00 ~ 23:30: 영어</span></h4>\n<ul>\n<li>2019년 가장 중요한 목표중에 하나</li>\n<li>발음,강세,리듬을 신경쓰면서 영어와 친해지자</li>\n<li>한문장이라도 제대로 파악하고 입에 연습한다.</li>\n</ul>\n<h4><span id=\"집-2330-~-0130-개인개발공부\">집 23:30 ~ 01:30: 개인개발공부</span></h4>\n<ul>\n<li>이왕이면 업무 할 때 할 수 없는 기술들을 사용해 보는 시간을 가지자</li>\n<li>주로 토이프로젝트 할 때 시간을 할애 하자</li>\n</ul>\n<h2><span id=\"토이프로젝트\">토이프로젝트</span></h2>\n<p>만들고 싶은 주제를 선정하여 짧으면 1달 길면 3개월 정도 걸리는 범위를 정하고 플젝을 만들자.<br>\n질질 끌게 되면 지치고 성취감도 느낄수 없게된다.<br>\n일단 목표치까지 만들고 살을 붙이 도록 하자</p>\n<h2><span id=\"프로그래밍-기본-본질에-충실하기\">프로그래밍 기본, 본질에 충실하기</span></h2>\n<p>토이보다 중요한건 프로그래밍 기본과 본질적 능력을 의식적인 노력을 키우는 것이다.</p>\n<ul>\n<li>컴퓨터 구조, OS, 전산 관련 필수 지식을 확실히 내것을 만들기</li>\n<li>클린코드, TDD, 리펙토링, 디자인패턴, OOP 특정 라이브러리 프레임워크 의존없이 개발에 기본기를 탄탄히 하여야 한다.</li>\n</ul>\n<h2><span id=\"영문-레퍼런스-문서-술술~~\">영문 레퍼런스 문서 술술~~</span></h2>\n<p>답은 거의 레퍼런스 문서에 다있다. 읽을줄 알면 신세계다. 반드시 독해능력을 향상 시키자</p>\n<h2><span id=\"영어-컨텐츠-영상-쏙쏙~~\">영어 컨텐츠 영상 쏙쏙~~</span></h2>\n<p>국내 컨텐츠는 빙산의 일각이다. 귀가 뚫리면 더많이 알 수 있다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>Overview</h1>\n<p>시행착오가 참 많았던 2018년 이었다.<br>\n다른 개발자 블로그를 많이 보면서 회고에 필요성을 느껴 처음 2018년도 회고를 작성해 본다.</p>\n<h1>목차</h1>\n<ul>\n<li>\n<p><strong>2018년 나의 키워드</strong></p>\n<ul>\n<li>습관</li>\n<li>멀티 스레드</li>\n<li>본질, 프로그래머 본질적 능력, 역량</li>\n</ul>\n</li>\n<li>\n<p><strong>습관 만들기</strong></p>\n<ul>\n<li>독서</li>\n<li>나의 계획 실천 프레임워크</li>\n</ul>\n</li>\n<li>\n<p><strong>개발 자취</strong></p>\n<ul>\n<li>매일 알고리즘 문제 풀기</li>\n<li>패스트캠퍼스 컴퓨터 공학 인강</li>\n<li>TIL</li>\n<li>토이프로젝트</li>\n</ul>\n</li>\n<li>\n<p><strong>반성</strong></p>\n<ul>\n<li>하루에 할 수 있는 것만!</li>\n</ul>\n</li>\n<li>\n<p><strong>2018년 마무리</strong></p>\n</li>\n<li>\n<p><strong>2019년에는?</strong></p>\n</li>\n</ul>\n<h2>2018년 나의 키워드</h2>\n<h3>습관</h3>\n<p>독서를 통해 습관에 중요성을 깨닳았고 습관을 기르기 위해 나름 노력을 많이 했다. 노력한 결과 올해 내가 만든 습관은 아래와 같다.</p>\n<ul>\n<li>독서</li>\n<li>TIL</li>\n<li>계획</li>\n</ul>\n<p>내가 깨닳기도 전에 어느순간 위 행동을 하는데 힘이 전혀 들지 않았다. 해야 되기 때문에 해야 했고 그것은 확실한 동기가 부여된 상태면 실천하는 힘이 나한테 나온다는 것을 깨닳았다.</p>\n<h3>멀티 스레드</h3>\n<p>올해는 주로 Java단에서 멀티 스레드 환경에서 코딩을 많이 하게 되었고 관련 내용에 무한한 호기심과 관심으로 스스로 공부도 많이 하게 되었다.  버거운 일을 나누어서 처리하여 다시 취합하여 결과를 얻어내는 것이 참 매력적으로 다가왔다.</p>\n<h3>본질</h3>\n<p>개발자 실력은 본질적 능력을 키워야 한다는 것에 격한 공감을 가지게 되어 프로그래머로 본질적 능력을 어떻게 키워야 하는지에 관심을 많이 갖고 키우려 노력하였다.</p>\n<ul>\n<li>문제해결 능력</li>\n<li>논리력</li>\n<li>새로운 개념 습득/적용 능력</li>\n</ul>\n<p>이것이 내가 생각하는 프로그래머가 가져야 하는 역략이자 본질적 능력이라 생각한다. 올해는 본질적 능력이 무엇인지에 대한 답만 알게 되었고 실질적 실천은 내년에는 <strong>의도적 수련</strong>을 통해 능력을 향상 시키자</p>\n<p>이러한 생각을 정립하게 된 것은 많은 선배 개발자님들에 지식 공유가 없었다면 영감도 얻지 못했을 것이다. 공유해주셔서 감사 드리며 영감을 얻은 경로는 아래와 같다.</p>\n<ul>\n<li><a href=\"https://goo.gl/26K1HE\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">개발자의 평생공부 | 임백준</a></li>\n<li><a href=\"https://goo.gl/az65WJ\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">개발자의 생명은 커뮤니케이션 능력 | 임백준</a></li>\n<li><a href=\"https://goo.gl/dFzW2M\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">개발자처럼 생각하는 방법 - 문제 해결의 교훈 | 오역 유발자 의 IT 블로그 번역(번역자), Richard Reis(저자)</a></li>\n<li><a href=\"https://goo.gl/LpeFdB\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">오픈소스 개발자 이야기 20170701_오픈소스 개발자의 공부방법 | 강대명</a></li>\n</ul>\n<p>이 밖에 많은 개발자분들이 올려주신 글을 읽고 영향을 받아 어떤 능력이 필요하고 체화시켜야 하는지 알게 되어 내년에는 더 확실하게 묙표를 세울 수 있게 되었다.</p>\n<h2>습관 만들기</h2>\n<h3>독서</h3>\n<p>올해 가장 잘한 일 중에 하나가 독서하는 습관을 만들었다는 것이다.<br>\n왜냐하면 다양한 분야에 책을 읽는 과정에서 공감, 까닳음, 반성, 동기부여, 삶의 계획 등 많은 것을 느끼게 해주었고 그것들은 내가 인생을 어떻게 살아야 겠다라는<br>\n가이드? 역활을 해주어서 삶을 계획하고 주체적으로 살아 갈 수 있게 해주었기 때문이다.</p>\n<p>집근처 도서관이 있는것을 보고 한번 가볼까? 하고 아내랑 도서관을 들어가봤다.<br>\n충격이었다. 남녀노소 공부하는 열기가 장난 아니었기 때문이었다. 더불어 수많은 책들의 제목만 봐도 그동안 내가 궁금해었던 주제들 보고 싶었던 책이 많다는것과<br>\n더 놀라운것은 내가 정말 지적 호기심이 많은 사람이었다는것을 깨닳은 것이었다.</p>\n<p>그 날부터 평균 1주에 1권씩 책을 읽어 나갔고 주로 프로그래밍 관련 된 책이었지만 그 외 인문, 과학, 자기개발 책들도 읽었다.</p>\n<h4>1년 70권</h4>\n<p>1년 100권이 목표였지만 올해는 70권을 읽었다기 보다 70권 정도 대출한것이다. 책을 볼때 0부터 100까지 끝까지 읽을때도 있고 아닐때도 있기 때문에 70권을 다 읽은 것은 아니다.<br>\n하지만 30년 살면서 올해가 가장 많이 책을 읽었고 그만큼 독서의 중요성을 알게된 중요한 해이기도 했다.</p>\n<h4>하지만 독서 노트는…</h4>\n<p>독서를 하고나서 얻은 지식을 써먹거나 실천하기 위해서는 메모를 하던가 장기기억으로 만들어야 한다.<br>\n독서 노트를 통해 내가 그당시 얻은 영감, 생각, 느낀점, 앞으로 계획 등을 적음으로써 내용을 반복하고 실천하고 장기기억으로 이루어져 생각이 바뀌고 실천 할 수 있다.</p>\n<p>하지만 책을 많이 읽은 만큼 적은 독서노트는 5개정도 밖에 되지 않는다… 얻은 지식을 체화시키지 않으면 밑빠지 독에 물붓기 밖에 되지 않으니 내년에는 독서 노트 반드시 적도록 하자</p>\n<h4>프로그래밍 책</h4>\n<p>관련 내용이 없는 책이 없을 정도로 다양한 주제로 된 책들이 엄청나게 많이 나와있다. 욕심이 많아 다 읽고 싶어 닥치는데로 빌려보고 사고 하였지만 결국 전략이 필요헀다.</p>\n<p><strong>머릿속에 남는게 없다.</strong><br>\n책을 다 읽었다고 내 지식이 되지 않는다… 그냥 책을 1권 읽었다 성취감만 느기고 싶어 책만! 읽는것이다. 내것으로 만드는 전략없이 즉, 의도적인 행위 없이 글만 본것은 도로아미타불이다…</p>\n<p><strong>그럼 전략은?</strong></p>\n<ul>\n<li>읽는 목적을 분명히 한다.\n<ul>\n<li>특정 주제를 보고 싶은가? 그러면 목차보고 관심있는 주제부터 보자 그래야 집중력과 머릿속에 잘 기억에 남는다.</li>\n<li>0부터 100까지 봐야 하는가? 그러면 목차를 쭉 스캔하고나서 읽되 특정 구절에 나의 생각을 적으면서 그날 읽은 것을 독서노트에 적고 반드시 내용을 공유하자<br>\n그리고 반복과 실천 뿐이다.</li>\n<li>책을 더럽게 보자</li>\n</ul>\n</li>\n</ul>\n<h3>나의 계획 실천 프레임워크</h3>\n<p>독서를 하면서 내가 이루고 싶은 것들을 이루기 위해서 체계적인 계획이 있어야 동기부여도 되면서 내가 무엇을 해야 하는지 딱 정해놔야 내가 실천 잘 할 수 있다는 것을 깨닳게 되어 고민해서 만든 나의 실천 프레임워크를 만들어 보았다.</p>\n<h4>Evernote</h4>\n<img src=\"/2019/01/13/회고/2018년%20회고/evernote.png\">  \n<p>제일 먼저 사용했던 앱으로 계획에 대한 진행 상황을 한눈에 볼 수 없다는 단점이 있어서 Notion 갈아타게 되었다.</p>\n<h4>Notion</h4>\n<p>메모앱 끝판왕이라고 할 수 있다.<br>\n자유롭게 내가 하고 싶은 포맷을 바꿀수 있어 편리하다.</p>\n<p>계획을 보기 편하고 잘 짜기 위해 여러 앱을 사용해보았다.<br>\n계획을 짜면서 느낀점은 하루에 내가 할 수 있는 양을 정확히 알고 그선 안에서 해야 한다는 것이다.</p>\n<h2>개발</h2>\n<h3>매일 알고리즘 문제 풀기</h3>\n<p>알고리즘 자체를 하기 위한 것이 아니라 논리력, 문제해결 능력을 키우기 위해 시작하였다.<br>\n하지만 시간이 많이 소요되고 전략없이 무작정 풀려고만해서 그런지 재미도 없고 금방 지쳐서 꾸준히 못했다.<br>\n약한 분야이다 보니 기반지식, 의식적 수련이 많이 필요한것을 느꼈다.</p>\n<p>중요한 능력인 만큼 내년에는 반드시 매일 실천 할 것이며 해당 습관을 만들기 위해 Github에 실천 <a href=\"https://goo.gl/VdhQoz\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">repo</a>를 생성하였다.<br>\n내년에는 반드시 코딩 문제를 풀면서 사고력과 논리력을 키워 기본기가 탄탄한 프로그래머가 되자</p>\n<h3>패스트캠퍼스 컴퓨터 공학 인강</h3>\n<p>OS에 대한 개념은 확실히 많이 알게 되었다.<br>\n내년에는 컴퓨터 구조, 리눅스, C/C++, Phython 까지 모두 완강하고 정리까지 마쳐야 겠다.</p>\n<h3>TIL</h3>\n<p>하루를 정말 쌓아가는 느낌을 들게 해주는 역활이었던거 같다.<br>\n비록 2달째 정도 거의 빠지지 않고 잘 유지하고 있는데 내년에도 계속 이어나가 내가 알게 된 지식을 잘 정리하고 장기기억으로 이어질수 있도록 하자</p>\n<h3>토이프로젝트</h3>\n<ul>\n<li>일단 제대로 완성 시킨것은 없다…</li>\n<li>개발범위를 너무 넓게 잡고 개발기간도 너무 오래 잡아 타이트 하지 않아 집중려고 떨어 졌다.</li>\n<li>내년에는 2주짜리, 3개월짜리 개발기간을 딱 정하고 평소 해보고 싶었던 기술을 써보아서 나의 개발 무기를 추가해보자</li>\n</ul>\n<h1>반성</h1>\n<h2>하루에 할 수 있는 것만!</h2>\n<p>하고싶은것은 많아 무리하게 계획하여 하루에 다 못이루는 경우가 많았다…<br>\n욕심이 많아 얼른 머릿속에 지식을 넣고 싶지만 지식을 내것으로 만드는 과정은 그렇게 빨리 이루어지지 않는다느것 이해와 반복이 계속 수반되어야 체화 되는 것을 다시 한번 알게 되었다.<br>\n내가 하루에 얼마나 투자 할 수 있을지 시간을 계산해보고 그 범위내에서 계획하고 꾸준히 이루어 나가자</p>\n<h1>2018년 마무리</h1>\n<p>참 많이 시도도 해보고 성장도 많이 한 한해인거 같다.<br>\n책도 많이 읽었고 계획한것을 잘 실천하기 위해 메모앱을 활용하면서 시도도 많이 해보고 지금은 시행착오에 대한 결과로 나만의 실천 프레임워크가 잘 정착된거 같다.<br>\n육아 하면서 짬짬히 시간내기가 정말 힘들었지만 그것또한 이제 익숙해져서 시간도 잘 활용하고 있다.<br>\n내년 2019년도에는 지금보다 훨씬 더 큰 폭으로 성장 할 것이라는 확신이 든다.<br>\n이제 나의 실천 프레임워크 기반 위에서 해야 할 플랜을 잘 실천하자 내년에는 참 많이 달라진 내모습을 기대하면서 기록은 마무리 하겠다.</p>\n<h1>내년에는?</h1>\n<ul>\n<li>프로그래머 필수 역량 논리력, 문제해결능력 이 본질적인 능력을 키우는 것을 최우선으로 한다.</li>\n<li>영어 듣고, 말하고, 쓰고, 읽고가 되는 실력을 만들자, 영어 레퍼런스 문서, 책, 유트브영상 보는데 부담이 없을 정도로 만든다.</li>\n<li>웹에서 류윤광이라는 개발자를 알리고 개발자들 사이에 편리한 서비스 및 아이디어를 구상하여 개발자들에게 편리함을 줘보자</li>\n<li>구상한 토이프로젝트는 반드시 기간 맞춰서 완성도 있게 완성 시킨다.</li>\n</ul>\n<h1>내년에는?</h1>\n<h2>쳬계적인 시간 관리</h2>\n<h3>평일 투자 가용 시간</h3>\n<ul>\n<li>출/퇴근 시간(100분)</li>\n<li>점심 시간(50분)</li>\n<li>자기전 까지(3시간)</li>\n</ul>\n<p><strong>약 5시간 30분이다.</strong></p>\n<h3>시간간분배</h3>\n<ul>\n<li>출/퇴근: 독서/개발자 블로그 보기</li>\n<li>점심: 코딩문제</li>\n<li>집 22:00 ~ 23:00: TIL</li>\n<li>집 23:00 ~ 23:30: 영어</li>\n<li>집 23:30 ~ 01:30: 개인개발공부</li>\n</ul>\n<h4>출/퇴근 독서/개발자 블로그 보기</h4>\n<p>독서 할 떄 이제는 양보단 질이다. 빨리 읽고 다른거 읽자 이런 마인드보다 한구절이라도 나를 울려 나의 행동과 생각을 깨뜨릴수 있도록 소중히 읽도록하자</p>\n<ul>\n<li>그날 읽은 내용 그날 독서노트 정리</li>\n<li>정리 시간은 TIL 시간에 할애 하자</li>\n</ul>\n<h4>점심 코딩문제</h4>\n<p>반드시 습관을 만들어야 한다.</p>\n<ul>\n<li>문제 해결 전략을 만들어보자</li>\n<li>30분 투자해도 안되면 다른 사람의 답과 비교해 보자</li>\n<li>뭐가 문제인지 정확히 파악하고 해당 내용을 Github에 실천 <a href=\"https://goo.gl/VdhQoz\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">repo</a>에 적자</li>\n<li>다시 첨부터 풀어보자</li>\n</ul>\n<h4>집 22:00 ~ 23:00: TIL</h4>\n<ul>\n<li>반드시 1시간만 투자한다. 다른거 할 꺼 많음 이거에 너무 많은 시간투자 하지는 말자</li>\n<li>너무 내용이 많으면 큰 덩이리들로만 한번 다 적고 나머지 디테일은 주말찬스를 쓰도록 하자</li>\n</ul>\n<h4>집 23:00 ~ 23:30: 영어</h4>\n<ul>\n<li>2019년 가장 중요한 목표중에 하나</li>\n<li>발음,강세,리듬을 신경쓰면서 영어와 친해지자</li>\n<li>한문장이라도 제대로 파악하고 입에 연습한다.</li>\n</ul>\n<h4>집 23:30 ~ 01:30: 개인개발공부</h4>\n<ul>\n<li>이왕이면 업무 할 때 할 수 없는 기술들을 사용해 보는 시간을 가지자</li>\n<li>주로 토이프로젝트 할 때 시간을 할애 하자</li>\n</ul>\n<h2>토이프로젝트</h2>\n<p>만들고 싶은 주제를 선정하여 짧으면 1달 길면 3개월 정도 걸리는 범위를 정하고 플젝을 만들자.<br>\n질질 끌게 되면 지치고 성취감도 느낄수 없게된다.<br>\n일단 목표치까지 만들고 살을 붙이 도록 하자</p>\n<h2>프로그래밍 기본, 본질에 충실하기</h2>\n<p>토이보다 중요한건 프로그래밍 기본과 본질적 능력을 의식적인 노력을 키우는 것이다.</p>\n<ul>\n<li>컴퓨터 구조, OS, 전산 관련 필수 지식을 확실히 내것을 만들기</li>\n<li>클린코드, TDD, 리펙토링, 디자인패턴, OOP 특정 라이브러리 프레임워크 의존없이 개발에 기본기를 탄탄히 하여야 한다.</li>\n</ul>\n<h2>영문 레퍼런스 문서 술술~~</h2>\n<p>답은 거의 레퍼런스 문서에 다있다. 읽을줄 알면 신세계다. 반드시 독해능력을 향상 시키자</p>\n<h2>영어 컨텐츠 영상 쏙쏙~~</h2>\n<p>국내 컨텐츠는 빙산의 일각이다. 귀가 뚫리면 더많이 알 수 있다.</p>\n"},{"title":"새로운 개념 어떻게 습득해야 할까","catalog":true,"date":"2018-12-11T15:18:21.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["메타"],"_content":"\n# 새로운 개념 습득 어떻게?\n\n소프트웨어 개발자로 살고 있는 나는 홍수같이 터져 나오는 많은 기술들에 대해서 다 알아둬야 할 것 같아서 허덕거렸다.  \n이 많은 것을 언제 다 배우지? 그것은 중압감과 압박감으로 스트레스로 이루어 졌고\n일하면서 알게된 지식들 정리하기도 벅찬데 육아하면서 새로운 개념은 언제 습득 할까..\n\n하지만 다른 개발들에 생각들을 웹에서 접하면서 새로운 기술을 배우는 것에 초점을 맞추는게 아니라\n새로운 기술들을 잘 배울려면 나는 어떻게 해야 할까?? 라는 좀 더 근본적인 다시 말해 메타 생각을 가지게 되었다.\n\n다 배울 필요없고 미리 배울 필요도 없다. 그냥 써야 되는 상황이 오면 그때 습득하여 적용하면 되는 것이다.\n\n어짜피 미리 배워봤자 머릿속에 장기기억으로 잘 이루어지지 않는다.  \n왜냐하면 설사 습득하였다 하더라도 습득한 기술이\n정말 절실하고 필요해서 사용한 것이 아니기 때문에 잘 와닿지도 않아 뇌 신경망을 그리 자극시키지 않기 때문이다.\n\n평소에 쓰는 기술들로 다시 머릿속을 채울뿐이다.\n\n한마디로 밑빠진독에 물붓기...\n\n그럼 다시 돌아와서 내가 중요하게 생각하는것은 새로운 개념을 어떻게 해야 빠르고 정확하게 잘 습득하여 적용/응용 할 수 있을까? 라는 대답이다.\n\n시간 날때마다 생각해본 나의 생각과 참고한 사이트 기반으로 정리한 방법은 아래와 같다. [원문](https://goo.gl/XNsHZv) / [번역](https://goo.gl/di0BnJ)\n\n\n# 그래서 어떻게 하라고?\n\n## Step1 튜토리얼 데로 따라해보자\n\n### 익숙해지는게 목표\n\n- 처음 접한 것이기 때문에 이해라는 그림에 퍼즐조각을 많이 확보해야 함\n- 퍼즐조각이 많을수록 이해도가 증가함\n- 모르는것이 천지이기 때문에 모른다고 시간 잡아 먹으면 끝도 없음 일단 끝까지 완주 하는게 목표\n\n## Step2 튜토리얼 따라하면서 몰랐던 내용 조사\n- Step1 에서 궁금증을 푸는 단계\n- 삽질은 반드시 필요하며 머릿속에 넣는 고통에 대가이자 필수 재료이다.\n- 책, 인터넷 서치, 커뮤니티, 지인 질문 등 다양한 방법으로 모르는 것을 해결하자\n\n## Step3 내가 만들고 싶은것을 만들어보자\n\n- 새로운 것을 습득하려는 이유가 반드시 있을것이다.\n- 그 이유가 무엇인가??\n- 그 이유를 바탕으로 내가 만들고 싶은걸 만들어야 동기가 생기고 재밋게 개발할 수 있다.\n\n## Step4 방출하기\n- 머릿속에 든 내용을 꺼내야 장기기억으로 이어짐\n- 그 수단은 포스팅, 누군가에게 이해시키기 등이 있다.\n\n# 의식적 연습\n\nnode.js 기반 스케줄 모듈 만들어 보자","source":"_posts/메타인지/[meta] 새로운 개념 어떻게 습득해야 할까.md","raw":"---\ntitle: 새로운 개념 어떻게 습득해야 할까\ncatalog: true\ndate: 2018-12-12 00:18:21\nsubtitle:\nheader-img: \"bg_computer.jpg\"\ntags:\n- 메타\ncatagories:\n- 메타\n---\n\n# 새로운 개념 습득 어떻게?\n\n소프트웨어 개발자로 살고 있는 나는 홍수같이 터져 나오는 많은 기술들에 대해서 다 알아둬야 할 것 같아서 허덕거렸다.  \n이 많은 것을 언제 다 배우지? 그것은 중압감과 압박감으로 스트레스로 이루어 졌고\n일하면서 알게된 지식들 정리하기도 벅찬데 육아하면서 새로운 개념은 언제 습득 할까..\n\n하지만 다른 개발들에 생각들을 웹에서 접하면서 새로운 기술을 배우는 것에 초점을 맞추는게 아니라\n새로운 기술들을 잘 배울려면 나는 어떻게 해야 할까?? 라는 좀 더 근본적인 다시 말해 메타 생각을 가지게 되었다.\n\n다 배울 필요없고 미리 배울 필요도 없다. 그냥 써야 되는 상황이 오면 그때 습득하여 적용하면 되는 것이다.\n\n어짜피 미리 배워봤자 머릿속에 장기기억으로 잘 이루어지지 않는다.  \n왜냐하면 설사 습득하였다 하더라도 습득한 기술이\n정말 절실하고 필요해서 사용한 것이 아니기 때문에 잘 와닿지도 않아 뇌 신경망을 그리 자극시키지 않기 때문이다.\n\n평소에 쓰는 기술들로 다시 머릿속을 채울뿐이다.\n\n한마디로 밑빠진독에 물붓기...\n\n그럼 다시 돌아와서 내가 중요하게 생각하는것은 새로운 개념을 어떻게 해야 빠르고 정확하게 잘 습득하여 적용/응용 할 수 있을까? 라는 대답이다.\n\n시간 날때마다 생각해본 나의 생각과 참고한 사이트 기반으로 정리한 방법은 아래와 같다. [원문](https://goo.gl/XNsHZv) / [번역](https://goo.gl/di0BnJ)\n\n\n# 그래서 어떻게 하라고?\n\n## Step1 튜토리얼 데로 따라해보자\n\n### 익숙해지는게 목표\n\n- 처음 접한 것이기 때문에 이해라는 그림에 퍼즐조각을 많이 확보해야 함\n- 퍼즐조각이 많을수록 이해도가 증가함\n- 모르는것이 천지이기 때문에 모른다고 시간 잡아 먹으면 끝도 없음 일단 끝까지 완주 하는게 목표\n\n## Step2 튜토리얼 따라하면서 몰랐던 내용 조사\n- Step1 에서 궁금증을 푸는 단계\n- 삽질은 반드시 필요하며 머릿속에 넣는 고통에 대가이자 필수 재료이다.\n- 책, 인터넷 서치, 커뮤니티, 지인 질문 등 다양한 방법으로 모르는 것을 해결하자\n\n## Step3 내가 만들고 싶은것을 만들어보자\n\n- 새로운 것을 습득하려는 이유가 반드시 있을것이다.\n- 그 이유가 무엇인가??\n- 그 이유를 바탕으로 내가 만들고 싶은걸 만들어야 동기가 생기고 재밋게 개발할 수 있다.\n\n## Step4 방출하기\n- 머릿속에 든 내용을 꺼내야 장기기억으로 이어짐\n- 그 수단은 포스팅, 누군가에게 이해시키기 등이 있다.\n\n# 의식적 연습\n\nnode.js 기반 스케줄 모듈 만들어 보자","slug":"메타인지/[meta] 새로운 개념 어떻게 습득해야 할까","published":1,"updated":"2019-07-10T14:43:29.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids1v002lk0otqywmshz4","content":"<h1><span id=\"새로운-개념-습득-어떻게\">새로운 개념 습득 어떻게?</span></h1>\n<p>소프트웨어 개발자로 살고 있는 나는 홍수같이 터져 나오는 많은 기술들에 대해서 다 알아둬야 할 것 같아서 허덕거렸다.<br>\n이 많은 것을 언제 다 배우지? 그것은 중압감과 압박감으로 스트레스로 이루어 졌고<br>\n일하면서 알게된 지식들 정리하기도 벅찬데 육아하면서 새로운 개념은 언제 습득 할까…</p>\n<p>하지만 다른 개발들에 생각들을 웹에서 접하면서 새로운 기술을 배우는 것에 초점을 맞추는게 아니라<br>\n새로운 기술들을 잘 배울려면 나는 어떻게 해야 할까?? 라는 좀 더 근본적인 다시 말해 메타 생각을 가지게 되었다.</p>\n<p>다 배울 필요없고 미리 배울 필요도 없다. 그냥 써야 되는 상황이 오면 그때 습득하여 적용하면 되는 것이다.</p>\n<p>어짜피 미리 배워봤자 머릿속에 장기기억으로 잘 이루어지지 않는다.<br>\n왜냐하면 설사 습득하였다 하더라도 습득한 기술이<br>\n정말 절실하고 필요해서 사용한 것이 아니기 때문에 잘 와닿지도 않아 뇌 신경망을 그리 자극시키지 않기 때문이다.</p>\n<p>평소에 쓰는 기술들로 다시 머릿속을 채울뿐이다.</p>\n<p>한마디로 밑빠진독에 물붓기…</p>\n<p>그럼 다시 돌아와서 내가 중요하게 생각하는것은 새로운 개념을 어떻게 해야 빠르고 정확하게 잘 습득하여 적용/응용 할 수 있을까? 라는 대답이다.</p>\n<p>시간 날때마다 생각해본 나의 생각과 참고한 사이트 기반으로 정리한 방법은 아래와 같다. <a href=\"https://goo.gl/XNsHZv\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">원문</a> / <a href=\"https://goo.gl/di0BnJ\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">번역</a></p>\n<h1><span id=\"그래서-어떻게-하라고\">그래서 어떻게 하라고?</span></h1>\n<h2><span id=\"step1-튜토리얼-데로-따라해보자\">Step1 튜토리얼 데로 따라해보자</span></h2>\n<h3><span id=\"익숙해지는게-목표\">익숙해지는게 목표</span></h3>\n<ul>\n<li>처음 접한 것이기 때문에 이해라는 그림에 퍼즐조각을 많이 확보해야 함</li>\n<li>퍼즐조각이 많을수록 이해도가 증가함</li>\n<li>모르는것이 천지이기 때문에 모른다고 시간 잡아 먹으면 끝도 없음 일단 끝까지 완주 하는게 목표</li>\n</ul>\n<h2><span id=\"step2-튜토리얼-따라하면서-몰랐던-내용-조사\">Step2 튜토리얼 따라하면서 몰랐던 내용 조사</span></h2>\n<ul>\n<li>Step1 에서 궁금증을 푸는 단계</li>\n<li>삽질은 반드시 필요하며 머릿속에 넣는 고통에 대가이자 필수 재료이다.</li>\n<li>책, 인터넷 서치, 커뮤니티, 지인 질문 등 다양한 방법으로 모르는 것을 해결하자</li>\n</ul>\n<h2><span id=\"step3-내가-만들고-싶은것을-만들어보자\">Step3 내가 만들고 싶은것을 만들어보자</span></h2>\n<ul>\n<li>새로운 것을 습득하려는 이유가 반드시 있을것이다.</li>\n<li>그 이유가 무엇인가??</li>\n<li>그 이유를 바탕으로 내가 만들고 싶은걸 만들어야 동기가 생기고 재밋게 개발할 수 있다.</li>\n</ul>\n<h2><span id=\"step4-방출하기\">Step4 방출하기</span></h2>\n<ul>\n<li>머릿속에 든 내용을 꺼내야 장기기억으로 이어짐</li>\n<li>그 수단은 포스팅, 누군가에게 이해시키기 등이 있다.</li>\n</ul>\n<h1><span id=\"의식적-연습\">의식적 연습</span></h1>\n<p>node.js 기반 스케줄 모듈 만들어 보자</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>새로운 개념 습득 어떻게?</h1>\n<p>소프트웨어 개발자로 살고 있는 나는 홍수같이 터져 나오는 많은 기술들에 대해서 다 알아둬야 할 것 같아서 허덕거렸다.<br>\n이 많은 것을 언제 다 배우지? 그것은 중압감과 압박감으로 스트레스로 이루어 졌고<br>\n일하면서 알게된 지식들 정리하기도 벅찬데 육아하면서 새로운 개념은 언제 습득 할까…</p>\n<p>하지만 다른 개발들에 생각들을 웹에서 접하면서 새로운 기술을 배우는 것에 초점을 맞추는게 아니라<br>\n새로운 기술들을 잘 배울려면 나는 어떻게 해야 할까?? 라는 좀 더 근본적인 다시 말해 메타 생각을 가지게 되었다.</p>\n<p>다 배울 필요없고 미리 배울 필요도 없다. 그냥 써야 되는 상황이 오면 그때 습득하여 적용하면 되는 것이다.</p>\n<p>어짜피 미리 배워봤자 머릿속에 장기기억으로 잘 이루어지지 않는다.<br>\n왜냐하면 설사 습득하였다 하더라도 습득한 기술이<br>\n정말 절실하고 필요해서 사용한 것이 아니기 때문에 잘 와닿지도 않아 뇌 신경망을 그리 자극시키지 않기 때문이다.</p>\n<p>평소에 쓰는 기술들로 다시 머릿속을 채울뿐이다.</p>\n<p>한마디로 밑빠진독에 물붓기…</p>\n<p>그럼 다시 돌아와서 내가 중요하게 생각하는것은 새로운 개념을 어떻게 해야 빠르고 정확하게 잘 습득하여 적용/응용 할 수 있을까? 라는 대답이다.</p>\n<p>시간 날때마다 생각해본 나의 생각과 참고한 사이트 기반으로 정리한 방법은 아래와 같다. <a href=\"https://goo.gl/XNsHZv\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">원문</a> / <a href=\"https://goo.gl/di0BnJ\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">번역</a></p>\n<h1>그래서 어떻게 하라고?</h1>\n<h2>Step1 튜토리얼 데로 따라해보자</h2>\n<h3>익숙해지는게 목표</h3>\n<ul>\n<li>처음 접한 것이기 때문에 이해라는 그림에 퍼즐조각을 많이 확보해야 함</li>\n<li>퍼즐조각이 많을수록 이해도가 증가함</li>\n<li>모르는것이 천지이기 때문에 모른다고 시간 잡아 먹으면 끝도 없음 일단 끝까지 완주 하는게 목표</li>\n</ul>\n<h2>Step2 튜토리얼 따라하면서 몰랐던 내용 조사</h2>\n<ul>\n<li>Step1 에서 궁금증을 푸는 단계</li>\n<li>삽질은 반드시 필요하며 머릿속에 넣는 고통에 대가이자 필수 재료이다.</li>\n<li>책, 인터넷 서치, 커뮤니티, 지인 질문 등 다양한 방법으로 모르는 것을 해결하자</li>\n</ul>\n<h2>Step3 내가 만들고 싶은것을 만들어보자</h2>\n<ul>\n<li>새로운 것을 습득하려는 이유가 반드시 있을것이다.</li>\n<li>그 이유가 무엇인가??</li>\n<li>그 이유를 바탕으로 내가 만들고 싶은걸 만들어야 동기가 생기고 재밋게 개발할 수 있다.</li>\n</ul>\n<h2>Step4 방출하기</h2>\n<ul>\n<li>머릿속에 든 내용을 꺼내야 장기기억으로 이어짐</li>\n<li>그 수단은 포스팅, 누군가에게 이해시키기 등이 있다.</li>\n</ul>\n<h1>의식적 연습</h1>\n<p>node.js 기반 스케줄 모듈 만들어 보자</p>\n"},{"title":"2019.02 회고","catalog":true,"subtitle":null,"header-img":"bg_computer.jpg","_content":"\n### 간소화 하기\n하루에 투자 할 시간은 한정적이다. 알차게 시간 보내기 위해서 지금 당장 해야 할 것부터 하자.  \n하루 점수 메기는 것보다 실천할것을 먼저하자\n\n\n### 영어 생활화\n영어를 생활화 하지 않으면 절대 영어 실력이 늘지 않는다. \n- 영어 이력서\n- 영어 커밋 메세지\n- 영어 문법 공부\n- 말하고 싶은 문장 말하기\n- 쉐도잉\n\n꾸준히 하자\n\n\n### 코딩문제 비중있게\n중요하다 시간 투자 많이 하자\n\n\n### 하루 어떻게??\n- 출근: 독서(꾸준히 읽어야 한다. 특히 개발서적, 많이 알아둬야 뭘 할지도 생각나는거임), 쉐도잉\n- 업무: 공부하면서 개발(시도할꺼 하자)\n- 퇴근: 컴공강의\n- 집: 0.5 영어 / 1.5 코딩문제 / 1.5 개인 토이\n- 짬시간 날 때마다 즐.찾 한 어려운 개념 익숙하게 하기\n\n\n### 내가 공부하고 싶은것 위주로\nNotion앱을 잘 활용 하여 모든 공부 내용은 Queue에 적어 놓고 실천해 나가자  \n일단, 내가 우선순위로 생각하는것은  \n\n- 코딩 문제\n- 하고 있는 개발 더 좋은 방법 찾아 바꾸기(리팩토링,디자인패턴,스프링설정,예외처리 등등)\n- 영어공부\n- 업무에서 안하는 새로운거 하기(대용량 데이터처리, 카프카, MSA 등)","source":"_posts/회고/2019년도 2월 회고.md","raw":"---\ntitle: 2019.02 회고\ncatalog: true\nsubtitle: \nheader-img: \"bg_computer.jpg\"\ntags: \n- 회고\n---\n\n### 간소화 하기\n하루에 투자 할 시간은 한정적이다. 알차게 시간 보내기 위해서 지금 당장 해야 할 것부터 하자.  \n하루 점수 메기는 것보다 실천할것을 먼저하자\n\n\n### 영어 생활화\n영어를 생활화 하지 않으면 절대 영어 실력이 늘지 않는다. \n- 영어 이력서\n- 영어 커밋 메세지\n- 영어 문법 공부\n- 말하고 싶은 문장 말하기\n- 쉐도잉\n\n꾸준히 하자\n\n\n### 코딩문제 비중있게\n중요하다 시간 투자 많이 하자\n\n\n### 하루 어떻게??\n- 출근: 독서(꾸준히 읽어야 한다. 특히 개발서적, 많이 알아둬야 뭘 할지도 생각나는거임), 쉐도잉\n- 업무: 공부하면서 개발(시도할꺼 하자)\n- 퇴근: 컴공강의\n- 집: 0.5 영어 / 1.5 코딩문제 / 1.5 개인 토이\n- 짬시간 날 때마다 즐.찾 한 어려운 개념 익숙하게 하기\n\n\n### 내가 공부하고 싶은것 위주로\nNotion앱을 잘 활용 하여 모든 공부 내용은 Queue에 적어 놓고 실천해 나가자  \n일단, 내가 우선순위로 생각하는것은  \n\n- 코딩 문제\n- 하고 있는 개발 더 좋은 방법 찾아 바꾸기(리팩토링,디자인패턴,스프링설정,예외처리 등등)\n- 영어공부\n- 업무에서 안하는 새로운거 하기(대용량 데이터처리, 카프카, MSA 등)","slug":"회고/2019년도 2월 회고","published":1,"date":"2019-03-01T13:39:49.607Z","updated":"2019-07-10T14:38:56.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids1z002nk0ot4d5cs6ri","content":"<h3><span id=\"간소화-하기\">간소화 하기</span></h3>\n<p>하루에 투자 할 시간은 한정적이다. 알차게 시간 보내기 위해서 지금 당장 해야 할 것부터 하자.<br>\n하루 점수 메기는 것보다 실천할것을 먼저하자</p>\n<h3><span id=\"영어-생활화\">영어 생활화</span></h3>\n<p>영어를 생활화 하지 않으면 절대 영어 실력이 늘지 않는다.</p>\n<ul>\n<li>영어 이력서</li>\n<li>영어 커밋 메세지</li>\n<li>영어 문법 공부</li>\n<li>말하고 싶은 문장 말하기</li>\n<li>쉐도잉</li>\n</ul>\n<p>꾸준히 하자</p>\n<h3><span id=\"코딩문제-비중있게\">코딩문제 비중있게</span></h3>\n<p>중요하다 시간 투자 많이 하자</p>\n<h3><span id=\"하루-어떻게\">하루 어떻게??</span></h3>\n<ul>\n<li>출근: 독서(꾸준히 읽어야 한다. 특히 개발서적, 많이 알아둬야 뭘 할지도 생각나는거임), 쉐도잉</li>\n<li>업무: 공부하면서 개발(시도할꺼 하자)</li>\n<li>퇴근: 컴공강의</li>\n<li>집: 0.5 영어 / 1.5 코딩문제 / 1.5 개인 토이</li>\n<li>짬시간 날 때마다 즐.찾 한 어려운 개념 익숙하게 하기</li>\n</ul>\n<h3><span id=\"내가-공부하고-싶은것-위주로\">내가 공부하고 싶은것 위주로</span></h3>\n<p>Notion앱을 잘 활용 하여 모든 공부 내용은 Queue에 적어 놓고 실천해 나가자<br>\n일단, 내가 우선순위로 생각하는것은</p>\n<ul>\n<li>코딩 문제</li>\n<li>하고 있는 개발 더 좋은 방법 찾아 바꾸기(리팩토링,디자인패턴,스프링설정,예외처리 등등)</li>\n<li>영어공부</li>\n<li>업무에서 안하는 새로운거 하기(대용량 데이터처리, 카프카, MSA 등)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3>간소화 하기</h3>\n<p>하루에 투자 할 시간은 한정적이다. 알차게 시간 보내기 위해서 지금 당장 해야 할 것부터 하자.<br>\n하루 점수 메기는 것보다 실천할것을 먼저하자</p>\n<h3>영어 생활화</h3>\n<p>영어를 생활화 하지 않으면 절대 영어 실력이 늘지 않는다.</p>\n<ul>\n<li>영어 이력서</li>\n<li>영어 커밋 메세지</li>\n<li>영어 문법 공부</li>\n<li>말하고 싶은 문장 말하기</li>\n<li>쉐도잉</li>\n</ul>\n<p>꾸준히 하자</p>\n<h3>코딩문제 비중있게</h3>\n<p>중요하다 시간 투자 많이 하자</p>\n<h3>하루 어떻게??</h3>\n<ul>\n<li>출근: 독서(꾸준히 읽어야 한다. 특히 개발서적, 많이 알아둬야 뭘 할지도 생각나는거임), 쉐도잉</li>\n<li>업무: 공부하면서 개발(시도할꺼 하자)</li>\n<li>퇴근: 컴공강의</li>\n<li>집: 0.5 영어 / 1.5 코딩문제 / 1.5 개인 토이</li>\n<li>짬시간 날 때마다 즐.찾 한 어려운 개념 익숙하게 하기</li>\n</ul>\n<h3>내가 공부하고 싶은것 위주로</h3>\n<p>Notion앱을 잘 활용 하여 모든 공부 내용은 Queue에 적어 놓고 실천해 나가자<br>\n일단, 내가 우선순위로 생각하는것은</p>\n<ul>\n<li>코딩 문제</li>\n<li>하고 있는 개발 더 좋은 방법 찾아 바꾸기(리팩토링,디자인패턴,스프링설정,예외처리 등등)</li>\n<li>영어공부</li>\n<li>업무에서 안하는 새로운거 하기(대용량 데이터처리, 카프카, MSA 등)</li>\n</ul>\n"},{"title":"IoC, DI란 무엇일까","catalog":true,"date":"2019-08-31T01:01:00.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["Spring"],"_content":"\n### Why?\n- Spring 에서 DI를 잘 썼다고 하는데 어느부분에서 잘썼는지 구체적인 사례를 찾아보자\n\n\n### 목표\n\n- Spring IoC, DI가 무엇인지 이해시킨다.\n- Spring DI에 장단점을 이해시킨다.\n- Bean이란 무엇이고 Container에서 어떻게 관리되고 생명주기는 어떻게 되는지 이해시킨다.\n\n### IoC (Inversion of Control) 란 무엇인가?\n\nIoC에 용어는 90년 중반에 GoF의 디자인패턴에서도 이용어가 언급되었다고 합니다. 즉, IoC는 Spring에서 나온 용어가 아닙니다. 과거 EJB에서도 WAS에 Servlet Container에서도 사용 된 개념이죠.  \n\nIoC에 대한 개념은 굉장히 폭이 넓습니다.  \n해석하면 제어의 역전입니다. 도대체 어떤 제어를 말하는 것이며 무엇을 역전한다는 말 일까요??\n\n아래 코드부터 바로 보시죠\n\n아래는 개발자가 직접 객체를 생성하여 코드를 제어하는 코드입니다.\n~~~ java\npublic class A {\n\n    private B b;\n\n    public A()\n        b = new B();\n    }\n}\n~~~\n\n위와 같이 B클래스를 직접 인스턴스하여 의존관계를 나타내고 있습니다. 즉 개발자가 직접 객체를 제어하여 A객체는 B객체에게 의존하고 있어 라고 클래스를 통해 표현하고 있는것 이죠\n\n이것은 개발자가 직접 한 것입니다. 하지만 아래 코드는 어떨까요??\n\n컨테이너에 의해서 생성한 객체를 사용만 하는 코드\n\n~~~ java\npublic class A {\n\n    @Autowired\n    private B b;\n\n}\n~~~\n\n스프링 사용자라면 잘알고 있는 표현입니다.\nB라는 객체가 스프링 컨테이너에게 관리되고 있는 Bean이라면 @Autowired 를 통해 객체를 주입받을수 있게 되죠\n이것은 개발자가 직접 객체를 관리하지 않고 스프링 컨테이너에서 직접(제어) 객체를 생성하여 해당 객체에 주입 시켜준 것입니다.\n\n이것이 바로 제어가 역전되었다. IoC 라는 개념입니다. 또 다른 예를 들어볼까요??\n\n\n디자인패턴인 템플릿 메소드 패턴에서도 IoC 개념을 찾아 볼 수 있습니다. 이처럼 IoC는 거시적인 개념이 아닌 프로그램을 제어권을 누가 가져갈것인가에 대한 프로그래밍 모델일 뿐입니다. 아래 코드를 한번 보죠\n\n~~~ java\npublic abstract class IronFactory {\n\n    private IronMan ironMan;\n\n    public IronMan getIronMan () {\n        return assemble();\n    }\n\n    /**\n     * 제어권은 상위 클래스에게 있다.\n     * 하위 클래스에서 구현한 코드는 상위 클래스가 어떻게 되는지 모른다. 단지 구현해야하는 부분을  \n    **/\n    private IronMan assemble() {\n        // do assemble.. from head, body, arms, legs\n        return ironMan;\n    }\n\n    protected abstract void head();\n    protected abstract void body();\n    protected abstract void arms();\n    protected abstract void legs();\n}\n~~~\n\n~~~ java\npublic classs HulkBuster extends IronFactory {\n\n    @Override\n    public void head() {\n        // do something..\n    }\n\n    @Override\n    public void body() {\n        // do something..\n    }\n\n    @Override\n    public void arms() {\n        // do something..\n    }\n\n    @Override\n    public void legs() {\n        // do something..\n    }\n}\n~~~\n\n제어권은 상위 클래스인 IronFactory에게 있습니다.\n하위 클래스에서 구현한 코드는 상위 클래스가 어떻게 되는지 모릅니다. 단지 구현해야하는 부분을 구현하였고 구현한 코드가 언제 어떻게 실행 될지는 모릅니다. 상위 클래스에서 알아서 필요할 때 구현한 메소드를 사용하게 됩니다. 바로 이처럼 코드 흐름이 제3자에게 위임되는 것이 IoC 모델이라고 합니다.\n\n### 그럼 왜 IoC를 Spring에서 사용 하였을까요? 분명히 이점이 있을텐데요\n\nIoC는 Spring에서만 사용되는 개념이 아닙니다. 프로그래밍 패턴이기때문에 범용적으로 쓰이며 작게는 객체간에 디자인 패턴으로 크게는 컨테이너, 프레임워크 역할에 적합한 구조이기 때문에 상황에 맞게 사용되는 프로그래밍 모델인 것이죠. Spring은 Framework입니다. 그렇기 때문에 흐름을 직접 핸들링 해줘야 하는것이고 자연스럽게 적합한 모델, 패턴을 적용해야 했고 그래서 Framework에 적합한 IoC, DI 개념 모델이 들어가게 된것이조.\n\n그럼 이점은 무엇이 있을까요?  \nIoC 프로그램 모델은 곧 역할과 책임에 분리라는 내용과 관련이 있다고 생각합니다.\n왜 내가 직접 객체를 제어 하지 않고 다른 제 3자가 제어를 위임하게 하고 나는 수동적으로 따라가는 길을 택하였을까요??\n\n이는 객체지향 프로그래밍과 아주 관련이 깊다고 생각합니다. 객체지향 프로그래밍은 각 객체마다 자기의 역할과 책임을 온전히 다하며 서로 협력하며 변경에 유연한 프로그래밍을 할 수 있는 프로그래밍 기법입니다. 즉, 각 객체마다 올바른 캡슐화를 통해 높은 응집도와 낮은 결합도를 이루어나가는 것이 핵심중에 핵심이죠.\n\n이러한 관점에서 제어의 역전으로 인해 제 3자 즉 다른 객체, 다른 컨테이너에게 제어에 대한 역할과 책임을 위임하고 다시말해 신경쓰지 않고 지금 내가 하고자 하는 역할과 책임에 관심이 있는것이죠. 왜 이렇게 할까요? 답은 **변경에 유연한 코드 구조를 가져가기 위해서**입니다. 내가 작성하고자 하는 코드에서 객체를 생성, 소멸 등에 관리 코드와 함께 비지니스 코드까지 들어가면 어떨까요??  \n\n기능은 얼마든지 변경될 수 있습니다. 자, A라는 객체를 생성하고 있었는데 A객체는 삭제하고 B객체를 추가해야 한다고 하면 어떻게 될까요?? 뭐 한 곳에서만 객체 생성을 추가했다면 한 곳에서만 변경하면 되겠죠.. 그럼 10곳에서 A라는 객체를 사용하였다고 해보죠. 그럼 10번을 수정해줘야 겠네요?   \n\n또 다른 예를 들어보죠. 객체 생명 주기를 직접 관리하기 때문에 객체 생성, 삭제를 직접 할 수 있습니다. 근데 도메인 모델상 객체 삭제는 절대 하면 안된다고 해보죠. 하지만 직접 개발자가 객체를 핸들링 할 수 있기 때문에 삭제하거나 아니면 새로운 객체를 생성 할 수 도 있습니다. 다시 말해서 권한이 너무 많다는 것입니다. 이것은 곧 캡슐화 위반을 일으킨 것입니다.  \n\n**엔터프라이즈 차원에서 수많은 객체들을 편리하게 관리하기 위함입니다.**  \n\n현재 설명한 객체는 등장한것이 2~3개 밖에 되지 않습니다.  \n각 객체마다 협력을 하다보면 IoC역할을 하는 객체들이 계속 생길수 있습니다. 그럼 개발자는 그런 IoC 역할을 하는 객체를 계속 알고 개발을 해야 합니다.  \n1~2개는 괜찮겠죠 하지만 개발하다 보면 또 유지보수 하다보면 객체를 계속 생길수 있습니다. 요구사항이 변하니까요.  \n\n그래서 스프링은 Application Context 로 모든 객체를 일괄 관리하는 IoC를 Wrapping 하는 개념이라 할까요? 아무튼 그렇게 보따리 해서 컨테이너가 되어 객체에 의존관계 주입, 객체 생명 주기 관리, 그 밖에 아직 제가 알지 못하는 영역에서 많은 유용한일을 담당 할 것입니다.\n\n**자 그럼 질문을 다시 해보겠습니다. IoC 왜 제어를 역전 시켰을까요? 어떤 이점일까요?**  \n\n객체를 관리해주는 독립적인 존재 (거시적으로는 컨테이너, 미시적으로는 디지인패턴적용)와 그 외 내가 구현 하고자 하는 부분으로 각각 관심을 분리하고 서로에 역할을 충실히하면서 변경에 유연한 코드를 작성 할 수 있는 구조이기 때문에 제어를 역전 하였다. 저는 이렇게 생각하였습니다.  \n\n스프링 컨테이너 차원에서는 엔터프라이즈 개발에 적합하게 수많은 객체 생명주기를 관리 하고 의존 관계를 설정해주고 그 외 많은 기능들을 제공하여 개발자는 비지니스 로직에 집중 할 수 있게 해주는것이죠.\n\n### 그럼 Spring DI 무엇을 의미하는 걸까요?\n\nSpring Framework란 무엇인가? 장점은 무엇인가? 조사를 하다보면 반드시 나오는 DI입니다.  \n이녀석은 무엇일까요?? 제가 참고한 토비스프링에서 정보를 얻을 수 있었습니다.  \n\n> IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는 점이다. 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공히는 기능의 특정을 명확하게 설명하지 못한다. .. 생략 .. 몇몇 사람의 제안으로 스프링이 제공하는 IoC 방식을 핵심을 짚어주는 의존관계 주입 DependencyIniection이라는， 좀 더 의도가 명확히 드러나는 이름을 사용하 기 시작했다.\n\n위에서 말했다싶이 IoC는 객체 생명 관리, 흐름 제어를 제 3자에게 위임하는 프로그래밍 모델입니다. 디자인 패턴인 템플릿 메소드 패턴에서도 IoC 개념을 찾아 볼 수 있었죠.\n하지만 이런 디자인 패턴이 적용된 것을 가지고 Spring 에서 IoC, IoC 할까요? 좀 더 핵심적인 의미가 있지 않을까요? 그 핵심적인 의미는 DI에서 찾아 볼 수 있습니다.\n\n> 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다. 생략..  \nDI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심\n\nSpring IoC와 DI가 어떤 차이점이 있는지 명확하게 이해가 되지 않았는데 위 문구에서 찾을 수 있게 되었죠.  \n\n그리고 DI라는 말은 마틴파울러와 그 주변사람들이 모여 IoC에 범용적인 의미를 객체 주입이라는 의미를 명확히 하기 위해 만들어졌다고 합니다.  \n그냥 제어의 역전이라 하면 그 차원에서 어느 범위에서 의존성 역전일까요? 단순 객체간의 디자인패턴으로 활용하는것도 제어 역전이고 컨테이너차원에서 수많은 객체들에 의존관계를 파악하고 런타임시점에서도 다이나믹하게 객체를 주임하여 유연한 프로그래밍을 할 수 있도록 하는 패턴에 더 명확한 이름을 부여하기 위해 토론 끝에 Dependency Injection 이라는 용어를 만들었다고 합니다.[[원문]](https://www.martinfowler.com/articles/injection.html) [[번역]](https://vandbt.tistory.com/44)\n\n\n### \nDI는 IoC 프로그래밍 모델을 구현하는 방식중에 하나입니다.  \nSpring 에서는 IoC를 구체적으로 DI라는 방식을통해서 의존성 역전 제어를 하고 있는 것이죠. 우선, 용어를 하나하나 분석해 보겠습니다.\n\n**의존성**  \n프로그래밍에서 의존한다는 말은 서로 다른 객체간에 레퍼런스 참조가 되어 있다는 말입니다. 이는 A -> B에 의존 관계에 있을 때, B객체에 변경사항이 생겼을 때, A 객체가 영향을 받는 구조인 것이죠.  \n\n~~~ java\npublic class A {\n\n    private B b = new B();\n\n    public void anyMethod() {\n        b.~~\n    }\n}\n~~~\n\n**주입**\n주입이란 단어를 생각하면 주사 맞는 이미지가 연상되는데요.  \n외부로부터 객체의 주소(레퍼런스) 값을 전달 받게 되어 객체가 참조 되어지는 방식입니다.  \n\n다시 돌아와서 그럼 의존성 주입이라는 말은 어떤 말일까요? \n의존관계에 있는 객체들이 있을 때, 외부(스프링컨테이너)에서 객체에 레퍼런스를 전달하여 사용하고자 하는 객체에서 코드를 작성 할 수 있게 한다. 이런의미가 되곘네요\n\nDI에 핵심 키워드는 **외부로부터~**, **다이나믹한 의존관계** 입니다.\n\n토비스프링에서 말하는 DI (의존관계 주입)에 3가지 조건은 다음과 같습니다.\n\n- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.\n- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.\n- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.\n\n외부로부터 인터페이스타입으로 얼마든지 부품이 교체 될 수 있으니 코드가 유연해 지겠죠? 또한 의존성 제어로 인해 수많은 객체들에 의존관계를 맺어주고 개발하는 클라이언트 입장에서는 편하게 비지니스로직에 집중할 수 있다고 생각합니다. 이러한 DI를 잘 녹인 프레임워크가 스프링이라고 합니다.\n\n\n\n토비스프링에서 인용한 문구를 다시 보여드리겠습니다.\n\n> DI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심 ..생략..\n주입받는 메소드 따라미터가 이미 특정 클래스 타입으로 고정되어 있다면 DI가 일어날 수 없다. DI에서 말하는 주입은 다이내믹하게 구현 클래스를 결정해서 제공받을 수 있도록 인터페이스 타입 의 파라미터를 통해 이뤄져야 한다.\n\n**핵심은 DI는 클래스타입이 고정되어 있지 않고 인터페이스 타입의 파라미터를 통해 다이나믹하게 구현 클래스를 결정해서 제공 받을수 있어야 한다.**\n\n이것이 바로 DI에 핵심개념입니다. \n\n\n\n\n코드를 통해서 바로 알아보겠습니다.   \n\n~~~ java\npublic class IronManController {\n\n    private IronManService ironManService;\n\n    public IronManController(IronManService ironManService) {\n        this.ironManService = ironManService;\n    }\n\n    // 생략\n\n}\n~~~\n\nIronManService라는 인터페이스를 \n\n~~~ java\npublic interface IronManService {\n\n    void attack();\n    void flying();\n}\n~~~\n\n\n~~~ java\npublic class HulkBuster implements IronManService {\n\n    @Override\n    public void attack() {\n        System.out.println(\"헐크버스터 공격!\");\n    }\n    // 생략\n}\n~~~\n\n~~~ java\npublic class Mark15 implements IronManService {\n\n    @Override\n    public void attack() {\n        System.out.println(\"나노입자 아이언맨 공격!\");\n    }\n    // 생략\n}\n~~~\n\nDI라는 개념 또한 스프링에서 나온 개념이 아닙니다.\n\n\n### 그럼 IoC와 DI 무엇이 다른걸까요??\n\nIoC는 객체의 흐름, 생명주기관리등 독립적인 제 3자에게 역할과 책임을 위임하는 방식에 프로그래밍 모델입니다.  \n디자인패턴에서도 찾아볼수 있고 다른 컨테이너를 가진 프레임워크들에서도 찾아볼 수 있습니다. 범용적인 표현이죠 하지만 DI는 인터페이스를 통해 다이나믹하게 객체를 주입을 하여 유연한 프로그래밍을 가능하게 하는 패턴으로 좀 더 구첵적인 의미인것이죠.  \n","source":"_posts/Spring/IoC, DI란 무엇일까.md","raw":"---\ntitle: IoC, DI란 무엇일까\ncatalog: true\ndate: 2019-08-31 10:01:00\nsubtitle: \nheader-img: \"bg_computer.jpg\"\ncatagories:\n- Spring\n---\n\n### Why?\n- Spring 에서 DI를 잘 썼다고 하는데 어느부분에서 잘썼는지 구체적인 사례를 찾아보자\n\n\n### 목표\n\n- Spring IoC, DI가 무엇인지 이해시킨다.\n- Spring DI에 장단점을 이해시킨다.\n- Bean이란 무엇이고 Container에서 어떻게 관리되고 생명주기는 어떻게 되는지 이해시킨다.\n\n### IoC (Inversion of Control) 란 무엇인가?\n\nIoC에 용어는 90년 중반에 GoF의 디자인패턴에서도 이용어가 언급되었다고 합니다. 즉, IoC는 Spring에서 나온 용어가 아닙니다. 과거 EJB에서도 WAS에 Servlet Container에서도 사용 된 개념이죠.  \n\nIoC에 대한 개념은 굉장히 폭이 넓습니다.  \n해석하면 제어의 역전입니다. 도대체 어떤 제어를 말하는 것이며 무엇을 역전한다는 말 일까요??\n\n아래 코드부터 바로 보시죠\n\n아래는 개발자가 직접 객체를 생성하여 코드를 제어하는 코드입니다.\n~~~ java\npublic class A {\n\n    private B b;\n\n    public A()\n        b = new B();\n    }\n}\n~~~\n\n위와 같이 B클래스를 직접 인스턴스하여 의존관계를 나타내고 있습니다. 즉 개발자가 직접 객체를 제어하여 A객체는 B객체에게 의존하고 있어 라고 클래스를 통해 표현하고 있는것 이죠\n\n이것은 개발자가 직접 한 것입니다. 하지만 아래 코드는 어떨까요??\n\n컨테이너에 의해서 생성한 객체를 사용만 하는 코드\n\n~~~ java\npublic class A {\n\n    @Autowired\n    private B b;\n\n}\n~~~\n\n스프링 사용자라면 잘알고 있는 표현입니다.\nB라는 객체가 스프링 컨테이너에게 관리되고 있는 Bean이라면 @Autowired 를 통해 객체를 주입받을수 있게 되죠\n이것은 개발자가 직접 객체를 관리하지 않고 스프링 컨테이너에서 직접(제어) 객체를 생성하여 해당 객체에 주입 시켜준 것입니다.\n\n이것이 바로 제어가 역전되었다. IoC 라는 개념입니다. 또 다른 예를 들어볼까요??\n\n\n디자인패턴인 템플릿 메소드 패턴에서도 IoC 개념을 찾아 볼 수 있습니다. 이처럼 IoC는 거시적인 개념이 아닌 프로그램을 제어권을 누가 가져갈것인가에 대한 프로그래밍 모델일 뿐입니다. 아래 코드를 한번 보죠\n\n~~~ java\npublic abstract class IronFactory {\n\n    private IronMan ironMan;\n\n    public IronMan getIronMan () {\n        return assemble();\n    }\n\n    /**\n     * 제어권은 상위 클래스에게 있다.\n     * 하위 클래스에서 구현한 코드는 상위 클래스가 어떻게 되는지 모른다. 단지 구현해야하는 부분을  \n    **/\n    private IronMan assemble() {\n        // do assemble.. from head, body, arms, legs\n        return ironMan;\n    }\n\n    protected abstract void head();\n    protected abstract void body();\n    protected abstract void arms();\n    protected abstract void legs();\n}\n~~~\n\n~~~ java\npublic classs HulkBuster extends IronFactory {\n\n    @Override\n    public void head() {\n        // do something..\n    }\n\n    @Override\n    public void body() {\n        // do something..\n    }\n\n    @Override\n    public void arms() {\n        // do something..\n    }\n\n    @Override\n    public void legs() {\n        // do something..\n    }\n}\n~~~\n\n제어권은 상위 클래스인 IronFactory에게 있습니다.\n하위 클래스에서 구현한 코드는 상위 클래스가 어떻게 되는지 모릅니다. 단지 구현해야하는 부분을 구현하였고 구현한 코드가 언제 어떻게 실행 될지는 모릅니다. 상위 클래스에서 알아서 필요할 때 구현한 메소드를 사용하게 됩니다. 바로 이처럼 코드 흐름이 제3자에게 위임되는 것이 IoC 모델이라고 합니다.\n\n### 그럼 왜 IoC를 Spring에서 사용 하였을까요? 분명히 이점이 있을텐데요\n\nIoC는 Spring에서만 사용되는 개념이 아닙니다. 프로그래밍 패턴이기때문에 범용적으로 쓰이며 작게는 객체간에 디자인 패턴으로 크게는 컨테이너, 프레임워크 역할에 적합한 구조이기 때문에 상황에 맞게 사용되는 프로그래밍 모델인 것이죠. Spring은 Framework입니다. 그렇기 때문에 흐름을 직접 핸들링 해줘야 하는것이고 자연스럽게 적합한 모델, 패턴을 적용해야 했고 그래서 Framework에 적합한 IoC, DI 개념 모델이 들어가게 된것이조.\n\n그럼 이점은 무엇이 있을까요?  \nIoC 프로그램 모델은 곧 역할과 책임에 분리라는 내용과 관련이 있다고 생각합니다.\n왜 내가 직접 객체를 제어 하지 않고 다른 제 3자가 제어를 위임하게 하고 나는 수동적으로 따라가는 길을 택하였을까요??\n\n이는 객체지향 프로그래밍과 아주 관련이 깊다고 생각합니다. 객체지향 프로그래밍은 각 객체마다 자기의 역할과 책임을 온전히 다하며 서로 협력하며 변경에 유연한 프로그래밍을 할 수 있는 프로그래밍 기법입니다. 즉, 각 객체마다 올바른 캡슐화를 통해 높은 응집도와 낮은 결합도를 이루어나가는 것이 핵심중에 핵심이죠.\n\n이러한 관점에서 제어의 역전으로 인해 제 3자 즉 다른 객체, 다른 컨테이너에게 제어에 대한 역할과 책임을 위임하고 다시말해 신경쓰지 않고 지금 내가 하고자 하는 역할과 책임에 관심이 있는것이죠. 왜 이렇게 할까요? 답은 **변경에 유연한 코드 구조를 가져가기 위해서**입니다. 내가 작성하고자 하는 코드에서 객체를 생성, 소멸 등에 관리 코드와 함께 비지니스 코드까지 들어가면 어떨까요??  \n\n기능은 얼마든지 변경될 수 있습니다. 자, A라는 객체를 생성하고 있었는데 A객체는 삭제하고 B객체를 추가해야 한다고 하면 어떻게 될까요?? 뭐 한 곳에서만 객체 생성을 추가했다면 한 곳에서만 변경하면 되겠죠.. 그럼 10곳에서 A라는 객체를 사용하였다고 해보죠. 그럼 10번을 수정해줘야 겠네요?   \n\n또 다른 예를 들어보죠. 객체 생명 주기를 직접 관리하기 때문에 객체 생성, 삭제를 직접 할 수 있습니다. 근데 도메인 모델상 객체 삭제는 절대 하면 안된다고 해보죠. 하지만 직접 개발자가 객체를 핸들링 할 수 있기 때문에 삭제하거나 아니면 새로운 객체를 생성 할 수 도 있습니다. 다시 말해서 권한이 너무 많다는 것입니다. 이것은 곧 캡슐화 위반을 일으킨 것입니다.  \n\n**엔터프라이즈 차원에서 수많은 객체들을 편리하게 관리하기 위함입니다.**  \n\n현재 설명한 객체는 등장한것이 2~3개 밖에 되지 않습니다.  \n각 객체마다 협력을 하다보면 IoC역할을 하는 객체들이 계속 생길수 있습니다. 그럼 개발자는 그런 IoC 역할을 하는 객체를 계속 알고 개발을 해야 합니다.  \n1~2개는 괜찮겠죠 하지만 개발하다 보면 또 유지보수 하다보면 객체를 계속 생길수 있습니다. 요구사항이 변하니까요.  \n\n그래서 스프링은 Application Context 로 모든 객체를 일괄 관리하는 IoC를 Wrapping 하는 개념이라 할까요? 아무튼 그렇게 보따리 해서 컨테이너가 되어 객체에 의존관계 주입, 객체 생명 주기 관리, 그 밖에 아직 제가 알지 못하는 영역에서 많은 유용한일을 담당 할 것입니다.\n\n**자 그럼 질문을 다시 해보겠습니다. IoC 왜 제어를 역전 시켰을까요? 어떤 이점일까요?**  \n\n객체를 관리해주는 독립적인 존재 (거시적으로는 컨테이너, 미시적으로는 디지인패턴적용)와 그 외 내가 구현 하고자 하는 부분으로 각각 관심을 분리하고 서로에 역할을 충실히하면서 변경에 유연한 코드를 작성 할 수 있는 구조이기 때문에 제어를 역전 하였다. 저는 이렇게 생각하였습니다.  \n\n스프링 컨테이너 차원에서는 엔터프라이즈 개발에 적합하게 수많은 객체 생명주기를 관리 하고 의존 관계를 설정해주고 그 외 많은 기능들을 제공하여 개발자는 비지니스 로직에 집중 할 수 있게 해주는것이죠.\n\n### 그럼 Spring DI 무엇을 의미하는 걸까요?\n\nSpring Framework란 무엇인가? 장점은 무엇인가? 조사를 하다보면 반드시 나오는 DI입니다.  \n이녀석은 무엇일까요?? 제가 참고한 토비스프링에서 정보를 얻을 수 있었습니다.  \n\n> IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는 점이다. 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공히는 기능의 특정을 명확하게 설명하지 못한다. .. 생략 .. 몇몇 사람의 제안으로 스프링이 제공하는 IoC 방식을 핵심을 짚어주는 의존관계 주입 DependencyIniection이라는， 좀 더 의도가 명확히 드러나는 이름을 사용하 기 시작했다.\n\n위에서 말했다싶이 IoC는 객체 생명 관리, 흐름 제어를 제 3자에게 위임하는 프로그래밍 모델입니다. 디자인 패턴인 템플릿 메소드 패턴에서도 IoC 개념을 찾아 볼 수 있었죠.\n하지만 이런 디자인 패턴이 적용된 것을 가지고 Spring 에서 IoC, IoC 할까요? 좀 더 핵심적인 의미가 있지 않을까요? 그 핵심적인 의미는 DI에서 찾아 볼 수 있습니다.\n\n> 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다. 생략..  \nDI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심\n\nSpring IoC와 DI가 어떤 차이점이 있는지 명확하게 이해가 되지 않았는데 위 문구에서 찾을 수 있게 되었죠.  \n\n그리고 DI라는 말은 마틴파울러와 그 주변사람들이 모여 IoC에 범용적인 의미를 객체 주입이라는 의미를 명확히 하기 위해 만들어졌다고 합니다.  \n그냥 제어의 역전이라 하면 그 차원에서 어느 범위에서 의존성 역전일까요? 단순 객체간의 디자인패턴으로 활용하는것도 제어 역전이고 컨테이너차원에서 수많은 객체들에 의존관계를 파악하고 런타임시점에서도 다이나믹하게 객체를 주임하여 유연한 프로그래밍을 할 수 있도록 하는 패턴에 더 명확한 이름을 부여하기 위해 토론 끝에 Dependency Injection 이라는 용어를 만들었다고 합니다.[[원문]](https://www.martinfowler.com/articles/injection.html) [[번역]](https://vandbt.tistory.com/44)\n\n\n### \nDI는 IoC 프로그래밍 모델을 구현하는 방식중에 하나입니다.  \nSpring 에서는 IoC를 구체적으로 DI라는 방식을통해서 의존성 역전 제어를 하고 있는 것이죠. 우선, 용어를 하나하나 분석해 보겠습니다.\n\n**의존성**  \n프로그래밍에서 의존한다는 말은 서로 다른 객체간에 레퍼런스 참조가 되어 있다는 말입니다. 이는 A -> B에 의존 관계에 있을 때, B객체에 변경사항이 생겼을 때, A 객체가 영향을 받는 구조인 것이죠.  \n\n~~~ java\npublic class A {\n\n    private B b = new B();\n\n    public void anyMethod() {\n        b.~~\n    }\n}\n~~~\n\n**주입**\n주입이란 단어를 생각하면 주사 맞는 이미지가 연상되는데요.  \n외부로부터 객체의 주소(레퍼런스) 값을 전달 받게 되어 객체가 참조 되어지는 방식입니다.  \n\n다시 돌아와서 그럼 의존성 주입이라는 말은 어떤 말일까요? \n의존관계에 있는 객체들이 있을 때, 외부(스프링컨테이너)에서 객체에 레퍼런스를 전달하여 사용하고자 하는 객체에서 코드를 작성 할 수 있게 한다. 이런의미가 되곘네요\n\nDI에 핵심 키워드는 **외부로부터~**, **다이나믹한 의존관계** 입니다.\n\n토비스프링에서 말하는 DI (의존관계 주입)에 3가지 조건은 다음과 같습니다.\n\n- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.\n- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.\n- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.\n\n외부로부터 인터페이스타입으로 얼마든지 부품이 교체 될 수 있으니 코드가 유연해 지겠죠? 또한 의존성 제어로 인해 수많은 객체들에 의존관계를 맺어주고 개발하는 클라이언트 입장에서는 편하게 비지니스로직에 집중할 수 있다고 생각합니다. 이러한 DI를 잘 녹인 프레임워크가 스프링이라고 합니다.\n\n\n\n토비스프링에서 인용한 문구를 다시 보여드리겠습니다.\n\n> DI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심 ..생략..\n주입받는 메소드 따라미터가 이미 특정 클래스 타입으로 고정되어 있다면 DI가 일어날 수 없다. DI에서 말하는 주입은 다이내믹하게 구현 클래스를 결정해서 제공받을 수 있도록 인터페이스 타입 의 파라미터를 통해 이뤄져야 한다.\n\n**핵심은 DI는 클래스타입이 고정되어 있지 않고 인터페이스 타입의 파라미터를 통해 다이나믹하게 구현 클래스를 결정해서 제공 받을수 있어야 한다.**\n\n이것이 바로 DI에 핵심개념입니다. \n\n\n\n\n코드를 통해서 바로 알아보겠습니다.   \n\n~~~ java\npublic class IronManController {\n\n    private IronManService ironManService;\n\n    public IronManController(IronManService ironManService) {\n        this.ironManService = ironManService;\n    }\n\n    // 생략\n\n}\n~~~\n\nIronManService라는 인터페이스를 \n\n~~~ java\npublic interface IronManService {\n\n    void attack();\n    void flying();\n}\n~~~\n\n\n~~~ java\npublic class HulkBuster implements IronManService {\n\n    @Override\n    public void attack() {\n        System.out.println(\"헐크버스터 공격!\");\n    }\n    // 생략\n}\n~~~\n\n~~~ java\npublic class Mark15 implements IronManService {\n\n    @Override\n    public void attack() {\n        System.out.println(\"나노입자 아이언맨 공격!\");\n    }\n    // 생략\n}\n~~~\n\nDI라는 개념 또한 스프링에서 나온 개념이 아닙니다.\n\n\n### 그럼 IoC와 DI 무엇이 다른걸까요??\n\nIoC는 객체의 흐름, 생명주기관리등 독립적인 제 3자에게 역할과 책임을 위임하는 방식에 프로그래밍 모델입니다.  \n디자인패턴에서도 찾아볼수 있고 다른 컨테이너를 가진 프레임워크들에서도 찾아볼 수 있습니다. 범용적인 표현이죠 하지만 DI는 인터페이스를 통해 다이나믹하게 객체를 주입을 하여 유연한 프로그래밍을 가능하게 하는 패턴으로 좀 더 구첵적인 의미인것이죠.  \n","slug":"Spring/IoC, DI란 무엇일까","published":1,"updated":"2022-09-30T13:23:19.300Z","_id":"cl8oids27002pk0otxpbncnhp","comments":1,"layout":"post","photos":[],"link":"","content":"<h3><span id=\"why\">Why?</span></h3>\n<ul>\n<li>Spring 에서 DI를 잘 썼다고 하는데 어느부분에서 잘썼는지 구체적인 사례를 찾아보자</li>\n</ul>\n<h3><span id=\"목표\">목표</span></h3>\n<ul>\n<li>Spring IoC, DI가 무엇인지 이해시킨다.</li>\n<li>Spring DI에 장단점을 이해시킨다.</li>\n<li>Bean이란 무엇이고 Container에서 어떻게 관리되고 생명주기는 어떻게 되는지 이해시킨다.</li>\n</ul>\n<h3><span id=\"ioc-inversion-of-control-란-무엇인가\">IoC (Inversion of Control) 란 무엇인가?</span></h3>\n<p>IoC에 용어는 90년 중반에 GoF의 디자인패턴에서도 이용어가 언급되었다고 합니다. 즉, IoC는 Spring에서 나온 용어가 아닙니다. 과거 EJB에서도 WAS에 Servlet Container에서도 사용 된 개념이죠.</p>\n<p>IoC에 대한 개념은 굉장히 폭이 넓습니다.<br>\n해석하면 제어의 역전입니다. 도대체 어떤 제어를 말하는 것이며 무엇을 역전한다는 말 일까요??</p>\n<p>아래 코드부터 바로 보시죠</p>\n<p>아래는 개발자가 직접 객체를 생성하여 코드를 제어하는 코드입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">        b </span>= <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와 같이 B클래스를 직접 인스턴스하여 의존관계를 나타내고 있습니다. 즉 개발자가 직접 객체를 제어하여 A객체는 B객체에게 의존하고 있어 라고 클래스를 통해 표현하고 있는것 이죠</p>\n<p>이것은 개발자가 직접 한 것입니다. 하지만 아래 코드는 어떨까요??</p>\n<p>컨테이너에 의해서 생성한 객체를 사용만 하는 코드</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>스프링 사용자라면 잘알고 있는 표현입니다.<br>\nB라는 객체가 스프링 컨테이너에게 관리되고 있는 Bean이라면 @Autowired 를 통해 객체를 주입받을수 있게 되죠<br>\n이것은 개발자가 직접 객체를 관리하지 않고 스프링 컨테이너에서 직접(제어) 객체를 생성하여 해당 객체에 주입 시켜준 것입니다.</p>\n<p>이것이 바로 제어가 역전되었다. IoC 라는 개념입니다. 또 다른 예를 들어볼까요??</p>\n<p>디자인패턴인 템플릿 메소드 패턴에서도 IoC 개념을 찾아 볼 수 있습니다. 이처럼 IoC는 거시적인 개념이 아닌 프로그램을 제어권을 누가 가져갈것인가에 대한 프로그래밍 모델일 뿐입니다. 아래 코드를 한번 보죠</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IronMan ironMan;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">getIronMan</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> assemble();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 제어권은 상위 클래스에게 있다.</span></span><br><span class=\"line\"><span class=\"comment\">     * 하위 클래스에서 구현한 코드는 상위 클래스가 어떻게 되는지 모른다. 단지 구현해야하는 부분을  </span></span><br><span class=\"line\"><span class=\"comment\">    **/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> IronMan <span class=\"title\">assemble</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do assemble.. from head, body, arms, legs</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">head</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">body</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">arms</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">legs</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> classs HulkBuster extends IronFactory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">head</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">body</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">arms</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">legs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>제어권은 상위 클래스인 IronFactory에게 있습니다.<br>\n하위 클래스에서 구현한 코드는 상위 클래스가 어떻게 되는지 모릅니다. 단지 구현해야하는 부분을 구현하였고 구현한 코드가 언제 어떻게 실행 될지는 모릅니다. 상위 클래스에서 알아서 필요할 때 구현한 메소드를 사용하게 됩니다. 바로 이처럼 코드 흐름이 제3자에게 위임되는 것이 IoC 모델이라고 합니다.</p>\n<h3><span id=\"그럼-왜-ioc를-spring에서-사용-하였을까요-분명히-이점이-있을텐데요\">그럼 왜 IoC를 Spring에서 사용 하였을까요? 분명히 이점이 있을텐데요</span></h3>\n<p>IoC는 Spring에서만 사용되는 개념이 아닙니다. 프로그래밍 패턴이기때문에 범용적으로 쓰이며 작게는 객체간에 디자인 패턴으로 크게는 컨테이너, 프레임워크 역할에 적합한 구조이기 때문에 상황에 맞게 사용되는 프로그래밍 모델인 것이죠. Spring은 Framework입니다. 그렇기 때문에 흐름을 직접 핸들링 해줘야 하는것이고 자연스럽게 적합한 모델, 패턴을 적용해야 했고 그래서 Framework에 적합한 IoC, DI 개념 모델이 들어가게 된것이조.</p>\n<p>그럼 이점은 무엇이 있을까요?<br>\nIoC 프로그램 모델은 곧 역할과 책임에 분리라는 내용과 관련이 있다고 생각합니다.<br>\n왜 내가 직접 객체를 제어 하지 않고 다른 제 3자가 제어를 위임하게 하고 나는 수동적으로 따라가는 길을 택하였을까요??</p>\n<p>이는 객체지향 프로그래밍과 아주 관련이 깊다고 생각합니다. 객체지향 프로그래밍은 각 객체마다 자기의 역할과 책임을 온전히 다하며 서로 협력하며 변경에 유연한 프로그래밍을 할 수 있는 프로그래밍 기법입니다. 즉, 각 객체마다 올바른 캡슐화를 통해 높은 응집도와 낮은 결합도를 이루어나가는 것이 핵심중에 핵심이죠.</p>\n<p>이러한 관점에서 제어의 역전으로 인해 제 3자 즉 다른 객체, 다른 컨테이너에게 제어에 대한 역할과 책임을 위임하고 다시말해 신경쓰지 않고 지금 내가 하고자 하는 역할과 책임에 관심이 있는것이죠. 왜 이렇게 할까요? 답은 <strong>변경에 유연한 코드 구조를 가져가기 위해서</strong>입니다. 내가 작성하고자 하는 코드에서 객체를 생성, 소멸 등에 관리 코드와 함께 비지니스 코드까지 들어가면 어떨까요??</p>\n<p>기능은 얼마든지 변경될 수 있습니다. 자, A라는 객체를 생성하고 있었는데 A객체는 삭제하고 B객체를 추가해야 한다고 하면 어떻게 될까요?? 뭐 한 곳에서만 객체 생성을 추가했다면 한 곳에서만 변경하면 되겠죠… 그럼 10곳에서 A라는 객체를 사용하였다고 해보죠. 그럼 10번을 수정해줘야 겠네요?</p>\n<p>또 다른 예를 들어보죠. 객체 생명 주기를 직접 관리하기 때문에 객체 생성, 삭제를 직접 할 수 있습니다. 근데 도메인 모델상 객체 삭제는 절대 하면 안된다고 해보죠. 하지만 직접 개발자가 객체를 핸들링 할 수 있기 때문에 삭제하거나 아니면 새로운 객체를 생성 할 수 도 있습니다. 다시 말해서 권한이 너무 많다는 것입니다. 이것은 곧 캡슐화 위반을 일으킨 것입니다.</p>\n<p><strong>엔터프라이즈 차원에서 수많은 객체들을 편리하게 관리하기 위함입니다.</strong></p>\n<p>현재 설명한 객체는 등장한것이 2~3개 밖에 되지 않습니다.<br>\n각 객체마다 협력을 하다보면 IoC역할을 하는 객체들이 계속 생길수 있습니다. 그럼 개발자는 그런 IoC 역할을 하는 객체를 계속 알고 개발을 해야 합니다.<br>\n1~2개는 괜찮겠죠 하지만 개발하다 보면 또 유지보수 하다보면 객체를 계속 생길수 있습니다. 요구사항이 변하니까요.</p>\n<p>그래서 스프링은 Application Context 로 모든 객체를 일괄 관리하는 IoC를 Wrapping 하는 개념이라 할까요? 아무튼 그렇게 보따리 해서 컨테이너가 되어 객체에 의존관계 주입, 객체 생명 주기 관리, 그 밖에 아직 제가 알지 못하는 영역에서 많은 유용한일을 담당 할 것입니다.</p>\n<p><strong>자 그럼 질문을 다시 해보겠습니다. IoC 왜 제어를 역전 시켰을까요? 어떤 이점일까요?</strong></p>\n<p>객체를 관리해주는 독립적인 존재 (거시적으로는 컨테이너, 미시적으로는 디지인패턴적용)와 그 외 내가 구현 하고자 하는 부분으로 각각 관심을 분리하고 서로에 역할을 충실히하면서 변경에 유연한 코드를 작성 할 수 있는 구조이기 때문에 제어를 역전 하였다. 저는 이렇게 생각하였습니다.</p>\n<p>스프링 컨테이너 차원에서는 엔터프라이즈 개발에 적합하게 수많은 객체 생명주기를 관리 하고 의존 관계를 설정해주고 그 외 많은 기능들을 제공하여 개발자는 비지니스 로직에 집중 할 수 있게 해주는것이죠.</p>\n<h3><span id=\"그럼-spring-di-무엇을-의미하는-걸까요\">그럼 Spring DI 무엇을 의미하는 걸까요?</span></h3>\n<p>Spring Framework란 무엇인가? 장점은 무엇인가? 조사를 하다보면 반드시 나오는 DI입니다.<br>\n이녀석은 무엇일까요?? 제가 참고한 토비스프링에서 정보를 얻을 수 있었습니다.</p>\n<blockquote>\n<p>IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는 점이다. 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공히는 기능의 특정을 명확하게 설명하지 못한다. … 생략 … 몇몇 사람의 제안으로 스프링이 제공하는 IoC 방식을 핵심을 짚어주는 의존관계 주입 DependencyIniection이라는， 좀 더 의도가 명확히 드러나는 이름을 사용하 기 시작했다.</p>\n</blockquote>\n<p>위에서 말했다싶이 IoC는 객체 생명 관리, 흐름 제어를 제 3자에게 위임하는 프로그래밍 모델입니다. 디자인 패턴인 템플릿 메소드 패턴에서도 IoC 개념을 찾아 볼 수 있었죠.<br>\n하지만 이런 디자인 패턴이 적용된 것을 가지고 Spring 에서 IoC, IoC 할까요? 좀 더 핵심적인 의미가 있지 않을까요? 그 핵심적인 의미는 DI에서 찾아 볼 수 있습니다.</p>\n<blockquote>\n<p>스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다. 생략…<br>\nDI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심</p>\n</blockquote>\n<p>Spring IoC와 DI가 어떤 차이점이 있는지 명확하게 이해가 되지 않았는데 위 문구에서 찾을 수 있게 되었죠.</p>\n<p>그리고 DI라는 말은 마틴파울러와 그 주변사람들이 모여 IoC에 범용적인 의미를 객체 주입이라는 의미를 명확히 하기 위해 만들어졌다고 합니다.<br>\n그냥 제어의 역전이라 하면 그 차원에서 어느 범위에서 의존성 역전일까요? 단순 객체간의 디자인패턴으로 활용하는것도 제어 역전이고 컨테이너차원에서 수많은 객체들에 의존관계를 파악하고 런타임시점에서도 다이나믹하게 객체를 주임하여 유연한 프로그래밍을 할 수 있도록 하는 패턴에 더 명확한 이름을 부여하기 위해 토론 끝에 Dependency Injection 이라는 용어를 만들었다고 합니다.<a href=\"https://www.martinfowler.com/articles/injection.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">[원문]</a> <a href=\"https://vandbt.tistory.com/44\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">[번역]</a></p>\n<h3><span id=\"\"></span></h3>\n<p>DI는 IoC 프로그래밍 모델을 구현하는 방식중에 하나입니다.<br>\nSpring 에서는 IoC를 구체적으로 DI라는 방식을통해서 의존성 역전 제어를 하고 있는 것이죠. 우선, 용어를 하나하나 분석해 보겠습니다.</p>\n<p><strong>의존성</strong><br>\n프로그래밍에서 의존한다는 말은 서로 다른 객체간에 레퍼런스 참조가 되어 있다는 말입니다. 이는 A -&gt; B에 의존 관계에 있을 때, B객체에 변경사항이 생겼을 때, A 객체가 영향을 받는 구조인 것이죠.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> B b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">anyMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        b.~~</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>주입</strong><br>\n주입이란 단어를 생각하면 주사 맞는 이미지가 연상되는데요.<br>\n외부로부터 객체의 주소(레퍼런스) 값을 전달 받게 되어 객체가 참조 되어지는 방식입니다.</p>\n<p>다시 돌아와서 그럼 의존성 주입이라는 말은 어떤 말일까요?<br>\n의존관계에 있는 객체들이 있을 때, 외부(스프링컨테이너)에서 객체에 레퍼런스를 전달하여 사용하고자 하는 객체에서 코드를 작성 할 수 있게 한다. 이런의미가 되곘네요</p>\n<p>DI에 핵심 키워드는 <strong>외부로부터~</strong>, <strong>다이나믹한 의존관계</strong> 입니다.</p>\n<p>토비스프링에서 말하는 DI (의존관계 주입)에 3가지 조건은 다음과 같습니다.</p>\n<ul>\n<li>클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.</li>\n<li>런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.</li>\n<li>의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.</li>\n</ul>\n<p>외부로부터 인터페이스타입으로 얼마든지 부품이 교체 될 수 있으니 코드가 유연해 지겠죠? 또한 의존성 제어로 인해 수많은 객체들에 의존관계를 맺어주고 개발하는 클라이언트 입장에서는 편하게 비지니스로직에 집중할 수 있다고 생각합니다. 이러한 DI를 잘 녹인 프레임워크가 스프링이라고 합니다.</p>\n<p>토비스프링에서 인용한 문구를 다시 보여드리겠습니다.</p>\n<blockquote>\n<p>DI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심 …생략…<br>\n주입받는 메소드 따라미터가 이미 특정 클래스 타입으로 고정되어 있다면 DI가 일어날 수 없다. DI에서 말하는 주입은 다이내믹하게 구현 클래스를 결정해서 제공받을 수 있도록 인터페이스 타입 의 파라미터를 통해 이뤄져야 한다.</p>\n</blockquote>\n<p><strong>핵심은 DI는 클래스타입이 고정되어 있지 않고 인터페이스 타입의 파라미터를 통해 다이나믹하게 구현 클래스를 결정해서 제공 받을수 있어야 한다.</strong></p>\n<p>이것이 바로 DI에 핵심개념입니다.</p>\n<p>코드를 통해서 바로 알아보겠습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronManController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IronManService ironManService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IronManController</span><span class=\"params\">(IronManService ironManService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ironManService = ironManService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 생략</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>IronManService라는 인터페이스를</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IronManService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attack</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flying</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HulkBuster</span> <span class=\"keyword\">implements</span> <span class=\"title\">IronManService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"헐크버스터 공격!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 생략</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mark15</span> <span class=\"keyword\">implements</span> <span class=\"title\">IronManService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"나노입자 아이언맨 공격!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 생략</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DI라는 개념 또한 스프링에서 나온 개념이 아닙니다.</p>\n<h3><span id=\"그럼-ioc와-di-무엇이-다른걸까요\">그럼 IoC와 DI 무엇이 다른걸까요??</span></h3>\n<p>IoC는 객체의 흐름, 생명주기관리등 독립적인 제 3자에게 역할과 책임을 위임하는 방식에 프로그래밍 모델입니다.<br>\n디자인패턴에서도 찾아볼수 있고 다른 컨테이너를 가진 프레임워크들에서도 찾아볼 수 있습니다. 범용적인 표현이죠 하지만 DI는 인터페이스를 통해 다이나믹하게 객체를 주입을 하여 유연한 프로그래밍을 가능하게 하는 패턴으로 좀 더 구첵적인 의미인것이죠.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>Why?</h3>\n<ul>\n<li>Spring 에서 DI를 잘 썼다고 하는데 어느부분에서 잘썼는지 구체적인 사례를 찾아보자</li>\n</ul>\n<h3>목표</h3>\n<ul>\n<li>Spring IoC, DI가 무엇인지 이해시킨다.</li>\n<li>Spring DI에 장단점을 이해시킨다.</li>\n<li>Bean이란 무엇이고 Container에서 어떻게 관리되고 생명주기는 어떻게 되는지 이해시킨다.</li>\n</ul>\n<h3>IoC (Inversion of Control) 란 무엇인가?</h3>\n<p>IoC에 용어는 90년 중반에 GoF의 디자인패턴에서도 이용어가 언급되었다고 합니다. 즉, IoC는 Spring에서 나온 용어가 아닙니다. 과거 EJB에서도 WAS에 Servlet Container에서도 사용 된 개념이죠.</p>\n<p>IoC에 대한 개념은 굉장히 폭이 넓습니다.<br>\n해석하면 제어의 역전입니다. 도대체 어떤 제어를 말하는 것이며 무엇을 역전한다는 말 일까요??</p>\n<p>아래 코드부터 바로 보시죠</p>\n<p>아래는 개발자가 직접 객체를 생성하여 코드를 제어하는 코드입니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">A</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">        b </span>= <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>위와 같이 B클래스를 직접 인스턴스하여 의존관계를 나타내고 있습니다. 즉 개발자가 직접 객체를 제어하여 A객체는 B객체에게 의존하고 있어 라고 클래스를 통해 표현하고 있는것 이죠</p>\n<p>이것은 개발자가 직접 한 것입니다. 하지만 아래 코드는 어떨까요??</p>\n<p>컨테이너에 의해서 생성한 객체를 사용만 하는 코드</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> B b;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>스프링 사용자라면 잘알고 있는 표현입니다.<br>\nB라는 객체가 스프링 컨테이너에게 관리되고 있는 Bean이라면 @Autowired 를 통해 객체를 주입받을수 있게 되죠<br>\n이것은 개발자가 직접 객체를 관리하지 않고 스프링 컨테이너에서 직접(제어) 객체를 생성하여 해당 객체에 주입 시켜준 것입니다.</p>\n<p>이것이 바로 제어가 역전되었다. IoC 라는 개념입니다. 또 다른 예를 들어볼까요??</p>\n<p>디자인패턴인 템플릿 메소드 패턴에서도 IoC 개념을 찾아 볼 수 있습니다. 이처럼 IoC는 거시적인 개념이 아닌 프로그램을 제어권을 누가 가져갈것인가에 대한 프로그래밍 모델일 뿐입니다. 아래 코드를 한번 보죠</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronFactory</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IronMan ironMan;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> IronMan <span class=\"title\">getIronMan</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> assemble();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 제어권은 상위 클래스에게 있다.</span></span><br><span class=\"line\"><span class=\"comment\">     * 하위 클래스에서 구현한 코드는 상위 클래스가 어떻게 되는지 모른다. 단지 구현해야하는 부분을  </span></span><br><span class=\"line\"><span class=\"comment\">    **/</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> IronMan <span class=\"title\">assemble</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do assemble.. from head, body, arms, legs</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> ironMan;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">head</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">body</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">arms</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">legs</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> classs HulkBuster extends IronFactory &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">head</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">body</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">arms</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">legs</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// do something..</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>제어권은 상위 클래스인 IronFactory에게 있습니다.<br>\n하위 클래스에서 구현한 코드는 상위 클래스가 어떻게 되는지 모릅니다. 단지 구현해야하는 부분을 구현하였고 구현한 코드가 언제 어떻게 실행 될지는 모릅니다. 상위 클래스에서 알아서 필요할 때 구현한 메소드를 사용하게 됩니다. 바로 이처럼 코드 흐름이 제3자에게 위임되는 것이 IoC 모델이라고 합니다.</p>\n<h3>그럼 왜 IoC를 Spring에서 사용 하였을까요? 분명히 이점이 있을텐데요</h3>\n<p>IoC는 Spring에서만 사용되는 개념이 아닙니다. 프로그래밍 패턴이기때문에 범용적으로 쓰이며 작게는 객체간에 디자인 패턴으로 크게는 컨테이너, 프레임워크 역할에 적합한 구조이기 때문에 상황에 맞게 사용되는 프로그래밍 모델인 것이죠. Spring은 Framework입니다. 그렇기 때문에 흐름을 직접 핸들링 해줘야 하는것이고 자연스럽게 적합한 모델, 패턴을 적용해야 했고 그래서 Framework에 적합한 IoC, DI 개념 모델이 들어가게 된것이조.</p>\n<p>그럼 이점은 무엇이 있을까요?<br>\nIoC 프로그램 모델은 곧 역할과 책임에 분리라는 내용과 관련이 있다고 생각합니다.<br>\n왜 내가 직접 객체를 제어 하지 않고 다른 제 3자가 제어를 위임하게 하고 나는 수동적으로 따라가는 길을 택하였을까요??</p>\n<p>이는 객체지향 프로그래밍과 아주 관련이 깊다고 생각합니다. 객체지향 프로그래밍은 각 객체마다 자기의 역할과 책임을 온전히 다하며 서로 협력하며 변경에 유연한 프로그래밍을 할 수 있는 프로그래밍 기법입니다. 즉, 각 객체마다 올바른 캡슐화를 통해 높은 응집도와 낮은 결합도를 이루어나가는 것이 핵심중에 핵심이죠.</p>\n<p>이러한 관점에서 제어의 역전으로 인해 제 3자 즉 다른 객체, 다른 컨테이너에게 제어에 대한 역할과 책임을 위임하고 다시말해 신경쓰지 않고 지금 내가 하고자 하는 역할과 책임에 관심이 있는것이죠. 왜 이렇게 할까요? 답은 <strong>변경에 유연한 코드 구조를 가져가기 위해서</strong>입니다. 내가 작성하고자 하는 코드에서 객체를 생성, 소멸 등에 관리 코드와 함께 비지니스 코드까지 들어가면 어떨까요??</p>\n<p>기능은 얼마든지 변경될 수 있습니다. 자, A라는 객체를 생성하고 있었는데 A객체는 삭제하고 B객체를 추가해야 한다고 하면 어떻게 될까요?? 뭐 한 곳에서만 객체 생성을 추가했다면 한 곳에서만 변경하면 되겠죠… 그럼 10곳에서 A라는 객체를 사용하였다고 해보죠. 그럼 10번을 수정해줘야 겠네요?</p>\n<p>또 다른 예를 들어보죠. 객체 생명 주기를 직접 관리하기 때문에 객체 생성, 삭제를 직접 할 수 있습니다. 근데 도메인 모델상 객체 삭제는 절대 하면 안된다고 해보죠. 하지만 직접 개발자가 객체를 핸들링 할 수 있기 때문에 삭제하거나 아니면 새로운 객체를 생성 할 수 도 있습니다. 다시 말해서 권한이 너무 많다는 것입니다. 이것은 곧 캡슐화 위반을 일으킨 것입니다.</p>\n<p><strong>엔터프라이즈 차원에서 수많은 객체들을 편리하게 관리하기 위함입니다.</strong></p>\n<p>현재 설명한 객체는 등장한것이 2~3개 밖에 되지 않습니다.<br>\n각 객체마다 협력을 하다보면 IoC역할을 하는 객체들이 계속 생길수 있습니다. 그럼 개발자는 그런 IoC 역할을 하는 객체를 계속 알고 개발을 해야 합니다.<br>\n1~2개는 괜찮겠죠 하지만 개발하다 보면 또 유지보수 하다보면 객체를 계속 생길수 있습니다. 요구사항이 변하니까요.</p>\n<p>그래서 스프링은 Application Context 로 모든 객체를 일괄 관리하는 IoC를 Wrapping 하는 개념이라 할까요? 아무튼 그렇게 보따리 해서 컨테이너가 되어 객체에 의존관계 주입, 객체 생명 주기 관리, 그 밖에 아직 제가 알지 못하는 영역에서 많은 유용한일을 담당 할 것입니다.</p>\n<p><strong>자 그럼 질문을 다시 해보겠습니다. IoC 왜 제어를 역전 시켰을까요? 어떤 이점일까요?</strong></p>\n<p>객체를 관리해주는 독립적인 존재 (거시적으로는 컨테이너, 미시적으로는 디지인패턴적용)와 그 외 내가 구현 하고자 하는 부분으로 각각 관심을 분리하고 서로에 역할을 충실히하면서 변경에 유연한 코드를 작성 할 수 있는 구조이기 때문에 제어를 역전 하였다. 저는 이렇게 생각하였습니다.</p>\n<p>스프링 컨테이너 차원에서는 엔터프라이즈 개발에 적합하게 수많은 객체 생명주기를 관리 하고 의존 관계를 설정해주고 그 외 많은 기능들을 제공하여 개발자는 비지니스 로직에 집중 할 수 있게 해주는것이죠.</p>\n<h3>그럼 Spring DI 무엇을 의미하는 걸까요?</h3>\n<p>Spring Framework란 무엇인가? 장점은 무엇인가? 조사를 하다보면 반드시 나오는 DI입니다.<br>\n이녀석은 무엇일까요?? 제가 참고한 토비스프링에서 정보를 얻을 수 있었습니다.</p>\n<blockquote>\n<p>IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어라는 점이다. 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공히는 기능의 특정을 명확하게 설명하지 못한다. … 생략 … 몇몇 사람의 제안으로 스프링이 제공하는 IoC 방식을 핵심을 짚어주는 의존관계 주입 DependencyIniection이라는， 좀 더 의도가 명확히 드러나는 이름을 사용하 기 시작했다.</p>\n</blockquote>\n<p>위에서 말했다싶이 IoC는 객체 생명 관리, 흐름 제어를 제 3자에게 위임하는 프로그래밍 모델입니다. 디자인 패턴인 템플릿 메소드 패턴에서도 IoC 개념을 찾아 볼 수 있었죠.<br>\n하지만 이런 디자인 패턴이 적용된 것을 가지고 Spring 에서 IoC, IoC 할까요? 좀 더 핵심적인 의미가 있지 않을까요? 그 핵심적인 의미는 DI에서 찾아 볼 수 있습니다.</p>\n<blockquote>\n<p>스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다. 생략…<br>\nDI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심</p>\n</blockquote>\n<p>Spring IoC와 DI가 어떤 차이점이 있는지 명확하게 이해가 되지 않았는데 위 문구에서 찾을 수 있게 되었죠.</p>\n<p>그리고 DI라는 말은 마틴파울러와 그 주변사람들이 모여 IoC에 범용적인 의미를 객체 주입이라는 의미를 명확히 하기 위해 만들어졌다고 합니다.<br>\n그냥 제어의 역전이라 하면 그 차원에서 어느 범위에서 의존성 역전일까요? 단순 객체간의 디자인패턴으로 활용하는것도 제어 역전이고 컨테이너차원에서 수많은 객체들에 의존관계를 파악하고 런타임시점에서도 다이나믹하게 객체를 주임하여 유연한 프로그래밍을 할 수 있도록 하는 패턴에 더 명확한 이름을 부여하기 위해 토론 끝에 Dependency Injection 이라는 용어를 만들었다고 합니다.<a href=\"https://www.martinfowler.com/articles/injection.html\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">[원문]</a> <a href=\"https://vandbt.tistory.com/44\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">[번역]</a></p>\n<h3></h3>\n<p>DI는 IoC 프로그래밍 모델을 구현하는 방식중에 하나입니다.<br>\nSpring 에서는 IoC를 구체적으로 DI라는 방식을통해서 의존성 역전 제어를 하고 있는 것이죠. 우선, 용어를 하나하나 분석해 보겠습니다.</p>\n<p><strong>의존성</strong><br>\n프로그래밍에서 의존한다는 말은 서로 다른 객체간에 레퍼런스 참조가 되어 있다는 말입니다. 이는 A -&gt; B에 의존 관계에 있을 때, B객체에 변경사항이 생겼을 때, A 객체가 영향을 받는 구조인 것이죠.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> B b = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">anyMethod</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        b.~~</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>주입</strong><br>\n주입이란 단어를 생각하면 주사 맞는 이미지가 연상되는데요.<br>\n외부로부터 객체의 주소(레퍼런스) 값을 전달 받게 되어 객체가 참조 되어지는 방식입니다.</p>\n<p>다시 돌아와서 그럼 의존성 주입이라는 말은 어떤 말일까요?<br>\n의존관계에 있는 객체들이 있을 때, 외부(스프링컨테이너)에서 객체에 레퍼런스를 전달하여 사용하고자 하는 객체에서 코드를 작성 할 수 있게 한다. 이런의미가 되곘네요</p>\n<p>DI에 핵심 키워드는 <strong>외부로부터~</strong>, <strong>다이나믹한 의존관계</strong> 입니다.</p>\n<p>토비스프링에서 말하는 DI (의존관계 주입)에 3가지 조건은 다음과 같습니다.</p>\n<ul>\n<li>클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.</li>\n<li>런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.</li>\n<li>의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.</li>\n</ul>\n<p>외부로부터 인터페이스타입으로 얼마든지 부품이 교체 될 수 있으니 코드가 유연해 지겠죠? 또한 의존성 제어로 인해 수많은 객체들에 의존관계를 맺어주고 개발하는 클라이언트 입장에서는 편하게 비지니스로직에 집중할 수 있다고 생각합니다. 이러한 DI를 잘 녹인 프레임워크가 스프링이라고 합니다.</p>\n<p>토비스프링에서 인용한 문구를 다시 보여드리겠습니다.</p>\n<blockquote>\n<p>DI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심 …생략…<br>\n주입받는 메소드 따라미터가 이미 특정 클래스 타입으로 고정되어 있다면 DI가 일어날 수 없다. DI에서 말하는 주입은 다이내믹하게 구현 클래스를 결정해서 제공받을 수 있도록 인터페이스 타입 의 파라미터를 통해 이뤄져야 한다.</p>\n</blockquote>\n<p><strong>핵심은 DI는 클래스타입이 고정되어 있지 않고 인터페이스 타입의 파라미터를 통해 다이나믹하게 구현 클래스를 결정해서 제공 받을수 있어야 한다.</strong></p>\n<p>이것이 바로 DI에 핵심개념입니다.</p>\n<p>코드를 통해서 바로 알아보겠습니다.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IronManController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> IronManService ironManService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">IronManController</span><span class=\"params\">(IronManService ironManService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ironManService = ironManService;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 생략</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>IronManService라는 인터페이스를</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">IronManService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">attack</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">flying</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HulkBuster</span> <span class=\"keyword\">implements</span> <span class=\"title\">IronManService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"헐크버스터 공격!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 생략</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mark15</span> <span class=\"keyword\">implements</span> <span class=\"title\">IronManService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">attack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"나노입자 아이언맨 공격!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 생략</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>DI라는 개념 또한 스프링에서 나온 개념이 아닙니다.</p>\n<h3>그럼 IoC와 DI 무엇이 다른걸까요??</h3>\n<p>IoC는 객체의 흐름, 생명주기관리등 독립적인 제 3자에게 역할과 책임을 위임하는 방식에 프로그래밍 모델입니다.<br>\n디자인패턴에서도 찾아볼수 있고 다른 컨테이너를 가진 프레임워크들에서도 찾아볼 수 있습니다. 범용적인 표현이죠 하지만 DI는 인터페이스를 통해 다이나믹하게 객체를 주입을 하여 유연한 프로그래밍을 가능하게 하는 패턴으로 좀 더 구첵적인 의미인것이죠.</p>\n"},{"title":"Spring AOP 적용시 주의사항","catalog":true,"date":"2018-12-03T16:03:21.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["Spring"],"_content":"\n\n## 기반개념\n---\n1.Componet Scan\n2.Root-context, servlet-context\n3.Spring AOP 방식\n\n\n## 현상\n---\n1.point cut excution 패턴 적용 하였지만 특정 패키지에서만 동작이 되고 Scheduled 사용된 클래스에서는 AOP 적용, 즉 트랜잭션 rollback이 안됨\n2.exception 발생시 catch 문에서 기존 동작 rollback하고 오류에 대한 insert를 하려 하는데 insert 까지 같이 rollback 됨\n\n## 원인\n---\n1.클래스내 모든 메소드가 private 메소드는 AOP 대상이 아님  [참고](https://goo.gl/rQnG4w)\n2.Spring AOP와 소스내 트랜잭션 rollback과 충돌 및 겹침 [참고](https://goo.gl/reS6sF)\n\n## 해결\n---\n1번 원인만 해결하면 된다면 특정 메소드 public으로 바꿔주면 해결된다. 대신 exception 발생시 무조건 rollback 된다. 정확히 말해서 해당 service단 클래스에서 완전히 throw해주어야 rollback이 된다.\n\n하지만 특정시점까지만 rollback 하고 그다움부턴 정상 commit 하고 싶은경우도 분명히 존재한다. 현상 2처럼 말이다. 그럴땐 Spring AOP 방식을 적용하지 않게 해야 한다. 안그러면 원인 2 처럼 되어 모두 rollback 이 되어 버린다.\n\n따라서 원인 2를 해결하려면 모두 메소드를 private으로 바꾸고 소스내에서 commit / rollback 을 수행하면 된다.\n\n\n## 코드\n~~~java\n\n*** 생략\n\ntry {\n  for (Map<String, Object> map : mBatchList) {\n\n  // 서비스별 dataSource 정보 갱신\n  bds = mDbConnMng.reNewDataSource(map.get(\"driver\").toString(), map.get(\"url\").toString(),map.get(\"username\").toString(),map.get(\"password\").toString());\n\n  // session open\n  session = mDbConnMng.openSession(false);\n\n  // mapper 호출\n  dao = session.getMapper(TransDataDao.class);\n\n  // ###### case 1 ######\n  /***************************************************************\n  // 해당 클래스 메소드 모두 private --> update 정상 동작\n  // 해당 클래스 메소드 한개 이상 public --> update 도 rollback 됨\n  // 정리하면\n  // Spring AOP Transaction 걸었는데 메소드내 트랜잭션 가져오면 충돌 나서 함수단위로 rollback이 안됨..\n  // 메소드내 트랜잭션 가져오려면 해당 클래스내 메소드를 모두 private로 해야 함..\n  // 반대로 Spring AOP Transaction 걸려면 public 메소드가 한개라도 있어야 함\n  ***************************************************************/\n\n  insertFirstData();\n  session.close();\n  }\n}catch (Exception e) {\n  throw e;\n}\n\nprivate void insertFirstData () throws Exception{\n\n  // ##### case 4 ###### worker 메소드 private으로 바꿈 (모든 메소드 private 이어야 함)\n  DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n  def.setName(\"insert tx\");\n  def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n  TransactionStatus status = iCalDbConnection.getTransaction(def);\n\n  try {\n    int result = loadDataDao.insertData();\n    if(true) {\n      throw new Exception();\n    }\n    iCalDbConnection.commit(status);\n  } catch (Exception e) {\n    iCalDbConnection.rollback(status);\n    updateTest();\n    throw e;\n  }\n}\n\nprivate void updateTest() throws Exception{\n  int result = loadDataDao.updateTest();\n}\n\n\n\n\n// console log\n13:49:50 INFO {call SET_CAL_BISMALLLITE_INSERT() } // rollback 대상\n13:49:50 INFO |-------|\n13:49:50 INFO |RESULT |\n13:49:50 INFO |-------|\n13:49:50 INFO |1 |\n13:49:50 INFO |-------|\n13:49:52 INFO {call SP_SET_BATCH_LOG_UPDATE('F', 4, 0, 'N', 'ERR_CD!!!', 'ERROR 발생!!!!!!!') }  // insert/update 대상\n13:49:52 INFO |-------|\n13:49:52 INFO |result |\n13:49:52 INFO |-------|\n13:49:52 INFO |1 |\n13:49:52 INFO |-------|\n~~~\n\n\n## 공부해야 할 개념\n---\n1.Spring AOP 동작 방식\n","source":"_posts/Spring/Spring AOP 적용시 주의사항.md","raw":"---\ntitle: Spring AOP 적용시 주의사항\ncatalog: true\ndate: 2018-12-04 01:03:21\nsubtitle:\nheader-img: \"bg_computer.jpg\"\ntags:\n- Framework\n- Spring\ncatagories:\n- Spring\n---\n\n\n## 기반개념\n---\n1.Componet Scan\n2.Root-context, servlet-context\n3.Spring AOP 방식\n\n\n## 현상\n---\n1.point cut excution 패턴 적용 하였지만 특정 패키지에서만 동작이 되고 Scheduled 사용된 클래스에서는 AOP 적용, 즉 트랜잭션 rollback이 안됨\n2.exception 발생시 catch 문에서 기존 동작 rollback하고 오류에 대한 insert를 하려 하는데 insert 까지 같이 rollback 됨\n\n## 원인\n---\n1.클래스내 모든 메소드가 private 메소드는 AOP 대상이 아님  [참고](https://goo.gl/rQnG4w)\n2.Spring AOP와 소스내 트랜잭션 rollback과 충돌 및 겹침 [참고](https://goo.gl/reS6sF)\n\n## 해결\n---\n1번 원인만 해결하면 된다면 특정 메소드 public으로 바꿔주면 해결된다. 대신 exception 발생시 무조건 rollback 된다. 정확히 말해서 해당 service단 클래스에서 완전히 throw해주어야 rollback이 된다.\n\n하지만 특정시점까지만 rollback 하고 그다움부턴 정상 commit 하고 싶은경우도 분명히 존재한다. 현상 2처럼 말이다. 그럴땐 Spring AOP 방식을 적용하지 않게 해야 한다. 안그러면 원인 2 처럼 되어 모두 rollback 이 되어 버린다.\n\n따라서 원인 2를 해결하려면 모두 메소드를 private으로 바꾸고 소스내에서 commit / rollback 을 수행하면 된다.\n\n\n## 코드\n~~~java\n\n*** 생략\n\ntry {\n  for (Map<String, Object> map : mBatchList) {\n\n  // 서비스별 dataSource 정보 갱신\n  bds = mDbConnMng.reNewDataSource(map.get(\"driver\").toString(), map.get(\"url\").toString(),map.get(\"username\").toString(),map.get(\"password\").toString());\n\n  // session open\n  session = mDbConnMng.openSession(false);\n\n  // mapper 호출\n  dao = session.getMapper(TransDataDao.class);\n\n  // ###### case 1 ######\n  /***************************************************************\n  // 해당 클래스 메소드 모두 private --> update 정상 동작\n  // 해당 클래스 메소드 한개 이상 public --> update 도 rollback 됨\n  // 정리하면\n  // Spring AOP Transaction 걸었는데 메소드내 트랜잭션 가져오면 충돌 나서 함수단위로 rollback이 안됨..\n  // 메소드내 트랜잭션 가져오려면 해당 클래스내 메소드를 모두 private로 해야 함..\n  // 반대로 Spring AOP Transaction 걸려면 public 메소드가 한개라도 있어야 함\n  ***************************************************************/\n\n  insertFirstData();\n  session.close();\n  }\n}catch (Exception e) {\n  throw e;\n}\n\nprivate void insertFirstData () throws Exception{\n\n  // ##### case 4 ###### worker 메소드 private으로 바꿈 (모든 메소드 private 이어야 함)\n  DefaultTransactionDefinition def = new DefaultTransactionDefinition();\n  def.setName(\"insert tx\");\n  def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n  TransactionStatus status = iCalDbConnection.getTransaction(def);\n\n  try {\n    int result = loadDataDao.insertData();\n    if(true) {\n      throw new Exception();\n    }\n    iCalDbConnection.commit(status);\n  } catch (Exception e) {\n    iCalDbConnection.rollback(status);\n    updateTest();\n    throw e;\n  }\n}\n\nprivate void updateTest() throws Exception{\n  int result = loadDataDao.updateTest();\n}\n\n\n\n\n// console log\n13:49:50 INFO {call SET_CAL_BISMALLLITE_INSERT() } // rollback 대상\n13:49:50 INFO |-------|\n13:49:50 INFO |RESULT |\n13:49:50 INFO |-------|\n13:49:50 INFO |1 |\n13:49:50 INFO |-------|\n13:49:52 INFO {call SP_SET_BATCH_LOG_UPDATE('F', 4, 0, 'N', 'ERR_CD!!!', 'ERROR 발생!!!!!!!') }  // insert/update 대상\n13:49:52 INFO |-------|\n13:49:52 INFO |result |\n13:49:52 INFO |-------|\n13:49:52 INFO |1 |\n13:49:52 INFO |-------|\n~~~\n\n\n## 공부해야 할 개념\n---\n1.Spring AOP 동작 방식\n","slug":"Spring/Spring AOP 적용시 주의사항","published":1,"updated":"2019-07-16T15:15:02.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids28002qk0ot7cko30zm","content":"<h2><span id=\"기반개념\">기반개념</span></h2>\n<hr>\n<p>1.Componet Scan<br>\n2.Root-context, servlet-context<br>\n3.Spring AOP 방식</p>\n<h2><span id=\"현상\">현상</span></h2>\n<hr>\n<p>1.point cut excution 패턴 적용 하였지만 특정 패키지에서만 동작이 되고 Scheduled 사용된 클래스에서는 AOP 적용, 즉 트랜잭션 rollback이 안됨<br>\n2.exception 발생시 catch 문에서 기존 동작 rollback하고 오류에 대한 insert를 하려 하는데 insert 까지 같이 rollback 됨</p>\n<h2><span id=\"원인\">원인</span></h2>\n<hr>\n<p>1.클래스내 모든 메소드가 private 메소드는 AOP 대상이 아님  <a href=\"https://goo.gl/rQnG4w\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">참고</a><br>\n2.Spring AOP와 소스내 트랜잭션 rollback과 충돌 및 겹침 <a href=\"https://goo.gl/reS6sF\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">참고</a></p>\n<h2><span id=\"해결\">해결</span></h2>\n<hr>\n<p>1번 원인만 해결하면 된다면 특정 메소드 public으로 바꿔주면 해결된다. 대신 exception 발생시 무조건 rollback 된다. 정확히 말해서 해당 service단 클래스에서 완전히 throw해주어야 rollback이 된다.</p>\n<p>하지만 특정시점까지만 rollback 하고 그다움부턴 정상 commit 하고 싶은경우도 분명히 존재한다. 현상 2처럼 말이다. 그럴땐 Spring AOP 방식을 적용하지 않게 해야 한다. 안그러면 원인 2 처럼 되어 모두 rollback 이 되어 버린다.</p>\n<p>따라서 원인 2를 해결하려면 모두 메소드를 private으로 바꾸고 소스내에서 commit / rollback 을 수행하면 된다.</p>\n<h2><span id=\"코드\">코드</span></h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">*** 생략</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Map&lt;String, Object&gt; map : mBatchList) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 서비스별 dataSource 정보 갱신</span></span><br><span class=\"line\">  bds = mDbConnMng.reNewDataSource(map.get(<span class=\"string\">\"driver\"</span>).toString(), map.get(<span class=\"string\">\"url\"</span>).toString(),map.get(<span class=\"string\">\"username\"</span>).toString(),map.get(<span class=\"string\">\"password\"</span>).toString());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// session open</span></span><br><span class=\"line\">  session = mDbConnMng.openSession(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// mapper 호출</span></span><br><span class=\"line\">  dao = session.getMapper(TransDataDao.class);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ###### case 1 ######</span></span><br><span class=\"line\">  <span class=\"comment\">/***************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  // 해당 클래스 메소드 모두 private --&gt; update 정상 동작</span></span><br><span class=\"line\"><span class=\"comment\">  // 해당 클래스 메소드 한개 이상 public --&gt; update 도 rollback 됨</span></span><br><span class=\"line\"><span class=\"comment\">  // 정리하면</span></span><br><span class=\"line\"><span class=\"comment\">  // Spring AOP Transaction 걸었는데 메소드내 트랜잭션 가져오면 충돌 나서 함수단위로 rollback이 안됨..</span></span><br><span class=\"line\"><span class=\"comment\">  // 메소드내 트랜잭션 가져오려면 해당 클래스내 메소드를 모두 private로 해야 함..</span></span><br><span class=\"line\"><span class=\"comment\">  // 반대로 Spring AOP Transaction 걸려면 public 메소드가 한개라도 있어야 함</span></span><br><span class=\"line\"><span class=\"comment\">  ***************************************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\">  insertFirstData();</span><br><span class=\"line\">  session.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">insertFirstData</span> <span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ##### case 4 ###### worker 메소드 private으로 바꿈 (모든 메소드 private 이어야 함)</span></span><br><span class=\"line\">  DefaultTransactionDefinition def = <span class=\"keyword\">new</span> DefaultTransactionDefinition();</span><br><span class=\"line\">  def.setName(<span class=\"string\">\"insert tx\"</span>);</span><br><span class=\"line\">  def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">  TransactionStatus status = iCalDbConnection.getTransaction(def);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = loadDataDao.insertData();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    iCalDbConnection.commit(status);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    iCalDbConnection.rollback(status);</span><br><span class=\"line\">    updateTest();</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">updateTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result = loadDataDao.updateTest();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// console log</span></span><br><span class=\"line\"><span class=\"number\">13</span>:<span class=\"number\">49</span>:<span class=\"number\">50</span> INFO &#123;<span class=\"function\">call <span class=\"title\">SET_CAL_BISMALLLITE_INSERT</span><span class=\"params\">()</span> &#125; <span class=\"comment\">// rollback 대상</span></span></span><br><span class=\"line\"><span class=\"function\">13:49:50 INFO |-------|</span></span><br><span class=\"line\"><span class=\"function\">13:49:50 INFO |RESULT |</span></span><br><span class=\"line\"><span class=\"function\">13:49:50 INFO |-------|</span></span><br><span class=\"line\"><span class=\"function\">13:49:50 INFO |1 |</span></span><br><span class=\"line\"><span class=\"function\">13:49:50 INFO |-------|</span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO </span>&#123;<span class=\"function\">call <span class=\"title\">SP_SET_BATCH_LOG_UPDATE</span><span class=\"params\">(<span class=\"string\">'F'</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"string\">'N'</span>, <span class=\"string\">'ERR_CD!!!'</span>, <span class=\"string\">'ERROR 발생!!!!!!!'</span>)</span> &#125;  <span class=\"comment\">// insert/update 대상</span></span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO |-------|</span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO |result |</span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO |-------|</span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO |1 |</span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO |-------|</span></span><br></pre></td></tr></table></figure>\n<h2><span id=\"공부해야-할-개념\">공부해야 할 개념</span></h2>\n<hr>\n<p>1.Spring AOP 동작 방식</p>\n","site":{"data":{}},"excerpt":"","more":"<h2>기반개념</h2>\n<hr>\n<p>1.Componet Scan<br>\n2.Root-context, servlet-context<br>\n3.Spring AOP 방식</p>\n<h2>현상</h2>\n<hr>\n<p>1.point cut excution 패턴 적용 하였지만 특정 패키지에서만 동작이 되고 Scheduled 사용된 클래스에서는 AOP 적용, 즉 트랜잭션 rollback이 안됨<br>\n2.exception 발생시 catch 문에서 기존 동작 rollback하고 오류에 대한 insert를 하려 하는데 insert 까지 같이 rollback 됨</p>\n<h2>원인</h2>\n<hr>\n<p>1.클래스내 모든 메소드가 private 메소드는 AOP 대상이 아님  <a href=\"https://goo.gl/rQnG4w\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">참고</a><br>\n2.Spring AOP와 소스내 트랜잭션 rollback과 충돌 및 겹침 <a href=\"https://goo.gl/reS6sF\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">참고</a></p>\n<h2>해결</h2>\n<hr>\n<p>1번 원인만 해결하면 된다면 특정 메소드 public으로 바꿔주면 해결된다. 대신 exception 발생시 무조건 rollback 된다. 정확히 말해서 해당 service단 클래스에서 완전히 throw해주어야 rollback이 된다.</p>\n<p>하지만 특정시점까지만 rollback 하고 그다움부턴 정상 commit 하고 싶은경우도 분명히 존재한다. 현상 2처럼 말이다. 그럴땐 Spring AOP 방식을 적용하지 않게 해야 한다. 안그러면 원인 2 처럼 되어 모두 rollback 이 되어 버린다.</p>\n<p>따라서 원인 2를 해결하려면 모두 메소드를 private으로 바꾸고 소스내에서 commit / rollback 을 수행하면 된다.</p>\n<h2>코드</h2>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">*** 생략</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (Map&lt;String, Object&gt; map : mBatchList) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 서비스별 dataSource 정보 갱신</span></span><br><span class=\"line\">  bds = mDbConnMng.reNewDataSource(map.get(<span class=\"string\">\"driver\"</span>).toString(), map.get(<span class=\"string\">\"url\"</span>).toString(),map.get(<span class=\"string\">\"username\"</span>).toString(),map.get(<span class=\"string\">\"password\"</span>).toString());</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// session open</span></span><br><span class=\"line\">  session = mDbConnMng.openSession(<span class=\"keyword\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// mapper 호출</span></span><br><span class=\"line\">  dao = session.getMapper(TransDataDao.class);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ###### case 1 ######</span></span><br><span class=\"line\">  <span class=\"comment\">/***************************************************************</span></span><br><span class=\"line\"><span class=\"comment\">  // 해당 클래스 메소드 모두 private --&gt; update 정상 동작</span></span><br><span class=\"line\"><span class=\"comment\">  // 해당 클래스 메소드 한개 이상 public --&gt; update 도 rollback 됨</span></span><br><span class=\"line\"><span class=\"comment\">  // 정리하면</span></span><br><span class=\"line\"><span class=\"comment\">  // Spring AOP Transaction 걸었는데 메소드내 트랜잭션 가져오면 충돌 나서 함수단위로 rollback이 안됨..</span></span><br><span class=\"line\"><span class=\"comment\">  // 메소드내 트랜잭션 가져오려면 해당 클래스내 메소드를 모두 private로 해야 함..</span></span><br><span class=\"line\"><span class=\"comment\">  // 반대로 Spring AOP Transaction 걸려면 public 메소드가 한개라도 있어야 함</span></span><br><span class=\"line\"><span class=\"comment\">  ***************************************************************/</span></span><br><span class=\"line\"></span><br><span class=\"line\">  insertFirstData();</span><br><span class=\"line\">  session.close();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">insertFirstData</span> <span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// ##### case 4 ###### worker 메소드 private으로 바꿈 (모든 메소드 private 이어야 함)</span></span><br><span class=\"line\">  DefaultTransactionDefinition def = <span class=\"keyword\">new</span> DefaultTransactionDefinition();</span><br><span class=\"line\">  def.setName(<span class=\"string\">\"insert tx\"</span>);</span><br><span class=\"line\">  def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);</span><br><span class=\"line\">  TransactionStatus status = iCalDbConnection.getTransaction(def);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = loadDataDao.insertData();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    iCalDbConnection.commit(status);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">    iCalDbConnection.rollback(status);</span><br><span class=\"line\">    updateTest();</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">updateTest</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> result = loadDataDao.updateTest();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// console log</span></span><br><span class=\"line\"><span class=\"number\">13</span>:<span class=\"number\">49</span>:<span class=\"number\">50</span> INFO &#123;<span class=\"function\">call <span class=\"title\">SET_CAL_BISMALLLITE_INSERT</span><span class=\"params\">()</span> &#125; <span class=\"comment\">// rollback 대상</span></span></span><br><span class=\"line\"><span class=\"function\">13:49:50 INFO |-------|</span></span><br><span class=\"line\"><span class=\"function\">13:49:50 INFO |RESULT |</span></span><br><span class=\"line\"><span class=\"function\">13:49:50 INFO |-------|</span></span><br><span class=\"line\"><span class=\"function\">13:49:50 INFO |1 |</span></span><br><span class=\"line\"><span class=\"function\">13:49:50 INFO |-------|</span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO </span>&#123;<span class=\"function\">call <span class=\"title\">SP_SET_BATCH_LOG_UPDATE</span><span class=\"params\">(<span class=\"string\">'F'</span>, <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"string\">'N'</span>, <span class=\"string\">'ERR_CD!!!'</span>, <span class=\"string\">'ERROR 발생!!!!!!!'</span>)</span> &#125;  <span class=\"comment\">// insert/update 대상</span></span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO |-------|</span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO |result |</span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO |-------|</span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO |1 |</span></span><br><span class=\"line\"><span class=\"function\">13:49:52 INFO |-------|</span></span><br></pre></td></tr></table></figure>\n<h2>공부해야 할 개념</h2>\n<hr>\n<p>1.Spring AOP 동작 방식</p>\n"},{"title":"2019년도 첫 실천 1월 회고","catalog":true,"subtitle":"1월 실천 성적표","header-img":"bg_computer.jpg","_content":"\n### 1월 실천 성적표\n{% asset_img \"score.png\" %}  \n\n드디어 2019년도! 나의 실천 1월 첫 성적표이다.  [깃텁 TIL](https://github.com/biggwang/TIL) 에서 작성한 하루 해야 할 체크리스트 수행 함에 따라 하루 점수를 매겨 100점 만점으로 환산하여 나타낸것이다.  (Github에 contribution을 따라해봤다.)  \n\n일단 위 색깔 음영과 같이 대부분 해야할 것을 미루지 않고 실천하였다.  정말 하기 싫은날에도 타협하지 않고 조금이라도 하자 라는 마음에 책상에 앉아 할 일을 하였고 그렇게 하루하루 하다보니 몸이 실천하고 행동하는데 익숙해져 큰 어려움이 없는것 같았다.  \n\n\n### 나의 실천 프레임워크\n{% asset_img \"1_notion.png\" %}   \n\nNotion 메모앱을 활용한 나의 1월달 실천 프레임워크이다!  1일부터 31일까지 빠짐없이 할 일을 적고 체크해 나갔다. 동기부여도 되고 실천도 잘되고 계속 활용 해야 겠다.\n\n이제, 1월달에 어떤것을 했는지 그리고 보안할 점은 무엇인지 한 번 회고해 보겠다.\n\n\n### 영어공부\n올해 목표중에 비중 있는 것중에 하나이다.   \n영문 레퍼런스 문서를 읽을때나 세미나, 컨퍼런스, 각종 프로그래밍 관련 영어 컨텐츠를 잘 이해하고 응용하고 싶은 강한 마음과 살면서 제 2외국어 하나 정해서 유창하게 말해보고 싶은 마음에 올해 큰 목표중에 하나로 정하였다.  \n\n출,퇴근 하면서 프로그래밍 관련 영어 유트브를 영어자막으로 만들고 동영상을 추출하여 폰에 넣고 수시로 듣고 shadowing을 하였고 집에서는 dictation 하였다.  \n1달간 정말 빠짐없이 계속 듣다보니 들리기는 잘 들리는거 같다. 아직 멀었지만 발음과 리듬 연음도 정리해가면서 차곡차곡 영어를 체화시키려고 노력하고 있다.  \n\n좀 더 보안할게 있다면  \n- 평소 개발 뉴스를 영어 뉴스로 봐보는 습관을 가지자는 것이다. [InfoQ](https://goo.gl/f3QTHD) 라는 개발 뉴스 사이트를 알게 됬는데 이 사이트를 이용하면 좋을 것 같다. \n- 평소 내말에 귀를 귀울여 내가 자주 사용하는 문장을 영어로 바꿔보는 것이다.\n- dictation 투자를 더 늘려야 한다.\n- commit message 영어로 작성하기\n\n### 영알남\n\"영어 알려주는 남자\" 유트브 구독중인데 영어 공부하고 있는 나로써 정말 도움이 많이 되고 있다.  \n단어, 전치사 등 학교 다닐때 뜻만 외웠지 문맥이나 상황에 따른 느낌은 없어 해석이나 의미전달이 왜 안됬는지 깨닳았기 때문이다. 실제 듣기, 읽기 할 때 상당히 도움이 되고 있다. 반복해서 꾸준히 들을 예정이다.\n\n### 코드 깔끔하게 그리고 보기좋게 작성하기 - Design patterns & Refactoring\n다른 여러 기술들 Docker, JPA, node.js, MSA, NoSQL, SPA 등 해보고 싶은게 많았지만!!  지금. 내가. 하고. 있는. 업무. 를 더 잘하기 위해서 생각하는 질문에 답이 먼저라고 판단하였고 그 답이 바로 **코드를 깔끔하고 다른 사람이 봤을때 이해하기 쉽게 작성하는 것** 이었다.  항상 더 좋은 방법이 없을까? 고민하는 나의 습관이 더 좋은 방법이 녹아들어간 코드를 만들고 더 깔끔해 졌을때 기분은 정말 많이 느꼈던 1월이었다.  \n\n실제 업무에 desigin patterns과 refactoring을 실천 하여 추후 기능을 추가 할 때도 중복을 최소화 할 수 있었고 다시한번 desigin pattern이 왜 필요하고 refacotring에 중요성을 알게 되었다.  \n\n내가 실제 사용한 desigin patterns과 refactoring을 github에 잘 정리하였는데 계속 내용을 추가 업데이트하여 실무에 잘 활용 해야 겠다.  \n- [Factory Method Pattern](https://goo.gl/4xjfVm)\n- [Template Method Pattern](https://goo.gl/fWXFpf)  \n- 그 밖에 Builder Pattern, Observer Pattern을 활용하였는데 추후 정리하여 Commit 할 예정이다.\n\n\n### TDD 실천\nTDD라고 하면 포괄적이고 거창할수 있지만, 정확히 말하면 개발 하면서 Junit을 통해 단위 테스트를 즉각 하여 피드백을 빨리 받고 좀 더 버그가 최소화 하여 개발 하는 벙법을 적용 했다는 것이다.  \n이러한 경험은 정말 값진 경험이었다.  이러한 방식으로 개발 하게 되면 상대적으로 심리적 안정이 있다. 내가 product 코드를 수정하더라도 내가 작성한 테스트 케이스가 있기 때문에 즉각 오류 및 버그를 알려줘 쉽게 문제를 해결 할 수 도 있고, maven을 통해 deploy 할 때도 작성한 테스트 코드를 수행하여 코드 검사도 해주기 때문에 뒤늦게 발생할 오류를 최대한 빨리 감지 할 수 있다는게 큰장점이라 생각한다.\n\n\n### OS 공부\n소프트웨어 개발자로써 컴퓨터 공학에 대한 기초 지식을 탄탄히 하는것이 다른 신기술을 배우는 것보다 더 중요하다고 생각하여 마찬가지로 비중있게 공부하고 있다.  패스트 캠퍼스 올인원 패키지를 수강하면서 내용을 체화시고 있는데 잘한 선택인거 같다. 책으로만 보면 어려운 내용이지만 역시 쉽게 설명해주어 그나마 이해를 하면서 진도를 밟아가고 있다.  \n\nOS파트를 1월에 다 정리하는게 목표였는데 2월까지는 해야 할 것같다. 진도율은 80%정도 됬지만 한번더 반복해서 들을 예정이다. OS내용을 접하면서 왜 개발자가 OS를 알아햐는지 절실히 깨닳았다.  \n\n왜냐하면, OS를 구현/운영 하기 위해서 적용되는 알고리즘, 자료구조가 개발하면서 도움이 많이 되기 때문이다. 이또한 실무에서 경험 할 수 있었는데 멀티스레드 환경에서 개발하고 있었는데 thread safe 하지 않고 간섭이 발생하였기 때문이었다. 나는 여기서 OS 프로세스 파트에서 뮤텍스와 세마포어 개념이 생각이 나서 스레드간 간섭이 생기지 않게 코드로 구현하여 실제 테스트 통과후 운영에 적용하였다. 후에 @disallowconcurrentexecution 어노테이션으로 방지 할 수있다는 것을 깨닳았지만 그래도 개념을 코드로 구현하여 현상을 해결한것은 내게 정말 값진 경험이었다.  \n\n2월 달에도 내것으로 다 만들겠다는 각오로 OS를 꾸준히 공부할 것이다.  그 다음은 컴퓨터 구조이다!\n\n\n### 2월달은?\n- 하루 실천 체크리스틀 좀 더 구체화 하자\n- OS 완강 및 내용 정리 확실히 해 놓자\n- 자료구조 및 알고리즘 공부시간을 늘리고 더 꾸준히 공부하자","source":"_posts/회고/2019년도 첫 실천 1월 회고.md","raw":"---\ntitle: 2019년도 첫 실천 1월 회고\ncatalog: true\nsubtitle: 1월 실천 성적표\nheader-img: \"bg_computer.jpg\"\ntags: \n- 회고\n---\n\n### 1월 실천 성적표\n{% asset_img \"score.png\" %}  \n\n드디어 2019년도! 나의 실천 1월 첫 성적표이다.  [깃텁 TIL](https://github.com/biggwang/TIL) 에서 작성한 하루 해야 할 체크리스트 수행 함에 따라 하루 점수를 매겨 100점 만점으로 환산하여 나타낸것이다.  (Github에 contribution을 따라해봤다.)  \n\n일단 위 색깔 음영과 같이 대부분 해야할 것을 미루지 않고 실천하였다.  정말 하기 싫은날에도 타협하지 않고 조금이라도 하자 라는 마음에 책상에 앉아 할 일을 하였고 그렇게 하루하루 하다보니 몸이 실천하고 행동하는데 익숙해져 큰 어려움이 없는것 같았다.  \n\n\n### 나의 실천 프레임워크\n{% asset_img \"1_notion.png\" %}   \n\nNotion 메모앱을 활용한 나의 1월달 실천 프레임워크이다!  1일부터 31일까지 빠짐없이 할 일을 적고 체크해 나갔다. 동기부여도 되고 실천도 잘되고 계속 활용 해야 겠다.\n\n이제, 1월달에 어떤것을 했는지 그리고 보안할 점은 무엇인지 한 번 회고해 보겠다.\n\n\n### 영어공부\n올해 목표중에 비중 있는 것중에 하나이다.   \n영문 레퍼런스 문서를 읽을때나 세미나, 컨퍼런스, 각종 프로그래밍 관련 영어 컨텐츠를 잘 이해하고 응용하고 싶은 강한 마음과 살면서 제 2외국어 하나 정해서 유창하게 말해보고 싶은 마음에 올해 큰 목표중에 하나로 정하였다.  \n\n출,퇴근 하면서 프로그래밍 관련 영어 유트브를 영어자막으로 만들고 동영상을 추출하여 폰에 넣고 수시로 듣고 shadowing을 하였고 집에서는 dictation 하였다.  \n1달간 정말 빠짐없이 계속 듣다보니 들리기는 잘 들리는거 같다. 아직 멀었지만 발음과 리듬 연음도 정리해가면서 차곡차곡 영어를 체화시키려고 노력하고 있다.  \n\n좀 더 보안할게 있다면  \n- 평소 개발 뉴스를 영어 뉴스로 봐보는 습관을 가지자는 것이다. [InfoQ](https://goo.gl/f3QTHD) 라는 개발 뉴스 사이트를 알게 됬는데 이 사이트를 이용하면 좋을 것 같다. \n- 평소 내말에 귀를 귀울여 내가 자주 사용하는 문장을 영어로 바꿔보는 것이다.\n- dictation 투자를 더 늘려야 한다.\n- commit message 영어로 작성하기\n\n### 영알남\n\"영어 알려주는 남자\" 유트브 구독중인데 영어 공부하고 있는 나로써 정말 도움이 많이 되고 있다.  \n단어, 전치사 등 학교 다닐때 뜻만 외웠지 문맥이나 상황에 따른 느낌은 없어 해석이나 의미전달이 왜 안됬는지 깨닳았기 때문이다. 실제 듣기, 읽기 할 때 상당히 도움이 되고 있다. 반복해서 꾸준히 들을 예정이다.\n\n### 코드 깔끔하게 그리고 보기좋게 작성하기 - Design patterns & Refactoring\n다른 여러 기술들 Docker, JPA, node.js, MSA, NoSQL, SPA 등 해보고 싶은게 많았지만!!  지금. 내가. 하고. 있는. 업무. 를 더 잘하기 위해서 생각하는 질문에 답이 먼저라고 판단하였고 그 답이 바로 **코드를 깔끔하고 다른 사람이 봤을때 이해하기 쉽게 작성하는 것** 이었다.  항상 더 좋은 방법이 없을까? 고민하는 나의 습관이 더 좋은 방법이 녹아들어간 코드를 만들고 더 깔끔해 졌을때 기분은 정말 많이 느꼈던 1월이었다.  \n\n실제 업무에 desigin patterns과 refactoring을 실천 하여 추후 기능을 추가 할 때도 중복을 최소화 할 수 있었고 다시한번 desigin pattern이 왜 필요하고 refacotring에 중요성을 알게 되었다.  \n\n내가 실제 사용한 desigin patterns과 refactoring을 github에 잘 정리하였는데 계속 내용을 추가 업데이트하여 실무에 잘 활용 해야 겠다.  \n- [Factory Method Pattern](https://goo.gl/4xjfVm)\n- [Template Method Pattern](https://goo.gl/fWXFpf)  \n- 그 밖에 Builder Pattern, Observer Pattern을 활용하였는데 추후 정리하여 Commit 할 예정이다.\n\n\n### TDD 실천\nTDD라고 하면 포괄적이고 거창할수 있지만, 정확히 말하면 개발 하면서 Junit을 통해 단위 테스트를 즉각 하여 피드백을 빨리 받고 좀 더 버그가 최소화 하여 개발 하는 벙법을 적용 했다는 것이다.  \n이러한 경험은 정말 값진 경험이었다.  이러한 방식으로 개발 하게 되면 상대적으로 심리적 안정이 있다. 내가 product 코드를 수정하더라도 내가 작성한 테스트 케이스가 있기 때문에 즉각 오류 및 버그를 알려줘 쉽게 문제를 해결 할 수 도 있고, maven을 통해 deploy 할 때도 작성한 테스트 코드를 수행하여 코드 검사도 해주기 때문에 뒤늦게 발생할 오류를 최대한 빨리 감지 할 수 있다는게 큰장점이라 생각한다.\n\n\n### OS 공부\n소프트웨어 개발자로써 컴퓨터 공학에 대한 기초 지식을 탄탄히 하는것이 다른 신기술을 배우는 것보다 더 중요하다고 생각하여 마찬가지로 비중있게 공부하고 있다.  패스트 캠퍼스 올인원 패키지를 수강하면서 내용을 체화시고 있는데 잘한 선택인거 같다. 책으로만 보면 어려운 내용이지만 역시 쉽게 설명해주어 그나마 이해를 하면서 진도를 밟아가고 있다.  \n\nOS파트를 1월에 다 정리하는게 목표였는데 2월까지는 해야 할 것같다. 진도율은 80%정도 됬지만 한번더 반복해서 들을 예정이다. OS내용을 접하면서 왜 개발자가 OS를 알아햐는지 절실히 깨닳았다.  \n\n왜냐하면, OS를 구현/운영 하기 위해서 적용되는 알고리즘, 자료구조가 개발하면서 도움이 많이 되기 때문이다. 이또한 실무에서 경험 할 수 있었는데 멀티스레드 환경에서 개발하고 있었는데 thread safe 하지 않고 간섭이 발생하였기 때문이었다. 나는 여기서 OS 프로세스 파트에서 뮤텍스와 세마포어 개념이 생각이 나서 스레드간 간섭이 생기지 않게 코드로 구현하여 실제 테스트 통과후 운영에 적용하였다. 후에 @disallowconcurrentexecution 어노테이션으로 방지 할 수있다는 것을 깨닳았지만 그래도 개념을 코드로 구현하여 현상을 해결한것은 내게 정말 값진 경험이었다.  \n\n2월 달에도 내것으로 다 만들겠다는 각오로 OS를 꾸준히 공부할 것이다.  그 다음은 컴퓨터 구조이다!\n\n\n### 2월달은?\n- 하루 실천 체크리스틀 좀 더 구체화 하자\n- OS 완강 및 내용 정리 확실히 해 놓자\n- 자료구조 및 알고리즘 공부시간을 늘리고 더 꾸준히 공부하자","slug":"회고/2019년도 첫 실천 1월 회고","published":1,"date":"2019-02-01T13:19:42.451Z","updated":"2019-07-10T14:38:56.579Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids2a002tk0otlsmkwbsb","content":"<h3><span id=\"1월-실천-성적표\">1월 실천 성적표</span></h3>\n<img src=\"/2019/02/01/회고/2019년도%20첫%20실천%201월%20회고/score.png\">  \n<p>드디어 2019년도! 나의 실천 1월 첫 성적표이다.  <a href=\"https://github.com/biggwang/TIL\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">깃텁 TIL</a> 에서 작성한 하루 해야 할 체크리스트 수행 함에 따라 하루 점수를 매겨 100점 만점으로 환산하여 나타낸것이다.  (Github에 contribution을 따라해봤다.)</p>\n<p>일단 위 색깔 음영과 같이 대부분 해야할 것을 미루지 않고 실천하였다.  정말 하기 싫은날에도 타협하지 않고 조금이라도 하자 라는 마음에 책상에 앉아 할 일을 하였고 그렇게 하루하루 하다보니 몸이 실천하고 행동하는데 익숙해져 큰 어려움이 없는것 같았다.</p>\n<h3><span id=\"나의-실천-프레임워크\">나의 실천 프레임워크</span></h3>\n<img src=\"/2019/02/01/회고/2019년도%20첫%20실천%201월%20회고/1_notion.png\">   \n<p>Notion 메모앱을 활용한 나의 1월달 실천 프레임워크이다!  1일부터 31일까지 빠짐없이 할 일을 적고 체크해 나갔다. 동기부여도 되고 실천도 잘되고 계속 활용 해야 겠다.</p>\n<p>이제, 1월달에 어떤것을 했는지 그리고 보안할 점은 무엇인지 한 번 회고해 보겠다.</p>\n<h3><span id=\"영어공부\">영어공부</span></h3>\n<p>올해 목표중에 비중 있는 것중에 하나이다.<br>\n영문 레퍼런스 문서를 읽을때나 세미나, 컨퍼런스, 각종 프로그래밍 관련 영어 컨텐츠를 잘 이해하고 응용하고 싶은 강한 마음과 살면서 제 2외국어 하나 정해서 유창하게 말해보고 싶은 마음에 올해 큰 목표중에 하나로 정하였다.</p>\n<p>출,퇴근 하면서 프로그래밍 관련 영어 유트브를 영어자막으로 만들고 동영상을 추출하여 폰에 넣고 수시로 듣고 shadowing을 하였고 집에서는 dictation 하였다.<br>\n1달간 정말 빠짐없이 계속 듣다보니 들리기는 잘 들리는거 같다. 아직 멀었지만 발음과 리듬 연음도 정리해가면서 차곡차곡 영어를 체화시키려고 노력하고 있다.</p>\n<p>좀 더 보안할게 있다면</p>\n<ul>\n<li>평소 개발 뉴스를 영어 뉴스로 봐보는 습관을 가지자는 것이다. <a href=\"https://goo.gl/f3QTHD\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">InfoQ</a> 라는 개발 뉴스 사이트를 알게 됬는데 이 사이트를 이용하면 좋을 것 같다.</li>\n<li>평소 내말에 귀를 귀울여 내가 자주 사용하는 문장을 영어로 바꿔보는 것이다.</li>\n<li>dictation 투자를 더 늘려야 한다.</li>\n<li>commit message 영어로 작성하기</li>\n</ul>\n<h3><span id=\"영알남\">영알남</span></h3>\n<p>“영어 알려주는 남자” 유트브 구독중인데 영어 공부하고 있는 나로써 정말 도움이 많이 되고 있다.<br>\n단어, 전치사 등 학교 다닐때 뜻만 외웠지 문맥이나 상황에 따른 느낌은 없어 해석이나 의미전달이 왜 안됬는지 깨닳았기 때문이다. 실제 듣기, 읽기 할 때 상당히 도움이 되고 있다. 반복해서 꾸준히 들을 예정이다.</p>\n<h3><span id=\"코드-깔끔하게-그리고-보기좋게-작성하기-design-patterns-amp-refactoring\">코드 깔끔하게 그리고 보기좋게 작성하기 - Design patterns &amp; Refactoring</span></h3>\n<p>다른 여러 기술들 Docker, JPA, node.js, MSA, NoSQL, SPA 등 해보고 싶은게 많았지만!!  지금. 내가. 하고. 있는. 업무. 를 더 잘하기 위해서 생각하는 질문에 답이 먼저라고 판단하였고 그 답이 바로 <strong>코드를 깔끔하고 다른 사람이 봤을때 이해하기 쉽게 작성하는 것</strong> 이었다.  항상 더 좋은 방법이 없을까? 고민하는 나의 습관이 더 좋은 방법이 녹아들어간 코드를 만들고 더 깔끔해 졌을때 기분은 정말 많이 느꼈던 1월이었다.</p>\n<p>실제 업무에 desigin patterns과 refactoring을 실천 하여 추후 기능을 추가 할 때도 중복을 최소화 할 수 있었고 다시한번 desigin pattern이 왜 필요하고 refacotring에 중요성을 알게 되었다.</p>\n<p>내가 실제 사용한 desigin patterns과 refactoring을 github에 잘 정리하였는데 계속 내용을 추가 업데이트하여 실무에 잘 활용 해야 겠다.</p>\n<ul>\n<li><a href=\"https://goo.gl/4xjfVm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Factory Method Pattern</a></li>\n<li><a href=\"https://goo.gl/fWXFpf\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Template Method Pattern</a></li>\n<li>그 밖에 Builder Pattern, Observer Pattern을 활용하였는데 추후 정리하여 Commit 할 예정이다.</li>\n</ul>\n<h3><span id=\"tdd-실천\">TDD 실천</span></h3>\n<p>TDD라고 하면 포괄적이고 거창할수 있지만, 정확히 말하면 개발 하면서 Junit을 통해 단위 테스트를 즉각 하여 피드백을 빨리 받고 좀 더 버그가 최소화 하여 개발 하는 벙법을 적용 했다는 것이다.<br>\n이러한 경험은 정말 값진 경험이었다.  이러한 방식으로 개발 하게 되면 상대적으로 심리적 안정이 있다. 내가 product 코드를 수정하더라도 내가 작성한 테스트 케이스가 있기 때문에 즉각 오류 및 버그를 알려줘 쉽게 문제를 해결 할 수 도 있고, maven을 통해 deploy 할 때도 작성한 테스트 코드를 수행하여 코드 검사도 해주기 때문에 뒤늦게 발생할 오류를 최대한 빨리 감지 할 수 있다는게 큰장점이라 생각한다.</p>\n<h3><span id=\"os-공부\">OS 공부</span></h3>\n<p>소프트웨어 개발자로써 컴퓨터 공학에 대한 기초 지식을 탄탄히 하는것이 다른 신기술을 배우는 것보다 더 중요하다고 생각하여 마찬가지로 비중있게 공부하고 있다.  패스트 캠퍼스 올인원 패키지를 수강하면서 내용을 체화시고 있는데 잘한 선택인거 같다. 책으로만 보면 어려운 내용이지만 역시 쉽게 설명해주어 그나마 이해를 하면서 진도를 밟아가고 있다.</p>\n<p>OS파트를 1월에 다 정리하는게 목표였는데 2월까지는 해야 할 것같다. 진도율은 80%정도 됬지만 한번더 반복해서 들을 예정이다. OS내용을 접하면서 왜 개발자가 OS를 알아햐는지 절실히 깨닳았다.</p>\n<p>왜냐하면, OS를 구현/운영 하기 위해서 적용되는 알고리즘, 자료구조가 개발하면서 도움이 많이 되기 때문이다. 이또한 실무에서 경험 할 수 있었는데 멀티스레드 환경에서 개발하고 있었는데 thread safe 하지 않고 간섭이 발생하였기 때문이었다. 나는 여기서 OS 프로세스 파트에서 뮤텍스와 세마포어 개념이 생각이 나서 스레드간 간섭이 생기지 않게 코드로 구현하여 실제 테스트 통과후 운영에 적용하였다. 후에 @disallowconcurrentexecution 어노테이션으로 방지 할 수있다는 것을 깨닳았지만 그래도 개념을 코드로 구현하여 현상을 해결한것은 내게 정말 값진 경험이었다.</p>\n<p>2월 달에도 내것으로 다 만들겠다는 각오로 OS를 꾸준히 공부할 것이다.  그 다음은 컴퓨터 구조이다!</p>\n<h3><span id=\"2월달은\">2월달은?</span></h3>\n<ul>\n<li>하루 실천 체크리스틀 좀 더 구체화 하자</li>\n<li>OS 완강 및 내용 정리 확실히 해 놓자</li>\n<li>자료구조 및 알고리즘 공부시간을 늘리고 더 꾸준히 공부하자</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3>1월 실천 성적표</h3>\n<img src=\"/2019/02/01/회고/2019년도%20첫%20실천%201월%20회고/score.png\">  \n<p>드디어 2019년도! 나의 실천 1월 첫 성적표이다.  <a href=\"https://github.com/biggwang/TIL\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">깃텁 TIL</a> 에서 작성한 하루 해야 할 체크리스트 수행 함에 따라 하루 점수를 매겨 100점 만점으로 환산하여 나타낸것이다.  (Github에 contribution을 따라해봤다.)</p>\n<p>일단 위 색깔 음영과 같이 대부분 해야할 것을 미루지 않고 실천하였다.  정말 하기 싫은날에도 타협하지 않고 조금이라도 하자 라는 마음에 책상에 앉아 할 일을 하였고 그렇게 하루하루 하다보니 몸이 실천하고 행동하는데 익숙해져 큰 어려움이 없는것 같았다.</p>\n<h3>나의 실천 프레임워크</h3>\n<img src=\"/2019/02/01/회고/2019년도%20첫%20실천%201월%20회고/1_notion.png\">   \n<p>Notion 메모앱을 활용한 나의 1월달 실천 프레임워크이다!  1일부터 31일까지 빠짐없이 할 일을 적고 체크해 나갔다. 동기부여도 되고 실천도 잘되고 계속 활용 해야 겠다.</p>\n<p>이제, 1월달에 어떤것을 했는지 그리고 보안할 점은 무엇인지 한 번 회고해 보겠다.</p>\n<h3>영어공부</h3>\n<p>올해 목표중에 비중 있는 것중에 하나이다.<br>\n영문 레퍼런스 문서를 읽을때나 세미나, 컨퍼런스, 각종 프로그래밍 관련 영어 컨텐츠를 잘 이해하고 응용하고 싶은 강한 마음과 살면서 제 2외국어 하나 정해서 유창하게 말해보고 싶은 마음에 올해 큰 목표중에 하나로 정하였다.</p>\n<p>출,퇴근 하면서 프로그래밍 관련 영어 유트브를 영어자막으로 만들고 동영상을 추출하여 폰에 넣고 수시로 듣고 shadowing을 하였고 집에서는 dictation 하였다.<br>\n1달간 정말 빠짐없이 계속 듣다보니 들리기는 잘 들리는거 같다. 아직 멀었지만 발음과 리듬 연음도 정리해가면서 차곡차곡 영어를 체화시키려고 노력하고 있다.</p>\n<p>좀 더 보안할게 있다면</p>\n<ul>\n<li>평소 개발 뉴스를 영어 뉴스로 봐보는 습관을 가지자는 것이다. <a href=\"https://goo.gl/f3QTHD\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">InfoQ</a> 라는 개발 뉴스 사이트를 알게 됬는데 이 사이트를 이용하면 좋을 것 같다.</li>\n<li>평소 내말에 귀를 귀울여 내가 자주 사용하는 문장을 영어로 바꿔보는 것이다.</li>\n<li>dictation 투자를 더 늘려야 한다.</li>\n<li>commit message 영어로 작성하기</li>\n</ul>\n<h3>영알남</h3>\n<p>“영어 알려주는 남자” 유트브 구독중인데 영어 공부하고 있는 나로써 정말 도움이 많이 되고 있다.<br>\n단어, 전치사 등 학교 다닐때 뜻만 외웠지 문맥이나 상황에 따른 느낌은 없어 해석이나 의미전달이 왜 안됬는지 깨닳았기 때문이다. 실제 듣기, 읽기 할 때 상당히 도움이 되고 있다. 반복해서 꾸준히 들을 예정이다.</p>\n<h3>코드 깔끔하게 그리고 보기좋게 작성하기 - Design patterns &amp; Refactoring</h3>\n<p>다른 여러 기술들 Docker, JPA, node.js, MSA, NoSQL, SPA 등 해보고 싶은게 많았지만!!  지금. 내가. 하고. 있는. 업무. 를 더 잘하기 위해서 생각하는 질문에 답이 먼저라고 판단하였고 그 답이 바로 <strong>코드를 깔끔하고 다른 사람이 봤을때 이해하기 쉽게 작성하는 것</strong> 이었다.  항상 더 좋은 방법이 없을까? 고민하는 나의 습관이 더 좋은 방법이 녹아들어간 코드를 만들고 더 깔끔해 졌을때 기분은 정말 많이 느꼈던 1월이었다.</p>\n<p>실제 업무에 desigin patterns과 refactoring을 실천 하여 추후 기능을 추가 할 때도 중복을 최소화 할 수 있었고 다시한번 desigin pattern이 왜 필요하고 refacotring에 중요성을 알게 되었다.</p>\n<p>내가 실제 사용한 desigin patterns과 refactoring을 github에 잘 정리하였는데 계속 내용을 추가 업데이트하여 실무에 잘 활용 해야 겠다.</p>\n<ul>\n<li><a href=\"https://goo.gl/4xjfVm\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Factory Method Pattern</a></li>\n<li><a href=\"https://goo.gl/fWXFpf\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\">Template Method Pattern</a></li>\n<li>그 밖에 Builder Pattern, Observer Pattern을 활용하였는데 추후 정리하여 Commit 할 예정이다.</li>\n</ul>\n<h3>TDD 실천</h3>\n<p>TDD라고 하면 포괄적이고 거창할수 있지만, 정확히 말하면 개발 하면서 Junit을 통해 단위 테스트를 즉각 하여 피드백을 빨리 받고 좀 더 버그가 최소화 하여 개발 하는 벙법을 적용 했다는 것이다.<br>\n이러한 경험은 정말 값진 경험이었다.  이러한 방식으로 개발 하게 되면 상대적으로 심리적 안정이 있다. 내가 product 코드를 수정하더라도 내가 작성한 테스트 케이스가 있기 때문에 즉각 오류 및 버그를 알려줘 쉽게 문제를 해결 할 수 도 있고, maven을 통해 deploy 할 때도 작성한 테스트 코드를 수행하여 코드 검사도 해주기 때문에 뒤늦게 발생할 오류를 최대한 빨리 감지 할 수 있다는게 큰장점이라 생각한다.</p>\n<h3>OS 공부</h3>\n<p>소프트웨어 개발자로써 컴퓨터 공학에 대한 기초 지식을 탄탄히 하는것이 다른 신기술을 배우는 것보다 더 중요하다고 생각하여 마찬가지로 비중있게 공부하고 있다.  패스트 캠퍼스 올인원 패키지를 수강하면서 내용을 체화시고 있는데 잘한 선택인거 같다. 책으로만 보면 어려운 내용이지만 역시 쉽게 설명해주어 그나마 이해를 하면서 진도를 밟아가고 있다.</p>\n<p>OS파트를 1월에 다 정리하는게 목표였는데 2월까지는 해야 할 것같다. 진도율은 80%정도 됬지만 한번더 반복해서 들을 예정이다. OS내용을 접하면서 왜 개발자가 OS를 알아햐는지 절실히 깨닳았다.</p>\n<p>왜냐하면, OS를 구현/운영 하기 위해서 적용되는 알고리즘, 자료구조가 개발하면서 도움이 많이 되기 때문이다. 이또한 실무에서 경험 할 수 있었는데 멀티스레드 환경에서 개발하고 있었는데 thread safe 하지 않고 간섭이 발생하였기 때문이었다. 나는 여기서 OS 프로세스 파트에서 뮤텍스와 세마포어 개념이 생각이 나서 스레드간 간섭이 생기지 않게 코드로 구현하여 실제 테스트 통과후 운영에 적용하였다. 후에 @disallowconcurrentexecution 어노테이션으로 방지 할 수있다는 것을 깨닳았지만 그래도 개념을 코드로 구현하여 현상을 해결한것은 내게 정말 값진 경험이었다.</p>\n<p>2월 달에도 내것으로 다 만들겠다는 각오로 OS를 꾸준히 공부할 것이다.  그 다음은 컴퓨터 구조이다!</p>\n<h3>2월달은?</h3>\n<ul>\n<li>하루 실천 체크리스틀 좀 더 구체화 하자</li>\n<li>OS 완강 및 내용 정리 확실히 해 놓자</li>\n<li>자료구조 및 알고리즘 공부시간을 늘리고 더 꾸준히 공부하자</li>\n</ul>\n"},{"title":"Spring Validation 다양한 처리 방법","catalog":true,"date":"2018-12-03T16:03:21.000Z","subtitle":null,"header-img":"bg_computer.jpg","catagories":["Spring","Guide"],"_content":"\n\n### org.springframework.validation 활용\n~~~ java\n@PostMapping(value = \"/leave\")\npublic String applyLeave(@ModelAttribute @Valid RequestDto dto,\n                          Errors erros, RedirectAttributes redirectAttributes) {\n\n    boolean isValid = validatorObject.validate(dto, erros);\n    if (!isValid || erros.hasErrors()) {\n        redirectAttributes.addFlashAttribute(\"alertMsg\", erros);\n        return \"redirect:/member/v1/leave\";\n    }\n    ...\n}\n~~~\n\n\n~~~ java\npublic class ValidatorObject implements ControllerValidator {\n\n    @Override\n    public boolean validate(Object requestDTO, Errors errors) {\n        // TODO\n    }\n}\n~~~\n\n**언제 사용 할까?**  \nController단에서 @Valid에서 체크 할 수 없는 비지니스 유효성 검사를 처리하기 위해 사용한다.  \n\n\n**장점은**  \n실제 비지니스로직과 유효성 검사 체크하는 코드를 관심 분리하여 비지니스 로직에 집중 할 수 있다.  \n\n\n**단점은**\n비지니스로직과 유효성검사 로직이 분리 되어 있기 때문에 만약에 다른 곳에서 해당 기능을 이용하고자 할 때 유효성 검사 로직과 비지니스 로직을 같이 가져가야 하는 지식을 알고 있어야 쓸 수 있다. 또한 다른 개발자가 해당 기능을 사용하고자 할 때 비지니스로직만 호출하여 사용 할 경우 유효성 검사 체크 부분은 빠트릴수 있다.\n\n\n\n\n### Custom Annotation 활용\n\n~~~ java\n@Documented\n@Constraint(validatedBy = SortColumnTypeValidator.class)\n@Target({ElementType.METHOD, ElementType.FIELD, PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Target {\n\n    // 애노테이션 지정 시 validatino rule에 맞는 메시지 지정 가능!!!\n    String message() default \"사용 예시) sort=title,asc or sort=title,name,desc or sort=title,desc&sort=name,asc\";\n\n    String[] names() default {};\n\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n\n    @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})\n    @Retention(RUNTIME)\n    @Documented\n    @interface List {\n        NotBlank[] value();\n    }\n}\n\n~~~\n\n~~~ java\npublic class TargetValidator implements ConstraintValidator<Target, String> {\n\n    @Override\n    public void initialize(Target target) {\n    \n    }\n \n    @Override\n    public boolean isValid(String field, ConstraintValidatorContext cxt) {\n        return field != null && field.matches(\"[0-9]+\")\n                && (field.length() > 8) && (field.length() < 14);\n    }\n}\n~~~\n\n\n### 비즈니스 로직에서 처리\n제일 간단한 방법이다.  \n그냥 Service Layer에서 유효성 검사 체크를 한다.  단, 유효성 검사에 대한 부분은 따로 메소드를 추출한다.\n\n\n### Entity객체에서도 유효성 검사를 하자\n","source":"_posts/Spring/Spring Validation 처리 방법.md","raw":"---\ntitle: Spring Validation 다양한 처리 방법\ncatalog: true\ndate: 2018-12-04 01:03:21\nsubtitle:\nheader-img: \"bg_computer.jpg\"\ntags:\n- Framework\n- Spring\ncatagories:\n- Spring\n- Guide\n\n---\n\n\n### org.springframework.validation 활용\n~~~ java\n@PostMapping(value = \"/leave\")\npublic String applyLeave(@ModelAttribute @Valid RequestDto dto,\n                          Errors erros, RedirectAttributes redirectAttributes) {\n\n    boolean isValid = validatorObject.validate(dto, erros);\n    if (!isValid || erros.hasErrors()) {\n        redirectAttributes.addFlashAttribute(\"alertMsg\", erros);\n        return \"redirect:/member/v1/leave\";\n    }\n    ...\n}\n~~~\n\n\n~~~ java\npublic class ValidatorObject implements ControllerValidator {\n\n    @Override\n    public boolean validate(Object requestDTO, Errors errors) {\n        // TODO\n    }\n}\n~~~\n\n**언제 사용 할까?**  \nController단에서 @Valid에서 체크 할 수 없는 비지니스 유효성 검사를 처리하기 위해 사용한다.  \n\n\n**장점은**  \n실제 비지니스로직과 유효성 검사 체크하는 코드를 관심 분리하여 비지니스 로직에 집중 할 수 있다.  \n\n\n**단점은**\n비지니스로직과 유효성검사 로직이 분리 되어 있기 때문에 만약에 다른 곳에서 해당 기능을 이용하고자 할 때 유효성 검사 로직과 비지니스 로직을 같이 가져가야 하는 지식을 알고 있어야 쓸 수 있다. 또한 다른 개발자가 해당 기능을 사용하고자 할 때 비지니스로직만 호출하여 사용 할 경우 유효성 검사 체크 부분은 빠트릴수 있다.\n\n\n\n\n### Custom Annotation 활용\n\n~~~ java\n@Documented\n@Constraint(validatedBy = SortColumnTypeValidator.class)\n@Target({ElementType.METHOD, ElementType.FIELD, PARAMETER})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Target {\n\n    // 애노테이션 지정 시 validatino rule에 맞는 메시지 지정 가능!!!\n    String message() default \"사용 예시) sort=title,asc or sort=title,name,desc or sort=title,desc&sort=name,asc\";\n\n    String[] names() default {};\n\n    Class<?>[] groups() default {};\n\n    Class<? extends Payload>[] payload() default {};\n\n    @Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})\n    @Retention(RUNTIME)\n    @Documented\n    @interface List {\n        NotBlank[] value();\n    }\n}\n\n~~~\n\n~~~ java\npublic class TargetValidator implements ConstraintValidator<Target, String> {\n\n    @Override\n    public void initialize(Target target) {\n    \n    }\n \n    @Override\n    public boolean isValid(String field, ConstraintValidatorContext cxt) {\n        return field != null && field.matches(\"[0-9]+\")\n                && (field.length() > 8) && (field.length() < 14);\n    }\n}\n~~~\n\n\n### 비즈니스 로직에서 처리\n제일 간단한 방법이다.  \n그냥 Service Layer에서 유효성 검사 체크를 한다.  단, 유효성 검사에 대한 부분은 따로 메소드를 추출한다.\n\n\n### Entity객체에서도 유효성 검사를 하자\n","slug":"Spring/Spring Validation 처리 방법","published":1,"updated":"2019-07-16T15:41:42.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids2b002uk0otyucxawh3","content":"<h3><span id=\"orgspringframeworkvalidation-활용\">org.springframework.validation 활용</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping</span>(value = <span class=\"string\">\"/leave\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">applyLeave</span><span class=\"params\">(@ModelAttribute @Valid RequestDto dto,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          Errors erros, RedirectAttributes redirectAttributes)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isValid = validatorObject.validate(dto, erros);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValid || erros.hasErrors()) &#123;</span><br><span class=\"line\">        redirectAttributes.addFlashAttribute(<span class=\"string\">\"alertMsg\"</span>, erros);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"redirect:/member/v1/leave\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValidatorObject</span> <span class=\"keyword\">implements</span> <span class=\"title\">ControllerValidator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">validate</span><span class=\"params\">(Object requestDTO, Errors errors)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>언제 사용 할까?</strong><br>\nController단에서 @Valid에서 체크 할 수 없는 비지니스 유효성 검사를 처리하기 위해 사용한다.</p>\n<p><strong>장점은</strong><br>\n실제 비지니스로직과 유효성 검사 체크하는 코드를 관심 분리하여 비지니스 로직에 집중 할 수 있다.</p>\n<p><strong>단점은</strong><br>\n비지니스로직과 유효성검사 로직이 분리 되어 있기 때문에 만약에 다른 곳에서 해당 기능을 이용하고자 할 때 유효성 검사 로직과 비지니스 로직을 같이 가져가야 하는 지식을 알고 있어야 쓸 수 있다. 또한 다른 개발자가 해당 기능을 사용하고자 할 때 비지니스로직만 호출하여 사용 할 경우 유효성 검사 체크 부분은 빠트릴수 있다.</p>\n<h3><span id=\"custom-annotation-활용\">Custom Annotation 활용</span></h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Constraint</span>(validatedBy = SortColumnTypeValidator.class)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.FIELD, PARAMETER&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Target &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 애노테이션 지정 시 validatino rule에 맞는 메시지 지정 가능!!!</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">message</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"사용 예시) sort</span>=title,asc or sort=title,name,desc or sort=title,desc&amp;sort=name,asc<span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    String[] names() default &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    @Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span></span><br><span class=\"line\"><span class=\"string\">    @Retention(RUNTIME)</span></span><br><span class=\"line\"><span class=\"string\">    @Documented</span></span><br><span class=\"line\"><span class=\"string\">    @interface List &#123;</span></span><br><span class=\"line\"><span class=\"string\">        NotBlank[] value();</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TargetValidator</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConstraintValidator</span>&lt;<span class=\"title\">Target</span>, <span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">(Target target)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String field, ConstraintValidatorContext cxt)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> field != <span class=\"keyword\">null</span> &amp;&amp; field.matches(<span class=\"string\">\"[0-9]+\"</span>)</span><br><span class=\"line\">                &amp;&amp; (field.length() &gt; <span class=\"number\">8</span>) &amp;&amp; (field.length() &lt; <span class=\"number\">14</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3><span id=\"비즈니스-로직에서-처리\">비즈니스 로직에서 처리</span></h3>\n<p>제일 간단한 방법이다.<br>\n그냥 Service Layer에서 유효성 검사 체크를 한다.  단, 유효성 검사에 대한 부분은 따로 메소드를 추출한다.</p>\n<h3><span id=\"entity객체에서도-유효성-검사를-하자\">Entity객체에서도 유효성 검사를 하자</span></h3>\n","site":{"data":{}},"excerpt":"","more":"<h3>org.springframework.validation 활용</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@PostMapping</span>(value = <span class=\"string\">\"/leave\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">applyLeave</span><span class=\"params\">(@ModelAttribute @Valid RequestDto dto,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          Errors erros, RedirectAttributes redirectAttributes)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isValid = validatorObject.validate(dto, erros);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValid || erros.hasErrors()) &#123;</span><br><span class=\"line\">        redirectAttributes.addFlashAttribute(<span class=\"string\">\"alertMsg\"</span>, erros);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"redirect:/member/v1/leave\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValidatorObject</span> <span class=\"keyword\">implements</span> <span class=\"title\">ControllerValidator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">validate</span><span class=\"params\">(Object requestDTO, Errors errors)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>언제 사용 할까?</strong><br>\nController단에서 @Valid에서 체크 할 수 없는 비지니스 유효성 검사를 처리하기 위해 사용한다.</p>\n<p><strong>장점은</strong><br>\n실제 비지니스로직과 유효성 검사 체크하는 코드를 관심 분리하여 비지니스 로직에 집중 할 수 있다.</p>\n<p><strong>단점은</strong><br>\n비지니스로직과 유효성검사 로직이 분리 되어 있기 때문에 만약에 다른 곳에서 해당 기능을 이용하고자 할 때 유효성 검사 로직과 비지니스 로직을 같이 가져가야 하는 지식을 알고 있어야 쓸 수 있다. 또한 다른 개발자가 해당 기능을 사용하고자 할 때 비지니스로직만 호출하여 사용 할 경우 유효성 검사 체크 부분은 빠트릴수 있다.</p>\n<h3>Custom Annotation 활용</h3>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Documented</span></span><br><span class=\"line\"><span class=\"meta\">@Constraint</span>(validatedBy = SortColumnTypeValidator.class)</span><br><span class=\"line\"><span class=\"meta\">@Target</span>(&#123;ElementType.METHOD, ElementType.FIELD, PARAMETER&#125;)</span><br><span class=\"line\"><span class=\"meta\">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Target &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 애노테이션 지정 시 validatino rule에 맞는 메시지 지정 가능!!!</span></span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">message</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> \"사용 예시) sort</span>=title,asc or sort=title,name,desc or sort=title,desc&amp;sort=name,asc<span class=\"string\">\";</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    String[] names() default &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    @Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)</span></span><br><span class=\"line\"><span class=\"string\">    @Retention(RUNTIME)</span></span><br><span class=\"line\"><span class=\"string\">    @Documented</span></span><br><span class=\"line\"><span class=\"string\">    @interface List &#123;</span></span><br><span class=\"line\"><span class=\"string\">        NotBlank[] value();</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TargetValidator</span> <span class=\"keyword\">implements</span> <span class=\"title\">ConstraintValidator</span>&lt;<span class=\"title\">Target</span>, <span class=\"title\">String</span>&gt; </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">initialize</span><span class=\"params\">(Target target)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String field, ConstraintValidatorContext cxt)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> field != <span class=\"keyword\">null</span> &amp;&amp; field.matches(<span class=\"string\">\"[0-9]+\"</span>)</span><br><span class=\"line\">                &amp;&amp; (field.length() &gt; <span class=\"number\">8</span>) &amp;&amp; (field.length() &lt; <span class=\"number\">14</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3>비즈니스 로직에서 처리</h3>\n<p>제일 간단한 방법이다.<br>\n그냥 Service Layer에서 유효성 검사 체크를 한다.  단, 유효성 검사에 대한 부분은 따로 메소드를 추출한다.</p>\n<h3>Entity객체에서도 유효성 검사를 하자</h3>\n"},{"title":"첫 서비스 오픈 준비를 하며","catalog":true,"subtitle":null,"header-img":"bg_computer.jpg","_content":"\n### 들어가며\n첫 서비르 오픈 준비를 하고 부족한 부분을 보안 할 점, 문제 해결 상황, 경험 등을 기억하고 기록하여 다음에는 더 개선된 행동을 하기 위해 적어 놓는다.\n\n\n### 부하테스트 통과 시키기\n서비스를 오픈하기전에 부하테스트를 하여 서버에 어떤 영향이 있을지 모르니 사전에 알기 위함이고 앞으로 팀내 서비스를 출시 할 때 부하테스트 스템을 추가하여 표준적인 부하 임계치를 정하고자 시작하게 되었다.\n\n\n### 응답시간 지연\n\nScouter에서 PHP에게 요청하는 응답시간이 지연되었다. 결과적으로 TPS는 15밖에 나오지 않았고 서비스 출시가 어려운 상황이었다. \n\n원인은 PHP에게 요청하는 데이터 사이즈도 컸고 어떠한 로직에 의하여 Cache가 동작하지 않는 것이었다. \n\n이부분은 Scouter를 보고 실장님에 인사이트로 원인을 알게 되었고 Scouter에서 나오는 데이터를 잘 분석하는 능력이 필요함을 느꼈다. \n\n아무튼 서비스 출시를 위해서는 PHP에게 의존하는 것을 최대한 줄여한다. 그러기 위해 사용한 전략은 PHP에서 가져오는 html, 데이터를 Java로 내재화 하고 캐쉬를 적용하는 것이다.\n\n### 캐쉬 적용\n\nSpring Caffeine 캐쉬를 사용하였고 어쩔수 없이 PHP 콜이 필요한 부분은 캐쉬를 사용하였다. \n\n캐쉬를 적용해 본것이 처음이었는데 캐쉬에 중요성과 캐쉬가 동작하는 개념을 알아야 할 필요성을 느꼈다.\n\n작업이 끝나고 스트레스 서버에 반영 하였다.\n\n### EC2 t2.micro → t2.medium 교체\n\n처음에 부하를 돌려도 Scouter에 반응이 없었는데 알고보니 토큰만료와 User-Agent 값이 달라서 로그인이 안되서 그런것이었다. 수정하고 테스트를 하였는데도 TPS가 50 밖에 되지 않는 것이었다.\n\n실장님이 일단 공인망을 타는것을 내부망을 타도록 바꾸어 주셨고 서버 스펙도 t2.medium으로 교체하고 진행하였는데 TPS 320 !!! 통과다.\n\n실장님이 말씀하시길 처음에 구동될때 Java가 초기화 될때는 CPU나 메모리 점유율이 크지만 곧 안정되서 떨어지는 곡선에 개형을 나타나지만 PHP는 떨어지지 않고 계속 유지되고 있다고 하였다. 요청은 PHP서버에서 받고 있긴 하지만 이대목에서 정확히 왜그런지는 모르곘다.\n\nTODO 그라파냐 캡쳐사진 첨부\n\nVisual GC 원격 접속\n\n원격으로 부하테스트 서버에 접속하여 GC에 대한 모니터링을 할 수 있다.\n\n그 과정에서 터미널로 포트를 확인하는 과정이 있었는데 이러한 부분은 내가 아예 몰라서 공부가 필요하다.\n\n\n### 어? 배너가 안나오네??\n다음날은 광복절 휴일이었다.. 제발 오늘은 아무일 없기를.. 칼퇴해야지!! 하는데 역시나 버그가 발생하였다.\n퇴근 약 1시간 전 이었고 얼른 끝내야 겠다는 마음으로 버그 원인을 조사하기 시작하였다. 특정 쿠기가 있으면 일반 배너가 나와야 하고 특정 쿠기가 없으면 사이즈가 큰 확장 배너가 나와야 하는데 확장 배너에서 이미지가 안나오고 그냥 html이 텍스트로 나오는 것이다.  \n\n많은 삽질과 도움을 받아 버그는 해결 되었는데 해결 하는 과정 속에 문제 원인과 시간이 지체된 이유를 적어 본다.\n\n\n### PHP 코드를 잘 못 보고 있었다.\n작업내용은 PHP 코드를 보고 JAVA 옮기는 것이었는데 a라는 파일 참고하여 개발하였는데 알고보니 수정된 a' 파일이었던 것이다.  \n그래서 Java 코드를 다시 수정 하는것이 필요하였다. 하지만 빠르게 PHP코드를 이해하고 Java로 어떻게 구현할지 감이 잡히지 않았다. PHP에는 있어도 JAVA 영역에서는 굳이 필요없는 코드인데 그것도 옮기려는 뻘짓도 있었고 꼭 PHP코드를 그대로 복사하는 것이 아니라 이해하고 코딩을 했어야 했다. A->B->C 로 로직이 구현 되어 있어도 A->C 로 가는 좋은 방법이 있으면 그것을 구현하면 되는 것이다. 하지만 나는 PHP를 그대로 구현해야 탈이 없다는 것이 잠재되어 있었는지 PHP데로 하려고 이해하고 JAVA로 코드를 구현하려 보니 시간이 지체 되었다.\n\n\n### DB를 잘 못 보고 있었다.\n구현하고 데이터를 확인하는데 디비랑 데이터가 다른것이다. 현상 특정 엔티티 프로퍼티에 값이 계속 null인 것이다. 많은 삽질 끝에 결국 DB주소를 잘 못 바라 보고 있었다...\n\n\n### 하지만 그래도 원인은 그대로..\n기존 PHP족 배너에서도 잘 나오던게 안나오고 있었고 이건 먼저 PHP쪽에 확인이 필요하였다. 결국 조치를 취하여 이제 배너는 나오게 된 상황이었다.\n\n\n### 결국 개발자는 문제 해결 능력\n배너는 나오고 있었지만 위에서 말했다 싶이 확장배너는 나오지 않았다. 특정 쿠키값을 지우면 나와야 하는데 안나오는 것이다. 옆에 선배 개발자님에게 도움을 받으며 문제를 하나하나 차근차근 까보기 시작했다. 지금 특정 쿠키를 지웠으니까 여기 조건으로 들어 왔을테고 근데 안나왔네? 그럼 PHP 소스를 보자아~~ 아 음.... 아 여기 조건이 바뀌었네.. 물론 이렇게 한방에 해서 해결 된건 아니었지만 문제 원인을 분석하기 위해 차근차근 하나씩 따져 보면서 접근하는 방식이 참 인상 깊었다. PHP랑 똑같이 했는데 안되면 그냥 스타일을 같이 먹여 보고 좀 이렇게 해보고 저렇게 해보고 그래서 결국 해내는 것 그 문제를 해결 하는 능력이 결국 개발자에 실력인것 같다.\n\n\n\n### 그럼 나는 왜 스스로 문제를 해결하지 못했을까??\n일단, 문제원인이 외부적인 문제도 있었다. 그럼 외부적이 문제가 무엇이었는지 파악을하고 질문을 하던지 공유를 하던지 해서 앞단에서 해결을 빨리 했어야 했는데 그러지 못헀다. 결국 **이문제가 내부(나의 문제)인가 아님 외부 인가 부터 구별하는 혜안이 부족**했던거 같다.  \n\n코드를 확실히 이해하지 않은 상태에서 코드 수정하기 바빴다.  \n코드를 이해하고 이것이 의미하는 바가 무엇인지 확실하게 이해해야 하고 코드를 수정해야 하는데 일단 수정하고 결과 보고 아니면 이렇게 수정하고 결과보고 계속 쳇바퀴만 돌고 문제는 해결되지 않고 시간은 지체 되어 결국 도움을 요청하게 되었다.\n\n\n\n\n### 느낀점, 그래서 앞으로는?\n\n**적극적으로 이해하기 위해서 적극적으로 행동하자**\n\n물어보는게 제일 빠르다\n다른 사람이 작성한 코드나 잘 모르는 업무라면 그 업무 담당자에게 확실하게 물어보자. 물어 볼때는 최대한 많이 정보를 얻기 위해서 무엇을 물어볼지 적어놓자. 그리고 이왕이면 내 자리로 데리고 와서 모니터 화면을 보면서 빠르게 이해시켜주면서 정보를 얻는것이 제일 좋다.\n\n\n**코드가 의미하는 바가 무엇인지 확실히 이해한다.**\n\n함부로 또는 건성으로 코드를 이해했다고 넘어가면 안된다.  \n정말 어떠한 문맥에서 이러한 코드를 작성했는지 무엇을 위해서 코드를 작성헀는지 확실히 이해하는 활동을 반드시 해야 한다.\n\n\n**개인공부는 업무를 하면서 잘 안된것들과 배운 경험들에 연장선에서 공부하자**\n결국 내가 지금 하고 있는 업무를 잘하면 된다. 그것들을 잘 습득해야 나중에 제대로 활용 할 수 있고 더 잘 할 수 있게 된다.  \n업무에서 잘 사용하지 않고 있는데 미리 공부한 지식들은 금방 까먹고 밑빠진 독에 물붓기가 되는 셈이다.\n\n\n**압박감 속에서 문제를 해결하는 능력이 진짜 능력이다.**\n사람들이 다 보고 있다. 나만 지켜 보고 있다. 부담감이 들고 내 행동 하나에 초점이 맞춰저 있어 되게 신경쓰인다.  \n하지만 일하면서 그러한 상황은 얼마든지 올 수 있다. 그러한 것들을 신경쓰지 않고 내 페이스를 유지하면서 정확하고 빠르게 생각하여 문제 원인을 찾고 해결하는 능력을 키우기 위해 의식적으로 노력해야 한다. 그럴려면 **일할때나 개인 공부 할 때 시간을 재고 문제를 해결 한다는지 주위에 사람이 있다 항상 생각하고 문제를 푼다는지 하는 전략**으로 해야 할 것 같다. ","source":"_posts/회고/첫오픈 준비.md","raw":"---\ntitle: 첫 서비스 오픈 준비를 하며\ncatalog: true\nsubtitle:\nheader-img: \"bg_computer.jpg\"\ntags: \n- 회고\n---\n\n### 들어가며\n첫 서비르 오픈 준비를 하고 부족한 부분을 보안 할 점, 문제 해결 상황, 경험 등을 기억하고 기록하여 다음에는 더 개선된 행동을 하기 위해 적어 놓는다.\n\n\n### 부하테스트 통과 시키기\n서비스를 오픈하기전에 부하테스트를 하여 서버에 어떤 영향이 있을지 모르니 사전에 알기 위함이고 앞으로 팀내 서비스를 출시 할 때 부하테스트 스템을 추가하여 표준적인 부하 임계치를 정하고자 시작하게 되었다.\n\n\n### 응답시간 지연\n\nScouter에서 PHP에게 요청하는 응답시간이 지연되었다. 결과적으로 TPS는 15밖에 나오지 않았고 서비스 출시가 어려운 상황이었다. \n\n원인은 PHP에게 요청하는 데이터 사이즈도 컸고 어떠한 로직에 의하여 Cache가 동작하지 않는 것이었다. \n\n이부분은 Scouter를 보고 실장님에 인사이트로 원인을 알게 되었고 Scouter에서 나오는 데이터를 잘 분석하는 능력이 필요함을 느꼈다. \n\n아무튼 서비스 출시를 위해서는 PHP에게 의존하는 것을 최대한 줄여한다. 그러기 위해 사용한 전략은 PHP에서 가져오는 html, 데이터를 Java로 내재화 하고 캐쉬를 적용하는 것이다.\n\n### 캐쉬 적용\n\nSpring Caffeine 캐쉬를 사용하였고 어쩔수 없이 PHP 콜이 필요한 부분은 캐쉬를 사용하였다. \n\n캐쉬를 적용해 본것이 처음이었는데 캐쉬에 중요성과 캐쉬가 동작하는 개념을 알아야 할 필요성을 느꼈다.\n\n작업이 끝나고 스트레스 서버에 반영 하였다.\n\n### EC2 t2.micro → t2.medium 교체\n\n처음에 부하를 돌려도 Scouter에 반응이 없었는데 알고보니 토큰만료와 User-Agent 값이 달라서 로그인이 안되서 그런것이었다. 수정하고 테스트를 하였는데도 TPS가 50 밖에 되지 않는 것이었다.\n\n실장님이 일단 공인망을 타는것을 내부망을 타도록 바꾸어 주셨고 서버 스펙도 t2.medium으로 교체하고 진행하였는데 TPS 320 !!! 통과다.\n\n실장님이 말씀하시길 처음에 구동될때 Java가 초기화 될때는 CPU나 메모리 점유율이 크지만 곧 안정되서 떨어지는 곡선에 개형을 나타나지만 PHP는 떨어지지 않고 계속 유지되고 있다고 하였다. 요청은 PHP서버에서 받고 있긴 하지만 이대목에서 정확히 왜그런지는 모르곘다.\n\nTODO 그라파냐 캡쳐사진 첨부\n\nVisual GC 원격 접속\n\n원격으로 부하테스트 서버에 접속하여 GC에 대한 모니터링을 할 수 있다.\n\n그 과정에서 터미널로 포트를 확인하는 과정이 있었는데 이러한 부분은 내가 아예 몰라서 공부가 필요하다.\n\n\n### 어? 배너가 안나오네??\n다음날은 광복절 휴일이었다.. 제발 오늘은 아무일 없기를.. 칼퇴해야지!! 하는데 역시나 버그가 발생하였다.\n퇴근 약 1시간 전 이었고 얼른 끝내야 겠다는 마음으로 버그 원인을 조사하기 시작하였다. 특정 쿠기가 있으면 일반 배너가 나와야 하고 특정 쿠기가 없으면 사이즈가 큰 확장 배너가 나와야 하는데 확장 배너에서 이미지가 안나오고 그냥 html이 텍스트로 나오는 것이다.  \n\n많은 삽질과 도움을 받아 버그는 해결 되었는데 해결 하는 과정 속에 문제 원인과 시간이 지체된 이유를 적어 본다.\n\n\n### PHP 코드를 잘 못 보고 있었다.\n작업내용은 PHP 코드를 보고 JAVA 옮기는 것이었는데 a라는 파일 참고하여 개발하였는데 알고보니 수정된 a' 파일이었던 것이다.  \n그래서 Java 코드를 다시 수정 하는것이 필요하였다. 하지만 빠르게 PHP코드를 이해하고 Java로 어떻게 구현할지 감이 잡히지 않았다. PHP에는 있어도 JAVA 영역에서는 굳이 필요없는 코드인데 그것도 옮기려는 뻘짓도 있었고 꼭 PHP코드를 그대로 복사하는 것이 아니라 이해하고 코딩을 했어야 했다. A->B->C 로 로직이 구현 되어 있어도 A->C 로 가는 좋은 방법이 있으면 그것을 구현하면 되는 것이다. 하지만 나는 PHP를 그대로 구현해야 탈이 없다는 것이 잠재되어 있었는지 PHP데로 하려고 이해하고 JAVA로 코드를 구현하려 보니 시간이 지체 되었다.\n\n\n### DB를 잘 못 보고 있었다.\n구현하고 데이터를 확인하는데 디비랑 데이터가 다른것이다. 현상 특정 엔티티 프로퍼티에 값이 계속 null인 것이다. 많은 삽질 끝에 결국 DB주소를 잘 못 바라 보고 있었다...\n\n\n### 하지만 그래도 원인은 그대로..\n기존 PHP족 배너에서도 잘 나오던게 안나오고 있었고 이건 먼저 PHP쪽에 확인이 필요하였다. 결국 조치를 취하여 이제 배너는 나오게 된 상황이었다.\n\n\n### 결국 개발자는 문제 해결 능력\n배너는 나오고 있었지만 위에서 말했다 싶이 확장배너는 나오지 않았다. 특정 쿠키값을 지우면 나와야 하는데 안나오는 것이다. 옆에 선배 개발자님에게 도움을 받으며 문제를 하나하나 차근차근 까보기 시작했다. 지금 특정 쿠키를 지웠으니까 여기 조건으로 들어 왔을테고 근데 안나왔네? 그럼 PHP 소스를 보자아~~ 아 음.... 아 여기 조건이 바뀌었네.. 물론 이렇게 한방에 해서 해결 된건 아니었지만 문제 원인을 분석하기 위해 차근차근 하나씩 따져 보면서 접근하는 방식이 참 인상 깊었다. PHP랑 똑같이 했는데 안되면 그냥 스타일을 같이 먹여 보고 좀 이렇게 해보고 저렇게 해보고 그래서 결국 해내는 것 그 문제를 해결 하는 능력이 결국 개발자에 실력인것 같다.\n\n\n\n### 그럼 나는 왜 스스로 문제를 해결하지 못했을까??\n일단, 문제원인이 외부적인 문제도 있었다. 그럼 외부적이 문제가 무엇이었는지 파악을하고 질문을 하던지 공유를 하던지 해서 앞단에서 해결을 빨리 했어야 했는데 그러지 못헀다. 결국 **이문제가 내부(나의 문제)인가 아님 외부 인가 부터 구별하는 혜안이 부족**했던거 같다.  \n\n코드를 확실히 이해하지 않은 상태에서 코드 수정하기 바빴다.  \n코드를 이해하고 이것이 의미하는 바가 무엇인지 확실하게 이해해야 하고 코드를 수정해야 하는데 일단 수정하고 결과 보고 아니면 이렇게 수정하고 결과보고 계속 쳇바퀴만 돌고 문제는 해결되지 않고 시간은 지체 되어 결국 도움을 요청하게 되었다.\n\n\n\n\n### 느낀점, 그래서 앞으로는?\n\n**적극적으로 이해하기 위해서 적극적으로 행동하자**\n\n물어보는게 제일 빠르다\n다른 사람이 작성한 코드나 잘 모르는 업무라면 그 업무 담당자에게 확실하게 물어보자. 물어 볼때는 최대한 많이 정보를 얻기 위해서 무엇을 물어볼지 적어놓자. 그리고 이왕이면 내 자리로 데리고 와서 모니터 화면을 보면서 빠르게 이해시켜주면서 정보를 얻는것이 제일 좋다.\n\n\n**코드가 의미하는 바가 무엇인지 확실히 이해한다.**\n\n함부로 또는 건성으로 코드를 이해했다고 넘어가면 안된다.  \n정말 어떠한 문맥에서 이러한 코드를 작성했는지 무엇을 위해서 코드를 작성헀는지 확실히 이해하는 활동을 반드시 해야 한다.\n\n\n**개인공부는 업무를 하면서 잘 안된것들과 배운 경험들에 연장선에서 공부하자**\n결국 내가 지금 하고 있는 업무를 잘하면 된다. 그것들을 잘 습득해야 나중에 제대로 활용 할 수 있고 더 잘 할 수 있게 된다.  \n업무에서 잘 사용하지 않고 있는데 미리 공부한 지식들은 금방 까먹고 밑빠진 독에 물붓기가 되는 셈이다.\n\n\n**압박감 속에서 문제를 해결하는 능력이 진짜 능력이다.**\n사람들이 다 보고 있다. 나만 지켜 보고 있다. 부담감이 들고 내 행동 하나에 초점이 맞춰저 있어 되게 신경쓰인다.  \n하지만 일하면서 그러한 상황은 얼마든지 올 수 있다. 그러한 것들을 신경쓰지 않고 내 페이스를 유지하면서 정확하고 빠르게 생각하여 문제 원인을 찾고 해결하는 능력을 키우기 위해 의식적으로 노력해야 한다. 그럴려면 **일할때나 개인 공부 할 때 시간을 재고 문제를 해결 한다는지 주위에 사람이 있다 항상 생각하고 문제를 푼다는지 하는 전략**으로 해야 할 것 같다. ","slug":"회고/첫오픈 준비","published":1,"date":"2019-08-14T14:25:03.595Z","updated":"2019-08-14T15:28:33.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl8oids2d002xk0otm22mdd1a","content":"<h3><span id=\"들어가며\">들어가며</span></h3>\n<p>첫 서비르 오픈 준비를 하고 부족한 부분을 보안 할 점, 문제 해결 상황, 경험 등을 기억하고 기록하여 다음에는 더 개선된 행동을 하기 위해 적어 놓는다.</p>\n<h3><span id=\"부하테스트-통과-시키기\">부하테스트 통과 시키기</span></h3>\n<p>서비스를 오픈하기전에 부하테스트를 하여 서버에 어떤 영향이 있을지 모르니 사전에 알기 위함이고 앞으로 팀내 서비스를 출시 할 때 부하테스트 스템을 추가하여 표준적인 부하 임계치를 정하고자 시작하게 되었다.</p>\n<h3><span id=\"응답시간-지연\">응답시간 지연</span></h3>\n<p>Scouter에서 PHP에게 요청하는 응답시간이 지연되었다. 결과적으로 TPS는 15밖에 나오지 않았고 서비스 출시가 어려운 상황이었다.</p>\n<p>원인은 PHP에게 요청하는 데이터 사이즈도 컸고 어떠한 로직에 의하여 Cache가 동작하지 않는 것이었다.</p>\n<p>이부분은 Scouter를 보고 실장님에 인사이트로 원인을 알게 되었고 Scouter에서 나오는 데이터를 잘 분석하는 능력이 필요함을 느꼈다.</p>\n<p>아무튼 서비스 출시를 위해서는 PHP에게 의존하는 것을 최대한 줄여한다. 그러기 위해 사용한 전략은 PHP에서 가져오는 html, 데이터를 Java로 내재화 하고 캐쉬를 적용하는 것이다.</p>\n<h3><span id=\"캐쉬-적용\">캐쉬 적용</span></h3>\n<p>Spring Caffeine 캐쉬를 사용하였고 어쩔수 없이 PHP 콜이 필요한 부분은 캐쉬를 사용하였다.</p>\n<p>캐쉬를 적용해 본것이 처음이었는데 캐쉬에 중요성과 캐쉬가 동작하는 개념을 알아야 할 필요성을 느꼈다.</p>\n<p>작업이 끝나고 스트레스 서버에 반영 하였다.</p>\n<h3><span id=\"ec2-t2micro-t2medium-교체\">EC2 t2.micro → t2.medium 교체</span></h3>\n<p>처음에 부하를 돌려도 Scouter에 반응이 없었는데 알고보니 토큰만료와 User-Agent 값이 달라서 로그인이 안되서 그런것이었다. 수정하고 테스트를 하였는데도 TPS가 50 밖에 되지 않는 것이었다.</p>\n<p>실장님이 일단 공인망을 타는것을 내부망을 타도록 바꾸어 주셨고 서버 스펙도 t2.medium으로 교체하고 진행하였는데 TPS 320 !!! 통과다.</p>\n<p>실장님이 말씀하시길 처음에 구동될때 Java가 초기화 될때는 CPU나 메모리 점유율이 크지만 곧 안정되서 떨어지는 곡선에 개형을 나타나지만 PHP는 떨어지지 않고 계속 유지되고 있다고 하였다. 요청은 PHP서버에서 받고 있긴 하지만 이대목에서 정확히 왜그런지는 모르곘다.</p>\n<p>TODO 그라파냐 캡쳐사진 첨부</p>\n<p>Visual GC 원격 접속</p>\n<p>원격으로 부하테스트 서버에 접속하여 GC에 대한 모니터링을 할 수 있다.</p>\n<p>그 과정에서 터미널로 포트를 확인하는 과정이 있었는데 이러한 부분은 내가 아예 몰라서 공부가 필요하다.</p>\n<h3><span id=\"어-배너가-안나오네\">어? 배너가 안나오네??</span></h3>\n<p>다음날은 광복절 휴일이었다… 제발 오늘은 아무일 없기를… 칼퇴해야지!! 하는데 역시나 버그가 발생하였다.<br>\n퇴근 약 1시간 전 이었고 얼른 끝내야 겠다는 마음으로 버그 원인을 조사하기 시작하였다. 특정 쿠기가 있으면 일반 배너가 나와야 하고 특정 쿠기가 없으면 사이즈가 큰 확장 배너가 나와야 하는데 확장 배너에서 이미지가 안나오고 그냥 html이 텍스트로 나오는 것이다.</p>\n<p>많은 삽질과 도움을 받아 버그는 해결 되었는데 해결 하는 과정 속에 문제 원인과 시간이 지체된 이유를 적어 본다.</p>\n<h3><span id=\"php-코드를-잘-못-보고-있었다\">PHP 코드를 잘 못 보고 있었다.</span></h3>\n<p>작업내용은 PHP 코드를 보고 JAVA 옮기는 것이었는데 a라는 파일 참고하여 개발하였는데 알고보니 수정된 a’ 파일이었던 것이다.<br>\n그래서 Java 코드를 다시 수정 하는것이 필요하였다. 하지만 빠르게 PHP코드를 이해하고 Java로 어떻게 구현할지 감이 잡히지 않았다. PHP에는 있어도 JAVA 영역에서는 굳이 필요없는 코드인데 그것도 옮기려는 뻘짓도 있었고 꼭 PHP코드를 그대로 복사하는 것이 아니라 이해하고 코딩을 했어야 했다. A-&gt;B-&gt;C 로 로직이 구현 되어 있어도 A-&gt;C 로 가는 좋은 방법이 있으면 그것을 구현하면 되는 것이다. 하지만 나는 PHP를 그대로 구현해야 탈이 없다는 것이 잠재되어 있었는지 PHP데로 하려고 이해하고 JAVA로 코드를 구현하려 보니 시간이 지체 되었다.</p>\n<h3><span id=\"db를-잘-못-보고-있었다\">DB를 잘 못 보고 있었다.</span></h3>\n<p>구현하고 데이터를 확인하는데 디비랑 데이터가 다른것이다. 현상 특정 엔티티 프로퍼티에 값이 계속 null인 것이다. 많은 삽질 끝에 결국 DB주소를 잘 못 바라 보고 있었다…</p>\n<h3><span id=\"하지만-그래도-원인은-그대로\">하지만 그래도 원인은 그대로…</span></h3>\n<p>기존 PHP족 배너에서도 잘 나오던게 안나오고 있었고 이건 먼저 PHP쪽에 확인이 필요하였다. 결국 조치를 취하여 이제 배너는 나오게 된 상황이었다.</p>\n<h3><span id=\"결국-개발자는-문제-해결-능력\">결국 개발자는 문제 해결 능력</span></h3>\n<p>배너는 나오고 있었지만 위에서 말했다 싶이 확장배너는 나오지 않았다. 특정 쿠키값을 지우면 나와야 하는데 안나오는 것이다. 옆에 선배 개발자님에게 도움을 받으며 문제를 하나하나 차근차근 까보기 시작했다. 지금 특정 쿠키를 지웠으니까 여기 조건으로 들어 왔을테고 근데 안나왔네? 그럼 PHP 소스를 보자아~~ 아 음… 아 여기 조건이 바뀌었네… 물론 이렇게 한방에 해서 해결 된건 아니었지만 문제 원인을 분석하기 위해 차근차근 하나씩 따져 보면서 접근하는 방식이 참 인상 깊었다. PHP랑 똑같이 했는데 안되면 그냥 스타일을 같이 먹여 보고 좀 이렇게 해보고 저렇게 해보고 그래서 결국 해내는 것 그 문제를 해결 하는 능력이 결국 개발자에 실력인것 같다.</p>\n<h3><span id=\"그럼-나는-왜-스스로-문제를-해결하지-못했을까\">그럼 나는 왜 스스로 문제를 해결하지 못했을까??</span></h3>\n<p>일단, 문제원인이 외부적인 문제도 있었다. 그럼 외부적이 문제가 무엇이었는지 파악을하고 질문을 하던지 공유를 하던지 해서 앞단에서 해결을 빨리 했어야 했는데 그러지 못헀다. 결국 <strong>이문제가 내부(나의 문제)인가 아님 외부 인가 부터 구별하는 혜안이 부족</strong>했던거 같다.</p>\n<p>코드를 확실히 이해하지 않은 상태에서 코드 수정하기 바빴다.<br>\n코드를 이해하고 이것이 의미하는 바가 무엇인지 확실하게 이해해야 하고 코드를 수정해야 하는데 일단 수정하고 결과 보고 아니면 이렇게 수정하고 결과보고 계속 쳇바퀴만 돌고 문제는 해결되지 않고 시간은 지체 되어 결국 도움을 요청하게 되었다.</p>\n<h3><span id=\"느낀점-그래서-앞으로는\">느낀점, 그래서 앞으로는?</span></h3>\n<p><strong>적극적으로 이해하기 위해서 적극적으로 행동하자</strong></p>\n<p>물어보는게 제일 빠르다<br>\n다른 사람이 작성한 코드나 잘 모르는 업무라면 그 업무 담당자에게 확실하게 물어보자. 물어 볼때는 최대한 많이 정보를 얻기 위해서 무엇을 물어볼지 적어놓자. 그리고 이왕이면 내 자리로 데리고 와서 모니터 화면을 보면서 빠르게 이해시켜주면서 정보를 얻는것이 제일 좋다.</p>\n<p><strong>코드가 의미하는 바가 무엇인지 확실히 이해한다.</strong></p>\n<p>함부로 또는 건성으로 코드를 이해했다고 넘어가면 안된다.<br>\n정말 어떠한 문맥에서 이러한 코드를 작성했는지 무엇을 위해서 코드를 작성헀는지 확실히 이해하는 활동을 반드시 해야 한다.</p>\n<p><strong>개인공부는 업무를 하면서 잘 안된것들과 배운 경험들에 연장선에서 공부하자</strong><br>\n결국 내가 지금 하고 있는 업무를 잘하면 된다. 그것들을 잘 습득해야 나중에 제대로 활용 할 수 있고 더 잘 할 수 있게 된다.<br>\n업무에서 잘 사용하지 않고 있는데 미리 공부한 지식들은 금방 까먹고 밑빠진 독에 물붓기가 되는 셈이다.</p>\n<p><strong>압박감 속에서 문제를 해결하는 능력이 진짜 능력이다.</strong><br>\n사람들이 다 보고 있다. 나만 지켜 보고 있다. 부담감이 들고 내 행동 하나에 초점이 맞춰저 있어 되게 신경쓰인다.<br>\n하지만 일하면서 그러한 상황은 얼마든지 올 수 있다. 그러한 것들을 신경쓰지 않고 내 페이스를 유지하면서 정확하고 빠르게 생각하여 문제 원인을 찾고 해결하는 능력을 키우기 위해 의식적으로 노력해야 한다. 그럴려면 <strong>일할때나 개인 공부 할 때 시간을 재고 문제를 해결 한다는지 주위에 사람이 있다 항상 생각하고 문제를 푼다는지 하는 전략</strong>으로 해야 할 것 같다.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3>들어가며</h3>\n<p>첫 서비르 오픈 준비를 하고 부족한 부분을 보안 할 점, 문제 해결 상황, 경험 등을 기억하고 기록하여 다음에는 더 개선된 행동을 하기 위해 적어 놓는다.</p>\n<h3>부하테스트 통과 시키기</h3>\n<p>서비스를 오픈하기전에 부하테스트를 하여 서버에 어떤 영향이 있을지 모르니 사전에 알기 위함이고 앞으로 팀내 서비스를 출시 할 때 부하테스트 스템을 추가하여 표준적인 부하 임계치를 정하고자 시작하게 되었다.</p>\n<h3>응답시간 지연</h3>\n<p>Scouter에서 PHP에게 요청하는 응답시간이 지연되었다. 결과적으로 TPS는 15밖에 나오지 않았고 서비스 출시가 어려운 상황이었다.</p>\n<p>원인은 PHP에게 요청하는 데이터 사이즈도 컸고 어떠한 로직에 의하여 Cache가 동작하지 않는 것이었다.</p>\n<p>이부분은 Scouter를 보고 실장님에 인사이트로 원인을 알게 되었고 Scouter에서 나오는 데이터를 잘 분석하는 능력이 필요함을 느꼈다.</p>\n<p>아무튼 서비스 출시를 위해서는 PHP에게 의존하는 것을 최대한 줄여한다. 그러기 위해 사용한 전략은 PHP에서 가져오는 html, 데이터를 Java로 내재화 하고 캐쉬를 적용하는 것이다.</p>\n<h3>캐쉬 적용</h3>\n<p>Spring Caffeine 캐쉬를 사용하였고 어쩔수 없이 PHP 콜이 필요한 부분은 캐쉬를 사용하였다.</p>\n<p>캐쉬를 적용해 본것이 처음이었는데 캐쉬에 중요성과 캐쉬가 동작하는 개념을 알아야 할 필요성을 느꼈다.</p>\n<p>작업이 끝나고 스트레스 서버에 반영 하였다.</p>\n<h3>EC2 t2.micro → t2.medium 교체</h3>\n<p>처음에 부하를 돌려도 Scouter에 반응이 없었는데 알고보니 토큰만료와 User-Agent 값이 달라서 로그인이 안되서 그런것이었다. 수정하고 테스트를 하였는데도 TPS가 50 밖에 되지 않는 것이었다.</p>\n<p>실장님이 일단 공인망을 타는것을 내부망을 타도록 바꾸어 주셨고 서버 스펙도 t2.medium으로 교체하고 진행하였는데 TPS 320 !!! 통과다.</p>\n<p>실장님이 말씀하시길 처음에 구동될때 Java가 초기화 될때는 CPU나 메모리 점유율이 크지만 곧 안정되서 떨어지는 곡선에 개형을 나타나지만 PHP는 떨어지지 않고 계속 유지되고 있다고 하였다. 요청은 PHP서버에서 받고 있긴 하지만 이대목에서 정확히 왜그런지는 모르곘다.</p>\n<p>TODO 그라파냐 캡쳐사진 첨부</p>\n<p>Visual GC 원격 접속</p>\n<p>원격으로 부하테스트 서버에 접속하여 GC에 대한 모니터링을 할 수 있다.</p>\n<p>그 과정에서 터미널로 포트를 확인하는 과정이 있었는데 이러한 부분은 내가 아예 몰라서 공부가 필요하다.</p>\n<h3>어? 배너가 안나오네??</h3>\n<p>다음날은 광복절 휴일이었다… 제발 오늘은 아무일 없기를… 칼퇴해야지!! 하는데 역시나 버그가 발생하였다.<br>\n퇴근 약 1시간 전 이었고 얼른 끝내야 겠다는 마음으로 버그 원인을 조사하기 시작하였다. 특정 쿠기가 있으면 일반 배너가 나와야 하고 특정 쿠기가 없으면 사이즈가 큰 확장 배너가 나와야 하는데 확장 배너에서 이미지가 안나오고 그냥 html이 텍스트로 나오는 것이다.</p>\n<p>많은 삽질과 도움을 받아 버그는 해결 되었는데 해결 하는 과정 속에 문제 원인과 시간이 지체된 이유를 적어 본다.</p>\n<h3>PHP 코드를 잘 못 보고 있었다.</h3>\n<p>작업내용은 PHP 코드를 보고 JAVA 옮기는 것이었는데 a라는 파일 참고하여 개발하였는데 알고보니 수정된 a’ 파일이었던 것이다.<br>\n그래서 Java 코드를 다시 수정 하는것이 필요하였다. 하지만 빠르게 PHP코드를 이해하고 Java로 어떻게 구현할지 감이 잡히지 않았다. PHP에는 있어도 JAVA 영역에서는 굳이 필요없는 코드인데 그것도 옮기려는 뻘짓도 있었고 꼭 PHP코드를 그대로 복사하는 것이 아니라 이해하고 코딩을 했어야 했다. A-&gt;B-&gt;C 로 로직이 구현 되어 있어도 A-&gt;C 로 가는 좋은 방법이 있으면 그것을 구현하면 되는 것이다. 하지만 나는 PHP를 그대로 구현해야 탈이 없다는 것이 잠재되어 있었는지 PHP데로 하려고 이해하고 JAVA로 코드를 구현하려 보니 시간이 지체 되었다.</p>\n<h3>DB를 잘 못 보고 있었다.</h3>\n<p>구현하고 데이터를 확인하는데 디비랑 데이터가 다른것이다. 현상 특정 엔티티 프로퍼티에 값이 계속 null인 것이다. 많은 삽질 끝에 결국 DB주소를 잘 못 바라 보고 있었다…</p>\n<h3>하지만 그래도 원인은 그대로…</h3>\n<p>기존 PHP족 배너에서도 잘 나오던게 안나오고 있었고 이건 먼저 PHP쪽에 확인이 필요하였다. 결국 조치를 취하여 이제 배너는 나오게 된 상황이었다.</p>\n<h3>결국 개발자는 문제 해결 능력</h3>\n<p>배너는 나오고 있었지만 위에서 말했다 싶이 확장배너는 나오지 않았다. 특정 쿠키값을 지우면 나와야 하는데 안나오는 것이다. 옆에 선배 개발자님에게 도움을 받으며 문제를 하나하나 차근차근 까보기 시작했다. 지금 특정 쿠키를 지웠으니까 여기 조건으로 들어 왔을테고 근데 안나왔네? 그럼 PHP 소스를 보자아~~ 아 음… 아 여기 조건이 바뀌었네… 물론 이렇게 한방에 해서 해결 된건 아니었지만 문제 원인을 분석하기 위해 차근차근 하나씩 따져 보면서 접근하는 방식이 참 인상 깊었다. PHP랑 똑같이 했는데 안되면 그냥 스타일을 같이 먹여 보고 좀 이렇게 해보고 저렇게 해보고 그래서 결국 해내는 것 그 문제를 해결 하는 능력이 결국 개발자에 실력인것 같다.</p>\n<h3>그럼 나는 왜 스스로 문제를 해결하지 못했을까??</h3>\n<p>일단, 문제원인이 외부적인 문제도 있었다. 그럼 외부적이 문제가 무엇이었는지 파악을하고 질문을 하던지 공유를 하던지 해서 앞단에서 해결을 빨리 했어야 했는데 그러지 못헀다. 결국 <strong>이문제가 내부(나의 문제)인가 아님 외부 인가 부터 구별하는 혜안이 부족</strong>했던거 같다.</p>\n<p>코드를 확실히 이해하지 않은 상태에서 코드 수정하기 바빴다.<br>\n코드를 이해하고 이것이 의미하는 바가 무엇인지 확실하게 이해해야 하고 코드를 수정해야 하는데 일단 수정하고 결과 보고 아니면 이렇게 수정하고 결과보고 계속 쳇바퀴만 돌고 문제는 해결되지 않고 시간은 지체 되어 결국 도움을 요청하게 되었다.</p>\n<h3>느낀점, 그래서 앞으로는?</h3>\n<p><strong>적극적으로 이해하기 위해서 적극적으로 행동하자</strong></p>\n<p>물어보는게 제일 빠르다<br>\n다른 사람이 작성한 코드나 잘 모르는 업무라면 그 업무 담당자에게 확실하게 물어보자. 물어 볼때는 최대한 많이 정보를 얻기 위해서 무엇을 물어볼지 적어놓자. 그리고 이왕이면 내 자리로 데리고 와서 모니터 화면을 보면서 빠르게 이해시켜주면서 정보를 얻는것이 제일 좋다.</p>\n<p><strong>코드가 의미하는 바가 무엇인지 확실히 이해한다.</strong></p>\n<p>함부로 또는 건성으로 코드를 이해했다고 넘어가면 안된다.<br>\n정말 어떠한 문맥에서 이러한 코드를 작성했는지 무엇을 위해서 코드를 작성헀는지 확실히 이해하는 활동을 반드시 해야 한다.</p>\n<p><strong>개인공부는 업무를 하면서 잘 안된것들과 배운 경험들에 연장선에서 공부하자</strong><br>\n결국 내가 지금 하고 있는 업무를 잘하면 된다. 그것들을 잘 습득해야 나중에 제대로 활용 할 수 있고 더 잘 할 수 있게 된다.<br>\n업무에서 잘 사용하지 않고 있는데 미리 공부한 지식들은 금방 까먹고 밑빠진 독에 물붓기가 되는 셈이다.</p>\n<p><strong>압박감 속에서 문제를 해결하는 능력이 진짜 능력이다.</strong><br>\n사람들이 다 보고 있다. 나만 지켜 보고 있다. 부담감이 들고 내 행동 하나에 초점이 맞춰저 있어 되게 신경쓰인다.<br>\n하지만 일하면서 그러한 상황은 얼마든지 올 수 있다. 그러한 것들을 신경쓰지 않고 내 페이스를 유지하면서 정확하고 빠르게 생각하여 문제 원인을 찾고 해결하는 능력을 키우기 위해 의식적으로 노력해야 한다. 그럴려면 <strong>일할때나 개인 공부 할 때 시간을 재고 문제를 해결 한다는지 주위에 사람이 있다 항상 생각하고 문제를 푼다는지 하는 전략</strong>으로 해야 할 것 같다.</p>\n"}],"PostAsset":[{"_id":"source/_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post-quartz-clustering-mode-test.png","slug":"post-quartz-clustering-mode-test.png","post":"cl8oids05000gk0otom7uq6yw","modified":0,"renderable":0},{"_id":"source/_drafts/IDC에서 클라우드로/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oidryl0001k0ot7tacx1qy","modified":0,"renderable":0},{"_id":"source/_drafts/docker compose 로 ngnix, spring boot, mysql 띄우기/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oidryr0005k0otlicxwlmf","modified":0,"renderable":0},{"_id":"source/_drafts/Jenkins과 AWS로 코드가 빌드 배포되는 과정/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oidryp0003k0ot6ot2jykn","modified":0,"renderable":0},{"_id":"source/_drafts/Jenkins과 AWS로 코드가 빌드 배포되는 과정/jenkins-deploy-process.png","slug":"jenkins-deploy-process.png","post":"cl8oidryp0003k0ot6ot2jykn","modified":0,"renderable":0},{"_id":"source/_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post-quartz-clustering-mode-log.png","slug":"post-quartz-clustering-mode-log.png","post":"cl8oids05000gk0otom7uq6yw","modified":0,"renderable":0},{"_id":"source/_posts/OOP/객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유/object-1.png","slug":"object-1.png","post":"cl8oids10001gk0otbf7g1wsj","modified":0,"renderable":0},{"_id":"source/_posts/ETC/서버가 여러대 있때 redirect 사용시 발생하는 문제/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids0f000ok0ot57tgl2sq","modified":0,"renderable":0},{"_id":"source/_posts/JPA/JPA 커스텀 리파지토리 만드는 방법/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids0s0012k0otmhtw8a9g","modified":0,"renderable":0},{"_id":"source/_posts/JPA/JPA 쿼리에 대해서/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids0v0018k0otzzas3e39","modified":0,"renderable":0},{"_id":"source/_posts/OOP/01 객체,설계/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids0x001ak0otxs44og5a","modified":0,"renderable":0},{"_id":"source/_posts/OOP/02 객체 지향 프로그래밍/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids0y001dk0otqzxz4913","modified":0,"renderable":0},{"_id":"source/_posts/메타인지/[meta] 개발자 논리적인 사고력에 대해서/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids1b001yk0otv9p35l6m","modified":0,"renderable":0},{"_id":"source/_posts/메타인지/[meta] 개발자 어떻게 공부 해야 할까/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids1d0022k0otrt8ulo4c","modified":0,"renderable":0},{"_id":"source/_posts/OOP/객체지향 캡슐화 그것이 알고 싶다/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids15001ok0otg0gjqn5b","modified":0,"renderable":0},{"_id":"source/_posts/Docker/Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids0h000rk0otqqv621mm","modified":0,"renderable":0},{"_id":"source/_posts/Docker/Mac에서도 Window 에서도 도커로 동일한 Mysql DB 환경 만들기/docker-error.png","slug":"docker-error.png","post":"cl8oids0h000rk0otqqv621mm","modified":0,"renderable":0},{"_id":"source/_posts/OOP/객체 설계 할 때 데이터 중심이 아닌 책임 중심으로 해야 하는 이유/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids10001gk0otbf7g1wsj","modified":0,"renderable":0},{"_id":"source/_posts/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids07000jk0ott3uryz5b","modified":0,"renderable":0},{"_id":"source/_posts/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편/observer-result.png","slug":"observer-result.png","post":"cl8oids07000jk0ott3uryz5b","modified":0,"renderable":0},{"_id":"source/_posts/Design Patterns/[Design Patterns] 옵저버 패턴, 도대체 왜 쓰는거야-기본 이론편/observer.png","slug":"observer.png","post":"cl8oids07000jk0ott3uryz5b","modified":0,"renderable":0},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids09000kk0ot7q6njay7","modified":0,"renderable":0},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편/factory-pattern.png","slug":"factory-pattern.png","post":"cl8oids09000kk0ot7q6njay7","modified":0,"renderable":0},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-기본 이론편/simple-factory.png","slug":"simple-factory.png","post":"cl8oids09000kk0ot7q6njay7","modified":0,"renderable":0},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids0k000tk0otx36sh04z","modified":0,"renderable":0},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편/factory-pattern.png","slug":"factory-pattern.png","post":"cl8oids0k000tk0otx36sh04z","modified":0,"renderable":0},{"_id":"source/_posts/Design Patterns/[Design Patterns] 팩토리 패턴, 도대체 왜 쓰는거야-실전 적용편/simple-factory.png","slug":"simple-factory.png","post":"cl8oids0k000tk0otx36sh04z","modified":0,"renderable":0},{"_id":"source/_posts/OOP/객체 지향 설계 5대 원칙/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids12001jk0oth4t7v4jw","modified":0,"renderable":0},{"_id":"source/_posts/OOP/객체 지향 설계 5대 원칙/srp-1.png","slug":"srp-1.png","post":"cl8oids12001jk0oth4t7v4jw","modified":0,"renderable":0},{"_id":"source/_posts/OOP/객체 지향 설계 5대 원칙/srp-2.png","slug":"srp-2.png","post":"cl8oids12001jk0oth4t7v4jw","modified":0,"renderable":0},{"_id":"source/_posts/JPA/JPA N+1 문제 해결 방법/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids0o000wk0ot1auok7fr","modified":0,"renderable":0},{"_id":"source/_posts/JPA/JPA N+1 문제 해결 방법/jpa_entity_graph.jpg","slug":"jpa_entity_graph.jpg","post":"cl8oids0o000wk0ot1auok7fr","modified":0,"renderable":0},{"_id":"source/_posts/JPA/JPA N+1 문제 해결 방법/jpa_fetch_join.jpg","slug":"jpa_fetch_join.jpg","post":"cl8oids0o000wk0ot1auok7fr","modified":0,"renderable":0},{"_id":"source/_posts/JPA/JPA N+1 문제 해결 방법/jpa_n_plus_one.jpg","slug":"jpa_n_plus_one.jpg","post":"cl8oids0o000wk0ot1auok7fr","modified":0,"renderable":0},{"_id":"source/_posts/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/OS_process.png","slug":"OS_process.png","post":"cl8oids0u0015k0otqltg3xu3","modified":0,"renderable":0},{"_id":"source/_posts/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/OS_process_code.png","slug":"OS_process_code.png","post":"cl8oids0u0015k0otqltg3xu3","modified":0,"renderable":0},{"_id":"source/_posts/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/OS_register.png","slug":"OS_register.png","post":"cl8oids0u0015k0otqltg3xu3","modified":0,"renderable":0},{"_id":"source/_posts/OS/[OS] 내가 작성한 코드가 메모리에서 어떻게 실행 될까/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids0u0015k0otqltg3xu3","modified":0,"renderable":0},{"_id":"source/_posts/OOP/상속보다는 합성을 사용해야 하는 이유/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids17001rk0oth2bzdn8z","modified":0,"renderable":0},{"_id":"source/_posts/OOP/상속보다는 합성을 사용해야 하는 이유/inherit-reason1.png","slug":"inherit-reason1.png","post":"cl8oids17001rk0oth2bzdn8z","modified":0,"renderable":0},{"_id":"source/_posts/OOP/상속보다는 합성을 사용해야 하는 이유/inherit-reason2.png","slug":"inherit-reason2.png","post":"cl8oids17001rk0oth2bzdn8z","modified":0,"renderable":0},{"_id":"source/_posts/OOP/상속보다는 합성을 사용해야 하는 이유/inherit-reason3.png","slug":"inherit-reason3.png","post":"cl8oids17001rk0oth2bzdn8z","modified":0,"renderable":0},{"_id":"source/_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids05000gk0otom7uq6yw","modified":0,"renderable":0},{"_id":"source/_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post-quartz-clustering-mode-example.png","slug":"post-quartz-clustering-mode-example.png","post":"cl8oids05000gk0otom7uq6yw","modified":0,"renderable":0},{"_id":"source/_posts/ETC/[quartz] 실시간 배치 동적 스케줄러 사용기/post_clustering.jpg","slug":"post_clustering.jpg","post":"cl8oids05000gk0otom7uq6yw","modified":0,"renderable":0},{"_id":"source/_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids0q000yk0ot7jlol0cv","modified":0,"renderable":0},{"_id":"source/_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/dynamic-update1.png","slug":"dynamic-update1.png","post":"cl8oids0q000yk0ot7jlol0cv","modified":0,"renderable":0},{"_id":"source/_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/dynamic-update2.png","slug":"dynamic-update2.png","post":"cl8oids0q000yk0ot7jlol0cv","modified":0,"renderable":0},{"_id":"source/_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/jpql-flush.png","slug":"jpql-flush.png","post":"cl8oids0q000yk0ot7jlol0cv","modified":0,"renderable":0},{"_id":"source/_posts/JPA/JPA 영속성 컨텍스트 엔티티 관리 방법/write-lazy.png","slug":"write-lazy.png","post":"cl8oids0q000yk0ot7jlol0cv","modified":0,"renderable":0},{"_id":"source/_posts/메타인지/[meta] 새로운 개념 어떻게 습득해야 할까/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids1v002lk0otqywmshz4","modified":0,"renderable":0},{"_id":"source/_posts/Spring/IoC, DI란 무엇일까/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids27002pk0otxpbncnhp","modified":0,"renderable":0},{"_id":"source/_posts/Spring/Spring AOP 적용시 주의사항/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids28002qk0ot7cko30zm","modified":0,"renderable":0},{"_id":"source/_posts/Spring/Spring Validation 처리 방법/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids2b002uk0otyucxawh3","modified":0,"renderable":0},{"_id":"source/_posts/회고/2018년 회고/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids1t002kk0ot7s55euai","modified":0,"renderable":0},{"_id":"source/_posts/회고/2018년 회고/evernote.png","slug":"evernote.png","post":"cl8oids1t002kk0ot7s55euai","modified":0,"renderable":0},{"_id":"source/_posts/회고/2019년도 첫 실천 1월 회고/1_notion.png","slug":"1_notion.png","post":"cl8oids2a002tk0otlsmkwbsb","modified":0,"renderable":0},{"_id":"source/_posts/회고/2019년도 첫 실천 1월 회고/bg_computer.jpg","slug":"bg_computer.jpg","post":"cl8oids2a002tk0otlsmkwbsb","modified":0,"renderable":0},{"_id":"source/_posts/회고/2019년도 첫 실천 1월 회고/score.png","slug":"score.png","post":"cl8oids2a002tk0otlsmkwbsb","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cl8oids12001jk0oth4t7v4jw","category_id":"cl8oids0z001ek0otzse6gtl6","_id":"cl8oids17001sk0otlrivrdtt"},{"post_id":"cl8oids0x001ak0otxs44og5a","category_id":"cl8oids0z001ek0otzse6gtl6","_id":"cl8oids1a001vk0otsshkzsuo"},{"post_id":"cl8oids15001ok0otg0gjqn5b","category_id":"cl8oids0z001ek0otzse6gtl6","_id":"cl8oids1c001zk0ot6sngz8j7"},{"post_id":"cl8oids0y001dk0otqzxz4913","category_id":"cl8oids0z001ek0otzse6gtl6","_id":"cl8oids1e0023k0otlu2jh3uu"},{"post_id":"cl8oids17001rk0oth2bzdn8z","category_id":"cl8oids0z001ek0otzse6gtl6","_id":"cl8oids1f0026k0otk99pscnx"},{"post_id":"cl8oids10001gk0otbf7g1wsj","category_id":"cl8oids0z001ek0otzse6gtl6","_id":"cl8oids1g0028k0ot0h2ok3z1"}],"PostTag":[{"post_id":"cl8oidryl0001k0ot7tacx1qy","tag_id":"cl8oidryr0004k0otgpjkm2nz","_id":"cl8oidryu0007k0otxvhmzrr2"},{"post_id":"cl8oidryp0003k0ot6ot2jykn","tag_id":"cl8oidryr0004k0otgpjkm2nz","_id":"cl8oidryw0009k0otdd8715mj"},{"post_id":"cl8oidryr0005k0otlicxwlmf","tag_id":"cl8oidryv0008k0otyase3rqd","_id":"cl8oidryy000ak0othbzaeseo"},{"post_id":"cl8oids02000dk0ot8m14d89d","tag_id":"cl8oids04000fk0otjt8k12yx","_id":"cl8oids0b000mk0otqpepatph"},{"post_id":"cl8oids0f000ok0ot57tgl2sq","tag_id":"cl8oidryr0004k0otgpjkm2nz","_id":"cl8oids0k000sk0otwuememu6"},{"post_id":"cl8oids0h000rk0otqqv621mm","tag_id":"cl8oidryv0008k0otyase3rqd","_id":"cl8oids0n000vk0ot3psifpe0"},{"post_id":"cl8oids05000gk0otom7uq6yw","tag_id":"cl8oids0a000lk0otrbxajc76","_id":"cl8oids0p000xk0ot4upbze52"},{"post_id":"cl8oids05000gk0otom7uq6yw","tag_id":"cl8oids0g000qk0otmvvxa030","_id":"cl8oids0r0010k0otjp02ack1"},{"post_id":"cl8oids0o000wk0ot1auok7fr","tag_id":"cl8oidryv0008k0otyase3rqd","_id":"cl8oids0t0014k0otfybut04h"},{"post_id":"cl8oids07000jk0ott3uryz5b","tag_id":"cl8oids0n000uk0otl5dy2272","_id":"cl8oids0v0016k0otcinkwnd0"},{"post_id":"cl8oids0q000yk0ot7jlol0cv","tag_id":"cl8oidryv0008k0otyase3rqd","_id":"cl8oids0w0019k0otqcxiejer"},{"post_id":"cl8oids0s0012k0otmhtw8a9g","tag_id":"cl8oidryv0008k0otyase3rqd","_id":"cl8oids0y001bk0otgt28rxj4"},{"post_id":"cl8oids09000kk0ot7q6njay7","tag_id":"cl8oids0n000uk0otl5dy2272","_id":"cl8oids10001fk0otyrit4t8c"},{"post_id":"cl8oids0v0018k0otzzas3e39","tag_id":"cl8oidryv0008k0otyase3rqd","_id":"cl8oids11001hk0ot8ljxuiiy"},{"post_id":"cl8oids0c000nk0ot3atzibed","tag_id":"cl8oids0n000uk0otl5dy2272","_id":"cl8oids13001kk0ot0z00hir4"},{"post_id":"cl8oids0k000tk0otx36sh04z","tag_id":"cl8oids0n000uk0otl5dy2272","_id":"cl8oids15001nk0otkh2kjhio"},{"post_id":"cl8oids0u0015k0otqltg3xu3","tag_id":"cl8oids11001ik0otgczr8fzl","_id":"cl8oids16001qk0otmh2f51p6"},{"post_id":"cl8oids17001rk0oth2bzdn8z","tag_id":"cl8oids16001pk0ot6oalo3sq","_id":"cl8oids1b001xk0ot1q8q8yzm"},{"post_id":"cl8oids0x001ak0otxs44og5a","tag_id":"cl8oids16001pk0ot6oalo3sq","_id":"cl8oids1d0021k0otqdal2b6w"},{"post_id":"cl8oids0y001dk0otqzxz4913","tag_id":"cl8oids16001pk0ot6oalo3sq","_id":"cl8oids1g0027k0otkvoxdqc5"},{"post_id":"cl8oids10001gk0otbf7g1wsj","tag_id":"cl8oids16001pk0ot6oalo3sq","_id":"cl8oids1h002ak0ot4q8xzezd"},{"post_id":"cl8oids1b001yk0otv9p35l6m","tag_id":"cl8oids1g0029k0oti58vhqa1","_id":"cl8oids1i002ek0ot6wvd75w9"},{"post_id":"cl8oids1b001yk0otv9p35l6m","tag_id":"cl8oids1h002ck0otqdhhdqq3","_id":"cl8oids1j002fk0otznuddigd"},{"post_id":"cl8oids1b001yk0otv9p35l6m","tag_id":"cl8oids16001pk0ot6oalo3sq","_id":"cl8oids1k002hk0otqh0qiao7"},{"post_id":"cl8oids1d0022k0otrt8ulo4c","tag_id":"cl8oids1g0029k0oti58vhqa1","_id":"cl8oids1k002ik0ot8bbb37l0"},{"post_id":"cl8oids1d0022k0otrt8ulo4c","tag_id":"cl8oids1h002ck0otqdhhdqq3","_id":"cl8oids1k002jk0otgi6n6xgm"},{"post_id":"cl8oids1v002lk0otqywmshz4","tag_id":"cl8oids1h002ck0otqdhhdqq3","_id":"cl8oids26002ok0otqk8vgsns"},{"post_id":"cl8oids1t002kk0ot7s55euai","tag_id":"cl8oids1w002mk0otrn658098","_id":"cl8oids2a002sk0otv68s125q"},{"post_id":"cl8oids2a002tk0otlsmkwbsb","tag_id":"cl8oids1w002mk0otrn658098","_id":"cl8oids2c002wk0otrppub5b2"},{"post_id":"cl8oids1z002nk0ot4d5cs6ri","tag_id":"cl8oids1w002mk0otrn658098","_id":"cl8oids2d002yk0otc02lxeza"},{"post_id":"cl8oids2d002xk0otm22mdd1a","tag_id":"cl8oids1w002mk0otrn658098","_id":"cl8oids2f0031k0otupvkeofz"},{"post_id":"cl8oids28002qk0ot7cko30zm","tag_id":"cl8oids2c002vk0otyo4g648a","_id":"cl8oids2h0035k0oto40fvdx3"},{"post_id":"cl8oids28002qk0ot7cko30zm","tag_id":"cl8oids2f0030k0otmxcvn2qm","_id":"cl8oids2i0036k0otyzti7o74"},{"post_id":"cl8oids2b002uk0otyucxawh3","tag_id":"cl8oids2c002vk0otyo4g648a","_id":"cl8oids2j0039k0othuk55brh"},{"post_id":"cl8oids2b002uk0otyucxawh3","tag_id":"cl8oids2f0030k0otmxcvn2qm","_id":"cl8oids2j003ak0ot6h9d4qbf"}],"Tag":[{"name":"Experience","_id":"cl8oidryr0004k0otgpjkm2nz"},{"name":"Learnning","_id":"cl8oidryv0008k0otyase3rqd"},{"name":"API","_id":"cl8oids04000fk0otjt8k12yx"},{"name":"Library","_id":"cl8oids0a000lk0otrbxajc76"},{"name":"Quartz","_id":"cl8oids0g000qk0otmvvxa030"},{"name":"Design Patterns","_id":"cl8oids0n000uk0otl5dy2272"},{"name":"OS","_id":"cl8oids11001ik0otgczr8fzl"},{"name":"Book","_id":"cl8oids16001pk0ot6oalo3sq"},{"name":"개발일반","_id":"cl8oids1g0029k0oti58vhqa1"},{"name":"메타","_id":"cl8oids1h002ck0otqdhhdqq3"},{"name":"회고","_id":"cl8oids1w002mk0otrn658098"},{"name":"Framework","_id":"cl8oids2c002vk0otyo4g648a"},{"name":"Spring","_id":"cl8oids2f0030k0otmxcvn2qm"}]}}