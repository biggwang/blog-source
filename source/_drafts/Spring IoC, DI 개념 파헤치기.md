---
title: Spring IoC, DI 개념 파헤치기
catalog: true
date: 2019-08-22 21:53:55
subtitle: 
header-img: "bg_computer.jpg"
catagories:
- Spring
---

### 목표

- Spring IoC, DI가 무엇인지 이해시킨다.
- Spring DI에 장단점을 이해시킨다.
- Bean이란 무엇이고 Container에서 어떻게 관리되고 생명주기는 어떻게 되는지 이해시킨다.

### IoC (Inversion of Control) 란 무엇인가?

IoC에 용어는 90년 중반에 GoF의 디자인패턴에서도 이용어가 언급되었다고 합니다. 즉, IoC는 Spring에서 나온 용어가 아닙니다. 과거 EJB에서도 WAS에 Servlet Container에서도 사용 된 개념이죠.  

IoC에 대한 개념은 굉장히 폭이 넓습니다.  
해석하면 제어의 역전입니다. 도대체 어떤 제어를 말하는 것이며 무엇을 역전한다는 말 일까요??

아래 코드부터 바로 보시죠

아래는 개발자가 직접 객체를 생성하여 코드를 제어하는 코드입니다.
~~~ java
public class A {

    private B b;

    public A()
        b = new B();
    }
}
~~~

위와 같이 B클래스를 직접 인스턴스하여 의존관계를 나타내고 있습니다. 즉 개발자가 직접 객체를 제어하여 A객체는 B객체에게 의존하고 있어 라고 클래스를 통해 표현하고 있는것 이죠

이것은 개발자가 직접 한 것입니다. 하지만 아래 코드는 어떨까요??

컨테이너에 의해서 생성한 객체를 사용만 하는 코드

~~~ java
public class A {
d
    @Autowired
    private B b;

}
~~~

스프링 사용자라면 잘알고 있는 표현입니다.
B라는 객체가 스프링 컨테이너에게 관리되고 있는 Bean이라면 @Autowired 를 통해 객체를 주입받을수 있게 되죠
이것은 개발자가 직접 객체를 관리하지 않고 스프링 컨테이너에서 직접(제어) 객체를 생성하여 해당 객체에 주입 시켜준 것입니다.

이것이 바로 제어가 역전되었다. IoC 라는 개념입니다. 또 다른 예를 들어볼까요??


디자인패턴인 템플릿 메소드 패턴에서도 IoC 개념을 찾아 볼 수 있습니다. 이처럼 IoC는 거시적인 개념이 아닌 프로그램을 제어권을 누가 가져갈것인가에 대한 프로그래밍 모델일 뿐입니다. 아래 코드를 한번 보죠

~~~ java
public abstract class IronFactory {

    private IronMan ironMan;

    public IronMan getIronMan () {
        return assemble();
    }

    /**
     * 제어권은 상위 클래스에게 있다.
     * 하위 클래스에서 구현한 코드는 상위 클래스가 어떻게 되는지 모른다. 단지 구현해야하는 부분을  
    **/
    private IronMan assemble() {
        // do assemble.. from head, body, arms, legs
        return ironMan;
    }

    protected abstract void head();
    protected abstract void body();
    protected abstract void arms();
    protected abstract void legs();
}
~~~

~~~ java
public classs HulkBuster extends IronFactory {

    @Override
    public void head() {
        // do something..
    }

    @Override
    public void body() {
        // do something..
    }

    @Override
    public void arms() {
        // do something..
    }

    @Override
    public void legs() {
        // do something..
    }
}
~~~

제어권은 상위 클래스인 IronFactory에게 있습니다.
하위 클래스에서 구현한 코드는 상위 클래스가 어떻게 되는지 모른다. 단지 구현해야하는 부분을 구현하였고 구현한 코드가 언제 어떻게 실행 될지는 모른다. 상위 클래스에서 알아서 필요할 때 구현한 메소드를 사용하는 것이다. 바로 이처럼 코드 흐름이 제3자에게 위임되는 것이 IoC 모델이라고 합니다.

IoC 개념은 스프링에서 나온 개념이 아니라 예전부터 사용되었던 개념입니다. 서블릿 컨테이너 또한 IoC를 통한 서블릿을 관리하고 있죠.


### 그럼 왜 IoC를 Spring에서 사용 하였을까요? 분명히 이점이 있을텐데요

IoC 프로그램 모델은 곧 역활과 책임에 분리라는 내용과 관련이 있다고 생각합니다.
왜 내가 직접 객체를 제어 하지 않고 다른 제 3자가 제어를 위임하게 하고 나는 수동적으로 따라가는 길을 택하였을까요??

이는 객체지향 프로그래밍과 아주 관련이 깊다고 생각합니다. 객체지향 프로그래밍은 각 객체마다 자기의 역활과 책임을 온전히 다하며 서로 협력하며 변경에 유연한 프로그래밍을 할 수 있는 프로그래밍 기법입니다. 즉, 각 객체마다 올바른 캡슐화를 통해 높은 응집도와 낮은 결합도를 이루어나가는 것이 핵심중에 핵심이죠.

이러한 관점에서 제어의 역전으로 인해 제 3자 즉 다른 객체, 다른 컨테이너에게 제어에 대한 역활과 책임을 위임하고 다시말해 신경쓰지 않고 지금 내가 하고자 하는 역활과 책임에 관심이 있는것이죠. 왜 이렇게 할까요? 답은 **변경에 유연한 코드 구조를 가져가기 위해서**입니다. 내가 작성하고자 하는 코드에서 객체를 생성, 소멸 등에 관리 코드와 함께 비지니스 코드까지 들어가면 어떨까요??  

기능은 얼마든지 변경될 수 있습니다. 자, A라는 객체를 생성하고 있었는데 A객체는 삭제하고 B객체를 추가해야 한다고 하면 어떻게 될까요?? 뭐 한 곳에서만 객체 생성을 추가했다면 한 곳에서만 변경하면 되겠죠.. 그럼 10곳에서 A라는 객체를 사용하였다고 해보죠. 그럼 10번을 수정해줘야 겠네요?   

또 다른 예를 들어보죠. 객체 생명 주기를 직접 관리하기 때문에 객체 생성, 삭제를 직접 할 수 있습니다. 근데 도메인 모델상 객체 삭제는 절대 하면 안된다고 해보죠. 하지만 직접 개발자가 객체를 핸들링 할 수 있기 때문에 삭제하거나 아니면 새로운 객체를 생성 할 수 도 있습니다. 다시 말해서 권한이 너무 많다는 것입니다. 이것은 곧 캡슐화 위반을 일으킨 것입니다.

**자 그럼 질문을 다시 해보겠습니다. IoC 왜 제어를 역전 시켰을까요? 어떤 이점일까요?**  

객체를 관리해주는 독릭적인 존재와 그 외 내가 구현 하고자 하는 부분에 관심을 두고 서로에 역화을 충실히하면서 변경에 유연한 코드를 작성 할 수 있는 구조이기 때문에 제어를 역전 하였다. 저는 이렇게 생각하였습니다.

그럼 구체적으로 Spring에서 IoC를 어떻게 사용했는지 확인해 보도록 하겠습니다.


### 그럼 Spring IoC는 무엇을 의미하는 걸까요?

위에서 말했다싶이 IoC는 객체 생명 관리, 흐름 제어를 제 3자에게 위임하는 프로그래밍 모델입니다. 디자인 패턴인 템플릿 메소드 패턴에서도 IoC 개념을 찾아 볼 수 있죠.  
하지만 이런 디자인 패턴이 적용된 것을 가지고 Spring 에서 IoC, IoC 할까요? 좀 더 핵심적인 의미가 있지 않을까요? 그 핵심적인 의미는 DI에서 찾아 볼 수 있습니다.

DI에 대해서 알아보죠.

### DI (Dependency Injection) 란?

> 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의존관계 주입이라는 새로운 영어를 사용할 때 분명하게 드러난다. 생략..  
DI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심  - 토비스프링

DI는 IoC 프로그래밍 모델을 구현하는 방식중에 하나입니다.  
Spring 에서는 IoC를 구체적으로 DI라는 방식을통해서 의존성 역전 제어를 하고 있는 것이죠. 우선, 용어를 하나하나 분석해 보겠습니다.

**의존성**  
프로그래밍에서 의존한다는 말은 서로 다른 객체간에 레퍼런스 참조가 되어 있다는 말입니다. 이는 A -> B에 의존 관계에 있을 때, B객체에 변경사항이 생겼을 때, A 객체가 영향을 받는 구조인 것이죠.  

~~~ java
public class A {

    private B b = new B();

    public void anyMethod() {
        b.~~
    }
}
~~~

**주입**
주입이란 단어를 생각하면 주사 맞는 이미지가 연상되는데요.  
외부로부터 객체의 주소(레퍼런스) 값을 전달 받게 되어 객체가 참조 되어지는 방식입니다.  

다시 돌아와서 그럼 의존성 주입이라는 말은 어떤 말일까요? 
의존관계에 있는 객체들이 있을 때, 외부(스프링컨테이너)에서 객체에 레퍼런스를 전달하여 사용하고자 하는 객체에서 코드를 작성 할 수 있게 한다.  

### 그럼 IoC와 DI 무엇이 다른걸까요??

토비스프링에서 인용한 문구를 다시 보여드리겠습니다.

> DI는 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심 ..생략..
주입받는 메소드 따라미터가 이미 특정 클래스 타입으로 고정되어 있다면 DI가 일어날 수 없다. DI에서 말하는 주입은 다이내믹하게 구현 클래스를 결정해서 제공받을 수 있도록 인터페이스 타입 의 파라미터를 통해 이뤄져야 한다.

**핵심은 DI는 클래스타입이 고정되어 있지 않고 인터페이스 타입의 파라미터를 통해 다이나믹하게 구현 클래스를 결정해서 제공 받을수 있어야 한다.**

이것이 바로 DI에 핵심개념입니다. 코드를 통해서 바로 알아보겠습니다.   

~~~ java
public class IronManController {

    @Autowired
    private IronManService;

    // 생략

}
~~~


~~~ java
public interface IronManService {

    void attack();
    void flying();
}
~~~


~~~ java
public class HulkBuster implements IronManService {

    @Override
    public void attack() {
        System.out.println("헐크버스터 공격!");
    }
    // 생략
}
~~~

~~~ java
public class Mark15 implements IronManService {

    @Override
    public void attack() {
        System.out.println("나노입자 아이언맨 공격!");
    }
    // 생략
}
~~~

DI라는 개념또한 스프링에서 나온 개념이 아닙니다.



### 컨테이너란?

컨테이너란 말이 계속 나오고 있는데 컨테이너란 무엇일까요?? 

위에서 설명했듯이 IoC는 컨테이너에서 이루어지고 있습니다. 즉, 컨테이너는 객체에 대한 생성, 소멸 등 생명 주기를 관리하면서 코드에 대한 제어를 직접 핸들링하는 주체라고 말할수 있습니다.
코드의 흐름을 개발자가 직접관리하는 옛날과 달리 큰 코드흐름은 컨테이너라는 독립적인 주체에게 맡기어 개발자는 비지니스에 구현에만 집중할수있게 되는것이죠

### IoC와 DI에 차이점

차이점이 무엇일까요?? 다시말하지만 IoC에 개념은 Spring으로 부터 나온것이 아닙니다.

EJB, Servlet Container에서도 나오는 개념입니다.

IoC에 대한 개념을 구현하는 방법중에 DI, DL 등등이 있는것입니다.

즉 DI는 IoC에 개념을 구현하는 방법중에 하나인것입니다. 그중 Spring 에서는 DI라는 방식을 사용하고 있습니다.



### 생성자 주입은 언제 사용할까??

### Setter 주입은 언제 사용할까??

### 그럼 왜 Spring 장점이 IoC, DI라 할까?? 예전에도 있던 개념인데